{{- /*
  File: templates/migration-configmap.yaml
  Purpose: ConfigMap containing all database migration files
  STATUS: DISABLED - Using content-only migration instead
*/ -}}
{{- if true }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "migrate.fullname" . }}-migrations
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "migrate.labels" . | nindent 4 }}
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-weight": "-15"  # Run before the main configmap
    {{- with .Values.commonAnnotations }}
    {{- toYaml . | nindent 4 }}
    {{- end }}
data:
  # Migration files from db/migrations/ directory
  000001_create_feeds_table.up.sql: |
    CREATE TABLE IF NOT EXISTS feeds (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        title TEXT NOT NULL,
        description TEXT NOT NULL,
        link TEXT NOT NULL,
        pub_date TIMESTAMP NOT NULL,
        created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
    );

    CREATE INDEX IF NOT EXISTS idx_feeds_created_at ON feeds (created_at);
    CREATE INDEX IF NOT EXISTS idx_feeds_id_link ON feeds (id, link);

  000001_create_feeds_table.down.sql: |
    DROP TABLE IF EXISTS feeds;

  000002_create_feed_links.up.sql: |
    CREATE TABLE IF NOT EXISTS feed_links (
        id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
        url TEXT NOT NULL UNIQUE,
        CONSTRAINT idx_feed_links_id_url UNIQUE (id, url)
    );

  000002_create_feed_links.down.sql: |
    DROP TABLE IF EXISTS feed_links;

  000003_add_unique_constraint_feeds_link.up.sql: |
    DO $$
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'unique_feeds_link') THEN
            ALTER TABLE feeds ADD CONSTRAINT unique_feeds_link UNIQUE (link);
        END IF;
    END
    $$;

  000003_add_unique_constraint_feeds_link.down.sql: |
    ALTER TABLE feeds DROP CONSTRAINT IF EXISTS unique_feeds_link;

  000004_create_read_status_table.up.sql: |
    CREATE TABLE IF NOT EXISTS read_status (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        feed_id UUID NOT NULL,
        user_id UUID NOT NULL,
        is_read BOOLEAN NOT NULL DEFAULT FALSE,
        created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (feed_id) REFERENCES feeds(id) ON DELETE CASCADE
    );

  000004_create_read_status_table.down.sql: |
    DROP TABLE IF EXISTS read_status;

  000005_add_composite_index_read_status.up.sql: |
    CREATE INDEX IF NOT EXISTS idx_read_status_feed_user ON read_status (feed_id, user_id);

  000005_add_composite_index_read_status.down.sql: |
    DROP INDEX IF EXISTS idx_read_status_feed_user;

  000006_add_partial_index_read_status.up.sql: |
    CREATE INDEX IF NOT EXISTS idx_read_status_unread ON read_status (feed_id, user_id) WHERE is_read = FALSE;

  000006_add_partial_index_read_status.down.sql: |
    DROP INDEX IF EXISTS idx_read_status_unread;

  000007_create_articles_table.up.sql: |
    CREATE TABLE IF NOT EXISTS articles (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        title TEXT NOT NULL,
        content TEXT NOT NULL,
        url TEXT NOT NULL UNIQUE,
        created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
    );

    CREATE INDEX IF NOT EXISTS idx_articles_created_at ON articles (created_at);
    CREATE INDEX IF NOT EXISTS idx_articles_title_created_at ON articles (title, created_at);
    CREATE INDEX IF NOT EXISTS idx_articles_title ON articles (title);

  000007_create_articles_table.down.sql: |
    DROP TABLE IF EXISTS articles;

  000008_create_preprocessor_user.up.sql: |
    -- Create pre_processor_user if it doesn't exist
    DO $$
    BEGIN
        IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = 'pre_processor_user') THEN
            CREATE USER pre_processor_user WITH PASSWORD 'pre_processor_password';
        END IF;
    END
    $$;

  000008_create_preprocessor_user.down.sql: |
    -- Drop pre_processor_user if it exists
    DROP USER IF EXISTS pre_processor_user;

  000009_grant_preprocessor_permissions.up.sql: |
    GRANT SELECT, INSERT, UPDATE, DELETE ON articles TO pre_processor_user;
    GRANT SELECT, INSERT, UPDATE, DELETE ON feeds TO pre_processor_user;
    GRANT SELECT, INSERT, UPDATE, DELETE ON feed_links TO pre_processor_user;

  000009_grant_preprocessor_permissions.down.sql: |
    REVOKE SELECT, INSERT, UPDATE, DELETE ON articles FROM pre_processor_user;
    REVOKE SELECT, INSERT, UPDATE, DELETE ON feeds FROM pre_processor_user;
    REVOKE SELECT, INSERT, UPDATE, DELETE ON feed_links FROM pre_processor_user;

  000010_create_article_summaries_table.up.sql: |
    CREATE TABLE IF NOT EXISTS article_summaries (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        article_id UUID NOT NULL,
        summary TEXT NOT NULL,
        created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (article_id) REFERENCES articles(id) ON DELETE CASCADE
    );

    CREATE INDEX IF NOT EXISTS idx_article_summaries_article_id ON article_summaries (article_id);

  000010_create_article_summaries_table.down.sql: |
    DROP TABLE IF EXISTS article_summaries;

  000011_grant_preprocessor_article_summaries_permissions.up.sql: |
    GRANT SELECT, INSERT, UPDATE, DELETE ON article_summaries TO pre_processor_user;

  000011_grant_preprocessor_article_summaries_permissions.down.sql: |
    REVOKE SELECT, INSERT, UPDATE, DELETE ON article_summaries FROM pre_processor_user;

  000012_optimize_feed_article_lookup.up.sql: |
    CREATE INDEX IF NOT EXISTS idx_feeds_link_created_desc ON feeds (link, created_at DESC);

  000012_optimize_feed_article_lookup.down.sql: |
    DROP INDEX IF EXISTS idx_feeds_link_created_desc;

  000013_optimize_feed_article_indexes.up.sql: |
    -- feeds: 並び替えと検索を同時に満たす複合
    CREATE INDEX IF NOT EXISTS idx_feeds_created_at_link
        ON feeds (created_at, link);

    -- articles: 存在確認だけなので単一キー
    CREATE UNIQUE INDEX IF NOT EXISTS idx_articles_url
        ON articles (url);

  000013_optimize_feed_article_indexes.down.sql: |
    -- Remove optimized indexes
    DROP INDEX IF EXISTS idx_feeds_created_at_link;
    DROP INDEX IF EXISTS idx_articles_url;

  000014_add_feeds_link_gin_trgm_index.up.sql: |
    CREATE EXTENSION IF NOT EXISTS pg_trgm;
    CREATE INDEX IF NOT EXISTS idx_feeds_link_gin_trgm ON feeds USING gin (link gin_trgm_ops);

  000014_add_feeds_link_gin_trgm_index.down.sql: |
    DROP INDEX IF EXISTS idx_feeds_link_gin_trgm;

  000015_add_articles_gin_trgm_indexes.up.sql: |
    -- Add GIN trigram indexes for articles table
    -- Index on title for fast text similarity searches
    CREATE INDEX IF NOT EXISTS idx_articles_title_gin_trgm ON articles USING gin (title gin_trgm_ops);

    -- Index on url for fast text similarity searches
    CREATE INDEX IF NOT EXISTS idx_articles_url_gin_trgm ON articles USING gin (url gin_trgm_ops);

  000015_add_articles_gin_trgm_indexes.down.sql: |
    -- Remove GIN trigram indexes for articles table
    DROP INDEX IF EXISTS idx_articles_title_gin_trgm;
    DROP INDEX IF EXISTS idx_articles_url_gin_trgm;

  000016_add_article_summaries_gin_trgm_indexes.up.sql: |
    CREATE INDEX IF NOT EXISTS idx_article_summaries_summary_gin_trgm ON article_summaries USING gin (summary gin_trgm_ops);

  000016_add_article_summaries_gin_trgm_indexes.down.sql: |
    DROP INDEX IF EXISTS idx_article_summaries_summary_gin_trgm;

  000017_remove_duplicate_articles_url_index.up.sql: |
    DROP INDEX IF EXISTS idx_articles_url_created_desc;

  000017_remove_duplicate_articles_url_index.down.sql: |
    CREATE INDEX IF NOT EXISTS idx_articles_url_created_desc ON articles (url, created_at DESC);

  000018_add_feeds_created_desc_not_mp3_index.up.sql: |
    CREATE INDEX IF NOT EXISTS idx_feeds_created_desc_not_mp3 ON feeds (created_at DESC) WHERE link !~ '\.mp3$';

  000018_add_feeds_created_desc_not_mp3_index.down.sql: |
    DROP INDEX IF EXISTS idx_feeds_created_desc_not_mp3;

  000019_add_articles_created_id_desc_index.up.sql: |
    CREATE INDEX IF NOT EXISTS idx_articles_created_id_desc ON articles (created_at DESC, id DESC);

  000019_add_articles_created_id_desc_index.down.sql: |
    DROP INDEX IF EXISTS idx_articles_created_id_desc;

  000020_add_articles_id_index.up.sql: |
    CREATE INDEX IF NOT EXISTS idx_articles_id ON articles (id);

  000020_add_articles_id_index.down.sql: |
    DROP INDEX IF EXISTS idx_articles_id;

  000021_refine_articles_indexes_add_covering.up.sql: |
    DROP INDEX IF EXISTS idx_articles_created_at;
    CREATE INDEX IF NOT EXISTS idx_articles_created_at_covering ON articles (created_at DESC) INCLUDE (id, title, content, url);

  000021_refine_articles_indexes_add_covering.down.sql: |
    DROP INDEX IF EXISTS idx_articles_created_at_covering;
    CREATE INDEX IF NOT EXISTS idx_articles_created_at ON articles (created_at);

  000022_optimize_articles_title_indexes.up.sql: |
    DROP INDEX IF EXISTS idx_articles_title_gin_trgm;
    CREATE INDEX IF NOT EXISTS idx_articles_title_gin_trgm_optimized ON articles USING gin (title gin_trgm_ops) WHERE title IS NOT NULL AND length(title) > 0;

  000022_optimize_articles_title_indexes.down.sql: |
    DROP INDEX IF EXISTS idx_articles_title_gin_trgm_optimized;
    CREATE INDEX IF NOT EXISTS idx_articles_title_gin_trgm ON articles USING gin (title gin_trgm_ops);

  000023_add_feeds_desc_not_mp3_cover_index.up.sql: |
    DROP INDEX IF EXISTS idx_feeds_created_desc_not_mp3;
    CREATE INDEX IF NOT EXISTS idx_feeds_created_desc_not_mp3_covering ON feeds (created_at DESC) INCLUDE (id, title, description, link) WHERE link !~ '\.mp3$';

  000023_add_feeds_desc_not_mp3_cover_index.down.sql: |
    DROP INDEX IF EXISTS idx_feeds_created_desc_not_mp3_covering;
    CREATE INDEX IF NOT EXISTS idx_feeds_created_desc_not_mp3 ON feeds (created_at DESC) WHERE link !~ '\.mp3$';

  000024_grant_preprocessor_delete_article_summaries.up.sql: |
    GRANT DELETE ON article_summaries TO pre_processor_user;

  000024_grant_preprocessor_delete_article_summaries.down.sql: |
    REVOKE DELETE ON article_summaries FROM pre_processor_user;

  000025_create_feed_tags_table.up.sql: |
    CREATE TABLE IF NOT EXISTS feed_tags (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        feed_id UUID NOT NULL,
        tag_name TEXT NOT NULL,
        confidence FLOAT NOT NULL DEFAULT 0.0,
        created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (feed_id) REFERENCES feeds(id) ON DELETE CASCADE
    );

    CREATE INDEX IF NOT EXISTS idx_feed_tags_feed_id ON feed_tags (feed_id);
    CREATE INDEX IF NOT EXISTS idx_feed_tags_tag_name ON feed_tags (tag_name);
    CREATE INDEX IF NOT EXISTS idx_feed_tags_confidence ON feed_tags (confidence DESC);

  000025_create_feed_tags_table.down.sql: |
    DROP TABLE IF EXISTS feed_tags;

  000026_create_article_tags_table.up.sql: |
    -- Create the article_tags junction table
    CREATE TABLE IF NOT EXISTS article_tags (
        article_id UUID     NOT NULL REFERENCES articles(id) ON DELETE CASCADE,
        feed_tag_id     UUID      NOT NULL REFERENCES feed_tags(id)     ON DELETE CASCADE,
        created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
        PRIMARY KEY (article_id, feed_tag_id)
    );

    ALTER TABLE article_tags
        OWNER TO alt_db_user;

    CREATE INDEX IF NOT EXISTS idx_article_tags_feed_tag_id
        ON article_tags (feed_tag_id);

    CREATE INDEX IF NOT EXISTS idx_article_tags_created_at
        ON article_tags (created_at);

  000026_create_article_tags_table.down.sql: |
    DROP TABLE IF EXISTS article_tags;

  000027_create_tag_generator_user.up.sql: |
    -- Create tag_generator_user if it doesn't exist
    DO $$
    BEGIN
        IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = 'tag_generator_user') THEN
            CREATE USER tag_generator_user WITH PASSWORD 'tag_generator_password';
        END IF;
    END
    $$;

  000027_create_tag_generator_user.down.sql: |
    -- Drop tag_generator_user if it exists
    DROP USER IF EXISTS tag_generator_user;

  000028_grant_tag_generator_permissions.up.sql: |
    GRANT SELECT, INSERT, UPDATE, DELETE ON feed_tags TO tag_generator_user;
    GRANT SELECT, INSERT, UPDATE, DELETE ON article_tags TO tag_generator_user;
    GRANT SELECT ON feeds TO tag_generator_user;
    GRANT SELECT ON articles TO tag_generator_user;

  000028_grant_tag_generator_permissions.down.sql: |
    REVOKE SELECT, INSERT, UPDATE, DELETE ON feed_tags FROM tag_generator_user;
    REVOKE SELECT, INSERT, UPDATE, DELETE ON article_tags FROM tag_generator_user;
    REVOKE SELECT ON feeds FROM tag_generator_user;
    REVOKE SELECT ON articles FROM tag_generator_user;

  000029_fix_tags_schema.up.sql: |
    ALTER TABLE feed_tags ADD COLUMN IF NOT EXISTS tag_type VARCHAR(50) DEFAULT 'auto';
    ALTER TABLE article_tags ADD COLUMN IF NOT EXISTS tag_type VARCHAR(50) DEFAULT 'auto';

  000029_fix_tags_schema.down.sql: |
    ALTER TABLE feed_tags DROP COLUMN IF EXISTS tag_type;
    ALTER TABLE article_tags DROP COLUMN IF EXISTS tag_type;

  000030_create_search_indexer_user.up.sql: |
    -- Create search_indexer_user if it doesn't exist
    DO $$
    BEGIN
        IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = 'search_indexer_user') THEN
            CREATE USER search_indexer_user WITH PASSWORD 'search_indexer_password';
        END IF;
    END
    $$;

  000030_create_search_indexer_user.down.sql: |
    -- Drop search_indexer_user if it exists
    DROP USER IF EXISTS search_indexer_user;

  000031_grant_search_indexer_permissions.up.sql: |
    GRANT SELECT ON feeds TO search_indexer_user;
    GRANT SELECT ON articles TO search_indexer_user;
    GRANT SELECT ON feed_tags TO search_indexer_user;
    GRANT SELECT ON article_tags TO search_indexer_user;

  000031_grant_search_indexer_permissions.down.sql: |
    REVOKE SELECT ON feeds FROM search_indexer_user;
    REVOKE SELECT ON articles FROM search_indexer_user;
    REVOKE SELECT ON feed_tags FROM search_indexer_user;
    REVOKE SELECT ON article_tags FROM search_indexer_user;

  000032_create_favorite_feeds_table.up.sql: |
    CREATE TABLE IF NOT EXISTS favorite_feeds (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        user_id UUID NOT NULL,
        feed_id UUID NOT NULL,
        created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (feed_id) REFERENCES feeds(id) ON DELETE CASCADE,
        UNIQUE(user_id, feed_id)
    );

    CREATE INDEX IF NOT EXISTS idx_favorite_feeds_user_id ON favorite_feeds (user_id);
    CREATE INDEX IF NOT EXISTS idx_favorite_feeds_feed_id ON favorite_feeds (feed_id);

  000032_create_favorite_feeds_table.down.sql: |
    DROP TABLE IF EXISTS favorite_feeds;

  000033_add_feed_id_to_articles.up.sql: |
    ALTER TABLE articles ADD COLUMN IF NOT EXISTS feed_id UUID;
    DO $$
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'fk_articles_feed_id') THEN
            ALTER TABLE articles ADD CONSTRAINT fk_articles_feed_id FOREIGN KEY (feed_id) REFERENCES feeds(id) ON DELETE CASCADE;
        END IF;
    END
    $$;
    CREATE INDEX IF NOT EXISTS idx_articles_feed_id ON articles (feed_id);

  000033_add_feed_id_to_articles.down.sql: |
    ALTER TABLE articles DROP CONSTRAINT IF EXISTS fk_articles_feed_id;
    DROP INDEX IF EXISTS idx_articles_feed_id;
    ALTER TABLE articles DROP COLUMN IF EXISTS feed_id;

  000034_update_tag_generator_permissions.up.sql: |
    GRANT SELECT ON article_summaries TO tag_generator_user;

  000034_update_tag_generator_permissions.down.sql: |
    REVOKE SELECT ON article_summaries FROM tag_generator_user;

  000035_add_summary_japanese_column.up.sql: |
    ALTER TABLE article_summaries ADD COLUMN IF NOT EXISTS summary_japanese TEXT;
    CREATE INDEX IF NOT EXISTS idx_article_summaries_summary_japanese_gin_trgm ON article_summaries USING gin (summary_japanese gin_trgm_ops);

  000035_add_summary_japanese_column.down.sql: |
    DROP INDEX IF EXISTS idx_article_summaries_summary_japanese_gin_trgm;
    ALTER TABLE article_summaries DROP COLUMN IF EXISTS summary_japanese;

  000036_add_read_status_unique_constraint.up.sql: |
    DO $$
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'unique_read_status_feed_user') THEN
            ALTER TABLE read_status ADD CONSTRAINT unique_read_status_feed_user UNIQUE (feed_id, user_id);
        END IF;
    END
    $$;

  000036_add_read_status_unique_constraint.down.sql: |
    ALTER TABLE read_status DROP CONSTRAINT IF EXISTS unique_read_status_feed_user;

  # Inoreader API integration tables (pre-processor-sidecar)
  000037_create_inoreader_subscriptions_table.up.sql: |
    -- Create inoreader_subscriptions table for storing Inoreader feed subscriptions
    CREATE TABLE IF NOT EXISTS inoreader_subscriptions (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        inoreader_id TEXT UNIQUE NOT NULL,
        feed_url TEXT NOT NULL,
        title TEXT,
        category TEXT,
        synced_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
    );

    -- Create indexes for performance
    CREATE INDEX IF NOT EXISTS idx_inoreader_subscriptions_inoreader_id ON inoreader_subscriptions(inoreader_id);
    CREATE INDEX IF NOT EXISTS idx_inoreader_subscriptions_feed_url ON inoreader_subscriptions(feed_url);
    CREATE INDEX IF NOT EXISTS idx_inoreader_subscriptions_synced_at ON inoreader_subscriptions(synced_at DESC);

    -- Add comments for documentation
    COMMENT ON TABLE inoreader_subscriptions IS 'Stores RSS feed subscriptions synchronized from Inoreader API';
    COMMENT ON COLUMN inoreader_subscriptions.id IS 'Internal UUID primary key';
    COMMENT ON COLUMN inoreader_subscriptions.inoreader_id IS 'Unique identifier from Inoreader API (e.g., feed/http://example.com/rss)';
    COMMENT ON COLUMN inoreader_subscriptions.feed_url IS 'XML RSS feed URL';
    COMMENT ON COLUMN inoreader_subscriptions.title IS 'Feed title from Inoreader';
    COMMENT ON COLUMN inoreader_subscriptions.category IS 'Feed category/folder from Inoreader';
    COMMENT ON COLUMN inoreader_subscriptions.synced_at IS 'Last synchronization timestamp';
    COMMENT ON COLUMN inoreader_subscriptions.created_at IS 'Record creation timestamp';

  000037_create_inoreader_subscriptions_table.down.sql: |
    -- Drop inoreader_subscriptions table and related indexes
    DROP INDEX IF EXISTS idx_inoreader_subscriptions_synced_at;
    DROP INDEX IF EXISTS idx_inoreader_subscriptions_feed_url;
    DROP INDEX IF EXISTS idx_inoreader_subscriptions_inoreader_id;
    DROP TABLE IF EXISTS inoreader_subscriptions;

  000038_create_inoreader_articles_table.up.sql: |
    -- Create inoreader_articles table for storing article metadata from Inoreader
    CREATE TABLE IF NOT EXISTS inoreader_articles (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        inoreader_id TEXT UNIQUE NOT NULL,
        subscription_id UUID REFERENCES inoreader_subscriptions(id) ON DELETE CASCADE,
        article_url TEXT NOT NULL,
        title TEXT,
        author TEXT,
        published_at TIMESTAMP WITH TIME ZONE,
        fetched_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        processed BOOLEAN DEFAULT FALSE
    );

    -- Create indexes for performance
    CREATE INDEX IF NOT EXISTS idx_inoreader_articles_inoreader_id ON inoreader_articles(inoreader_id);
    CREATE INDEX IF NOT EXISTS idx_inoreader_articles_subscription_id ON inoreader_articles(subscription_id);
    CREATE INDEX IF NOT EXISTS idx_inoreader_articles_article_url ON inoreader_articles(article_url);
    CREATE INDEX IF NOT EXISTS idx_inoreader_articles_published_at ON inoreader_articles(published_at DESC);
    CREATE INDEX IF NOT EXISTS idx_inoreader_articles_fetched_at ON inoreader_articles(fetched_at DESC);
    CREATE INDEX IF NOT EXISTS idx_inoreader_articles_processed ON inoreader_articles(processed) WHERE processed = FALSE;

    -- Add comments for documentation
    COMMENT ON TABLE inoreader_articles IS 'Stores article metadata fetched from Inoreader stream contents API';
    COMMENT ON COLUMN inoreader_articles.id IS 'Internal UUID primary key';
    COMMENT ON COLUMN inoreader_articles.inoreader_id IS 'Unique article identifier from Inoreader API';
    COMMENT ON COLUMN inoreader_articles.subscription_id IS 'Reference to inoreader_subscriptions table';
    COMMENT ON COLUMN inoreader_articles.article_url IS 'URL to the original article';
    COMMENT ON COLUMN inoreader_articles.title IS 'Article title from Inoreader';
    COMMENT ON COLUMN inoreader_articles.author IS 'Article author';
    COMMENT ON COLUMN inoreader_articles.published_at IS 'Original publication timestamp';
    COMMENT ON COLUMN inoreader_articles.fetched_at IS 'When this record was fetched from Inoreader';
    COMMENT ON COLUMN inoreader_articles.processed IS 'Whether this article has been processed by other services';

  000038_create_inoreader_articles_table.down.sql: |
    -- Drop inoreader_articles table and related indexes
    DROP INDEX IF EXISTS idx_inoreader_articles_processed;
    DROP INDEX IF EXISTS idx_inoreader_articles_fetched_at;
    DROP INDEX IF EXISTS idx_inoreader_articles_published_at;
    DROP INDEX IF EXISTS idx_inoreader_articles_article_url;
    DROP INDEX IF EXISTS idx_inoreader_articles_subscription_id;
    DROP INDEX IF EXISTS idx_inoreader_articles_inoreader_id;
    DROP TABLE IF EXISTS inoreader_articles;

  000039_create_sync_state_table.up.sql: |
    -- Create sync_state table for managing continuation tokens and synchronization state
    CREATE TABLE IF NOT EXISTS sync_state (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        stream_id TEXT UNIQUE NOT NULL,
        continuation_token TEXT,
        last_sync TIMESTAMP WITH TIME ZONE DEFAULT NOW()
    );

    -- Create indexes for performance
    CREATE INDEX IF NOT EXISTS idx_sync_state_stream_id ON sync_state(stream_id);
    CREATE INDEX IF NOT EXISTS idx_sync_state_last_sync ON sync_state(last_sync DESC);

    -- Add comments for documentation
    COMMENT ON TABLE sync_state IS 'Stores synchronization state and continuation tokens for Inoreader stream pagination';
    COMMENT ON COLUMN sync_state.id IS 'Internal UUID primary key';
    COMMENT ON COLUMN sync_state.stream_id IS 'Stream identifier (e.g., user/-/state/com.google/reading-list)';
    COMMENT ON COLUMN sync_state.continuation_token IS 'Continuation token for pagination from Inoreader API';
    COMMENT ON COLUMN sync_state.last_sync IS 'Last successful synchronization timestamp';

  000039_create_sync_state_table.down.sql: |
    -- Drop sync_state table and related indexes
    DROP INDEX IF EXISTS idx_sync_state_last_sync;
    DROP INDEX IF EXISTS idx_sync_state_stream_id;
    DROP TABLE IF EXISTS sync_state;

  000040_create_api_usage_tracking_table.up.sql: |
    -- Create api_usage_tracking table for monitoring Inoreader API rate limits
    CREATE TABLE IF NOT EXISTS api_usage_tracking (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        date DATE DEFAULT CURRENT_DATE,
        zone1_requests INTEGER DEFAULT 0,
        zone2_requests INTEGER DEFAULT 0,
        last_reset TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        rate_limit_headers JSONB DEFAULT '{}'::JSONB
    );

    -- Create unique constraint to ensure one record per date
    DO $$
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'uq_api_usage_tracking_date') THEN
            ALTER TABLE api_usage_tracking ADD CONSTRAINT uq_api_usage_tracking_date UNIQUE (date);
        END IF;
    END
    $$;

    -- Create indexes for performance
    CREATE INDEX IF NOT EXISTS idx_api_usage_tracking_date ON api_usage_tracking(date DESC);
    CREATE INDEX IF NOT EXISTS idx_api_usage_tracking_last_reset ON api_usage_tracking(last_reset DESC);

    -- Add comments for documentation
    COMMENT ON TABLE api_usage_tracking IS 'Tracks daily API usage for Inoreader rate limit monitoring (Zone 1: 100/day, Zone 2: 100/day)';
    COMMENT ON COLUMN api_usage_tracking.id IS 'Internal UUID primary key';
    COMMENT ON COLUMN api_usage_tracking.date IS 'Date for this usage tracking record (YYYY-MM-DD)';
    COMMENT ON COLUMN api_usage_tracking.zone1_requests IS 'Number of Zone 1 API requests made (read operations like /subscription/list, /stream/contents)';
    COMMENT ON COLUMN api_usage_tracking.zone2_requests IS 'Number of Zone 2 API requests made (write operations like /subscription/edit)';
    COMMENT ON COLUMN api_usage_tracking.last_reset IS 'Last time the counters were reset or updated';
    COMMENT ON COLUMN api_usage_tracking.rate_limit_headers IS 'JSON object storing rate limit headers from Inoreader API responses';

  000040_create_api_usage_tracking_table.down.sql: |
    -- Drop api_usage_tracking table and related constraints/indexes
    DROP INDEX IF EXISTS idx_api_usage_tracking_last_reset;
    DROP INDEX IF EXISTS idx_api_usage_tracking_date;
    ALTER TABLE IF EXISTS api_usage_tracking DROP CONSTRAINT IF EXISTS uq_api_usage_tracking_date;
    DROP TABLE IF EXISTS api_usage_tracking;

  000041_create_pre_processor_sidecar_user.up.sql: |
    -- Create user for pre-processor-sidecar service
    DO $$
    BEGIN
       IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = 'pre_processor_sidecar_user') THEN
          CREATE USER pre_processor_sidecar_user WITH LOGIN PASSWORD '{{ .Values.database.passwords.preProcessorSidecar | required "database.passwords.preProcessorSidecar is required" }}';
       END IF;
    END $$;

    -- Add comments for documentation
    COMMENT ON ROLE pre_processor_sidecar_user IS 'Database user for pre-processor-sidecar CronJob service - Inoreader API integration';

  000041_create_pre_processor_sidecar_user.down.sql: |
    -- Drop pre_processor_sidecar_user
    DROP USER IF EXISTS pre_processor_sidecar_user;

  000042_grant_pre_processor_sidecar_permissions.up.sql: |
    -- Grant permissions to pre_processor_sidecar_user for Inoreader integration tables

    -- Grant permissions on inoreader_subscriptions table
    GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE inoreader_subscriptions TO pre_processor_sidecar_user;

    -- Grant permissions on inoreader_articles table  
    GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE inoreader_articles TO pre_processor_sidecar_user;

    -- Grant permissions on sync_state table
    GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE sync_state TO pre_processor_sidecar_user;

    -- Grant permissions on api_usage_tracking table
    GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE api_usage_tracking TO pre_processor_sidecar_user;

    -- Grant CONNECT permission on database
    GRANT CONNECT ON DATABASE alt TO pre_processor_sidecar_user;

    -- Grant USAGE on public schema
    GRANT USAGE ON SCHEMA public TO pre_processor_sidecar_user;

  000042_grant_pre_processor_sidecar_permissions.down.sql: |
    -- Revoke permissions from pre_processor_sidecar_user

    -- Revoke schema permissions
    REVOKE USAGE ON SCHEMA public FROM pre_processor_sidecar_user;
    REVOKE CONNECT ON DATABASE alt FROM pre_processor_sidecar_user;

    -- Revoke permissions on api_usage_tracking table
    REVOKE SELECT, INSERT, UPDATE, DELETE ON TABLE api_usage_tracking FROM pre_processor_sidecar_user;

    -- Revoke permissions on sync_state table
    REVOKE SELECT, INSERT, UPDATE, DELETE ON TABLE sync_state FROM pre_processor_sidecar_user;

    -- Revoke permissions on inoreader_articles table
    REVOKE SELECT, INSERT, UPDATE, DELETE ON TABLE inoreader_articles FROM pre_processor_sidecar_user;

    -- Revoke permissions on inoreader_subscriptions table
    REVOKE SELECT, INSERT, UPDATE, DELETE ON TABLE inoreader_subscriptions FROM pre_processor_sidecar_user;

  000043_add_created_at_to_sync_state.up.sql: |
    -- Add created_at column to sync_state table for pre-processor-sidecar compatibility
    -- EMERGENCY FIX: Adds missing created_at column that caused article insertion failures
    ALTER TABLE sync_state ADD COLUMN IF NOT EXISTS created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW();

    -- Create index for performance on the new column
    CREATE INDEX IF NOT EXISTS idx_sync_state_created_at ON sync_state(created_at DESC);

    -- Update existing records to have created_at value (use last_sync as fallback)
    UPDATE sync_state SET created_at = COALESCE(last_sync, NOW()) WHERE created_at IS NULL;

    -- Add comment for documentation
    COMMENT ON COLUMN sync_state.created_at IS 'Timestamp when the sync state record was first created - EMERGENCY FIX for pre-processor-sidecar article insertion';

  000043_add_created_at_to_sync_state.down.sql: |
    -- Remove created_at column from sync_state table
    DROP INDEX IF EXISTS idx_sync_state_created_at;
    ALTER TABLE sync_state DROP COLUMN IF EXISTS created_at;

  000044_fix_read_status_user_id.up.sql: |
    -- EMERGENCY FIX: Add dummy user_id to existing read_status records for compatibility
    -- This migration fixes the read status functionality broken by migration 000036
    
    -- Update existing read_status records that have NULL user_id
    UPDATE read_status 
    SET user_id = '00000000-0000-0000-0000-000000000001' 
    WHERE user_id IS NULL;
    
    -- Make user_id NOT NULL to prevent future NULL insertions
    ALTER TABLE read_status ALTER COLUMN user_id SET NOT NULL;
    
    -- Add comment for documentation
    COMMENT ON COLUMN read_status.user_id IS 'User ID for read status - uses dummy ID for single-user mode compatibility';

  000044_fix_read_status_user_id.down.sql: |
    -- Rollback read_status user_id fix
    ALTER TABLE read_status ALTER COLUMN user_id DROP NOT NULL;
    UPDATE read_status SET user_id = NULL WHERE user_id = '00000000-0000-0000-0000-000000000001';

  000045_add_content_to_inoreader_articles.up.sql: |
    -- Add content fields to inoreader_articles table for storing article full content
    -- Phase 1: Database Schema Extension for Article Content Storage

    ALTER TABLE inoreader_articles 
    ADD COLUMN content TEXT,
    ADD COLUMN content_length INTEGER DEFAULT 0,
    ADD COLUMN content_type VARCHAR(50) DEFAULT 'html';

    -- Update comments for new columns
    COMMENT ON COLUMN inoreader_articles.content IS 'Full article content from Inoreader summary.content field';
    COMMENT ON COLUMN inoreader_articles.content_length IS 'Length of content in characters for optimization';
    COMMENT ON COLUMN inoreader_articles.content_type IS 'Content type (html, html_rtl, text)';

    -- Create index for content-based queries (partial index for performance)
    CREATE INDEX IF NOT EXISTS idx_inoreader_articles_has_content
    ON inoreader_articles(content_length) 
    WHERE content_length > 0;

    -- Create composite index for processed status and content availability
    CREATE INDEX IF NOT EXISTS idx_inoreader_articles_processed_content
    ON inoreader_articles(processed, content_length) 
    WHERE content_length > 0;

    -- Create index for content type filtering
    CREATE INDEX IF NOT EXISTS idx_inoreader_articles_content_type
    ON inoreader_articles(content_type)
    WHERE content_type IS NOT NULL AND content_type != 'html';

  000045_add_content_to_inoreader_articles.down.sql: |
    -- Rollback content fields from inoreader_articles table
    -- Phase 1: Database Schema Extension Rollback

    -- Drop indexes first
    DROP INDEX IF EXISTS idx_inoreader_articles_content_type;
    DROP INDEX IF EXISTS idx_inoreader_articles_processed_content;
    DROP INDEX IF EXISTS idx_inoreader_articles_has_content;

    -- Drop content columns
    ALTER TABLE inoreader_articles DROP COLUMN IF EXISTS content_type;
    ALTER TABLE inoreader_articles DROP COLUMN IF EXISTS content_length;
    ALTER TABLE inoreader_articles DROP COLUMN IF EXISTS content;{{- end }}
