# TraceID/SpanID がログに出力されない問題の修正

## ADR's STATUS

Accepted

## CONTEXT

### 背景

Go系マイクロサービス（pre-processor, search-indexer）において、Grafana のログダッシュボードで TraceID と SpanID が全て `0000000000000000` と表示されていた。

### 問題点

`slog.Logger.Info()` と `slog.Logger.InfoContext(ctx, ...)` の使い分けが正しく行われていなかった。

### 仕組み

1. `otelecho.Middleware()` がリクエストごとにスパンを作成し、`c.Request().Context()` に格納
2. `TraceContextHandler.Handle(ctx, r)` が ctx からスパンを抽出して trace_id/span_id をログに追加
3. **問題**: `Info()` は内部で `context.Background()` を使用するため、スパンが存在しない

### サービス別の状況（修正前）

| サービス | ファイル | 状況 |
|----------|----------|------|
| alt-backend | `middleware/logging_middleware.go` | 正しい（`InfoContext`） |
| auth-hub | `main.go` | 正しい（`InfoContext`） |
| **pre-processor** | `main.go` | 問題あり（`Info`） |
| **search-indexer** | `rest/handler.go` | 問題あり（`Info/Error`） |

## DECISION MAKING

### 修正方針

HTTP リクエストコンテキスト内でログを出力する際は、必ず `InfoContext(ctx, ...)` または `ErrorContext(ctx, ...)` を使用する。

### 正しいパターン

```go
// Echo フレームワーク
LogValuesFunc: func(c echo.Context, v middleware.RequestLoggerValues) error {
    ctx := c.Request().Context()
    logger.Logger.InfoContext(ctx, "HTTP request completed", ...)
}

// net/http ハンドラ
func handler(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    logger.Logger.InfoContext(ctx, "request processed", ...)
}
```

### 誤ったパターン

```go
// context を渡さないため、TraceID/SpanID が取得できない
logger.Logger.Info("HTTP request completed", ...)
```

## RESULTS, EFFECTS

### 変更ファイル

| ファイル | 変更内容 |
|----------|----------|
| `pre-processor/app/main.go:268-276` | `Info` → `InfoContext(ctx, ...)` |
| `search-indexer/app/rest/handler.go:83-134` | `Info/Error` → `InfoContext/ErrorContext(ctx, ...)` |

### pre-processor/app/main.go の変更

```go
// Before
LogValuesFunc: func(c echo.Context, v middleware.RequestLoggerValues) error {
    logger.Logger.Info("HTTP request completed", ...)
}

// After
LogValuesFunc: func(c echo.Context, v middleware.RequestLoggerValues) error {
    ctx := c.Request().Context()
    logger.Logger.InfoContext(ctx, "HTTP request completed", ...)
}
```

### search-indexer/app/rest/handler.go の変更

```go
// Before
func SearchArticles(w http.ResponseWriter, r *http.Request, idx meilisearch.IndexManager) {
    logger.Logger.Error("query is empty")
    logger.Logger.Info("search ok", ...)
}

// After
func SearchArticles(w http.ResponseWriter, r *http.Request, idx meilisearch.IndexManager) {
    ctx := r.Context()
    logger.Logger.ErrorContext(ctx, "query is empty")
    logger.Logger.InfoContext(ctx, "search ok", ...)
}
```

### 検証結果

修正後のログ出力例:

```json
{
  "time": "2026-01-21T14:31:16.915Z",
  "level": "info",
  "msg": "HTTP request completed",
  "method": "GET",
  "uri": "/api/v1/health",
  "status": 200,
  "trace_id": "6252144cf4eff1c3f7455ff3d36553e6",
  "span_id": "656af53dcdd78482"
}
```

### PROS

1. **トレーサビリティ向上**: ログとトレースが正しく紐付けられる
2. **Grafana での可視性**: TraceID でログをフィルタリング可能
3. **分散トレーシング**: サービス間のリクエストを追跡可能

### CONS, TRADEOFF

1. **バックグラウンドジョブ**: HTTP コンテキスト外のログには TraceID が付与されない（これは正常な動作）

## APPENDIX

### 検証コマンド

```bash
# コンテナ再ビルド・再起動
docker compose -f compose/compose.yaml -p alt up -d --build pre-processor search-indexer

# リクエスト発行
curl http://localhost:9200/api/v1/health
curl "http://localhost:9300/v1/search?q=test&user_id=test"

# ログ確認
docker compose -f compose/compose.yaml -p alt logs pre-processor --tail=10 | grep trace_id
docker compose -f compose/compose.yaml -p alt logs search-indexer --tail=10 | grep trace_id
```

### 参考資料

- [GitHub Issue #6114 - TraceID and SpanID are both "00000...." in otel log export](https://github.com/open-telemetry/opentelemetry-go/issues/6114)
- [Go slog Package](https://pkg.go.dev/log/slog)
- [OpenTelemetry Go - trace package](https://pkg.go.dev/go.opentelemetry.io/otel/trace)
