# FetchUnreadFeedsListCursor の既読フィルタを user_reading_status テーブルに移行

## ステータス

**撤回（Superseded）** - 2026年1月

> ⚠️ **重要**: この決定は誤った前提に基づいていたため撤回されました。詳細は「撤回と教訓」セクションを参照。

## コンテキスト

### 背景

本番環境で「記事を既読マークしてもリロード後に同じフィードが表示される」不具合が発生していた。

### 問題の発生状況

ログ分析により以下が確認された：

1. `MarkAsRead` APIは正常に200 OKを返す
2. `article reading status updated successfully` ログが出力される
3. しかし、UIリロード後も同じ記事がフィード一覧に表示される
4. 同じ記事が複数回既読マークされる（07:17:29, 07:18:06に同一article_id）

### 根本原因

シングルテナント移行時のテーブル参照漏れ：

| 操作 | テーブル | キー | 状態 |
|------|---------|-----|------|
| MarkAsRead (書込) | `user_reading_status` | `article_id` | ✅ 移行済み |
| FetchUnreadFeedsListCursor (読取) | `read_status` | `feed_id` | ❌ 未移行 |

- 旧テーブル: `read_status` (feed_id ベース) - マルチテナント用、廃止予定
- 新テーブル: `user_reading_status` (article_id ベース) - シングルテナント用

`MarkAsRead` は `user_reading_status` に書き込むが、`FetchUnreadFeedsListCursor` は旧 `read_status` テーブルを参照していたため、既読情報が反映されなかった。

### ADR-039との関係

ADR-039では以下の問題を修正した：
1. フィード重複表示 → サブクエリ化
2. 既読処理の404エラー → OR検索

しかし、テーブル参照の不一致問題は触れられていなかった。

## 意思決定

### 決定: FetchUnreadFeedsListCursor のクエリを user_reading_status に移行

**修正前（問題）:**
```sql
WHERE NOT EXISTS (
    SELECT 1
    FROM read_status rs
    WHERE rs.feed_id = f.id
    AND rs.user_id = $2
    AND rs.is_read = TRUE
)
```

**修正後:**
```sql
WHERE NOT EXISTS (
    SELECT 1
    FROM user_reading_status urs
    JOIN articles a ON a.id = urs.article_id
    WHERE a.url = f.link
    AND a.deleted_at IS NULL
    AND urs.user_id = $2
    AND urs.is_read = TRUE
)
```

**代替案と理由:**
- ❌ **MarkAsRead側で両テーブルに書き込む**: 二重書き込みは複雑さを増し、データ不整合リスクがある
- ❌ **read_statusテーブルを維持**: 廃止予定のテーブルへの依存を継続するのは技術的負債
- ✅ **クエリ側をuser_reading_statusに統一**: シングルテナント移行の方針に沿い、一貫性を確保

## 結果

### 技術的成果

| 項目 | 修正前 | 修正後 |
|------|--------|--------|
| 既読反映 | されない | 即時反映 |
| 参照テーブル | read_status (旧) | user_reading_status (新) |
| JOINの複雑さ | 単純 (feed_id直接参照) | articles経由のJOIN |

### 修正ファイル

**バックエンド:**
- `alt-backend/app/driver/alt_db/fetch_feed_driver.go` (lines 167-210)
  - cursor無しクエリ: `user_reading_status` JOIN `articles` に変更
  - cursor有りクエリ: 同様に変更

### PROS

1. **不具合解消**: 既読マーク後のリロードで記事が正しくフィルタリングされる
2. **テーブル統一**: シングルテナント移行方針に沿った一貫性
3. **技術的負債削減**: 旧テーブル依存の解消

### CONS, TRADEOFF

1. **クエリ複雑化**: articles テーブル経由のJOINが必要
2. **パフォーマンス影響の可能性**: JOINによる若干のオーバーヘッド（要モニタリング）

## 付録

### 関連ADR

- [ADR-039: フィード取得・既読処理におけるデータ整合性の確保](./000039.md) - サブクエリ化とOR検索

### 今後の改善

1. **read_statusテーブルの廃止**: 参照箇所がなくなり次第、マイグレーションでDROP
2. **FetchReadFeedsListCursor の移行**: 既読フィード取得も同様にuser_reading_statusに移行が必要
3. **パフォーマンス監視**: 新クエリのレイテンシをダッシュボードで監視

---

## 撤回と教訓（2026年1月）

### 撤回理由

この決定は**誤った前提**に基づいていた：

> 「すべての `feeds` レコードには対応する `articles` レコードが存在する」

**実際には**:
- `feeds` テーブル: RSS フィードアイテム（約 21,000 件の既読）
- `articles` テーブル: オンデマンドで作成されるリッチコンテンツ
- **約 7,000 件の `feeds` には対応する `articles` が存在しない**

### 発生した問題

1. **既読マークが機能しない**: `articles` が存在しない `feeds` を既読にできない（404エラー）
2. **永遠に未読のまま**: `articles` がない `feeds` は `user_reading_status` にJOINできないため、常に未読として表示
3. **データ移行の不完全性**: `read_status` → `user_reading_status` への移行で約 7,000 件の既読情報が失われた

### 修正内容

`read_status`（feed_id ベース）を復活：

**修正ファイル:**
- `alt-backend/app/driver/alt_db/user_reading_status_driver.go` - `MarkArticleAsRead` が `feeds.link` で検索し `read_status` に書き込むよう変更
- `alt-backend/app/driver/alt_db/fetch_feed_driver.go` - `FetchUnreadFeedsListCursor` を `read_status` ベースに戻す
- `alt-backend/app/connect/v2/feeds/handler.go` - `ErrFeedNotFound` エラーハンドリングに変更

**修正後のクエリ:**
```sql
WHERE NOT EXISTS (
    SELECT 1
    FROM read_status rs
    WHERE rs.feed_id = f.id
    AND rs.user_id = $2
    AND rs.is_read = TRUE
)
```

### 教訓

1. **データモデルの正確な理解**: テーブル間の関係性と1:1マッピングの前提を検証する
2. **移行前の影響分析**: データ移行前に影響を受けるレコード数を確認する
3. **段階的な移行**: 大きな変更は段階的に行い、問題を早期に検出する

### user_reading_status テーブルの扱い

テーブル自体は将来の用途に備えて残すが、現時点ではデータを空にし、使用しない。
article 単位の細かい既読管理が必要になった場合に再検討する。
