# ADR-000280: OGP Image Proxy リファクタリング — 関心の分離と 502 エラー修正

## ステータス

承認済み

## コンテキスト

### ADR-276〜279 で導入された OGP 画像プロキシの問題

ADR-276〜279 の実装で OGP 画像プロキシ機能が追加された。HMAC 署名付きプロキシ URL を生成し、外部 OGP 画像をバックエンド経由で配信する仕組みである。しかし、実運用で以下の 3 つの問題が発覚した。

### 問題 1: 関心の分離不足

`FetchArticleContent` RPC が記事コンテンツ取得と同時に `og_image_proxy_url` を生成していた。この URL は visual-preview モードでのみ使用されるが、normal swipe モードでも毎回生成されていた。OGP 画像プロキシは `BatchPrefetchImages` という独立した非同期バッチ経路が既に存在しており、プロキシ URL 生成はそこに集約すべきであった。

```
FetchArticleContent (記事取得) → プロキシ URL 生成 ← 不要な結合
BatchPrefetchImages (画像バッチ) → プロキシ URL 生成 ← 本来の責務
```

### 問題 2: visual-preview の 502 エラー

`ProxyImage` ハンドラが nginx の `proxy_read_timeout`（30s）を超過するケースで、nginx が 502 Bad Gateway を返していた。また、エラー分類が不適切で、タイムアウト・クライアント切断・認証エラー・上流エラーがすべて 502 として返されていた。

### 問題 3: `triggerBatchImagePrefetch` のタイミングバグ

フロントエンドの `triggerBatchImagePrefetch` が `articlePrefetcher.getCachedArticleId()` に依存していたが、batch prefetch が呼ばれる時点では article content がまだプリフェッチされていない。そのため `getCachedArticleId()` は常に null を返し、空配列で早期 return していた。結果、visual-preview モードでの OGP 画像バッチプリフェッチが一切機能していなかった。

## 意思決定

### 1. `FetchArticleContent` から proxy URL 生成を除去

`FetchArticleContent` RPC ハンドラから `ImageProxyUsecase.GenerateProxyURL()` 呼び出しを削除した。

- `og_image_url` フィールドは残す（HTML メタタグからの抽出結果として有用）
- Proto フィールド `og_image_proxy_url` は後方互換のために残すが、空文字を返す
- プロキシ URL 生成は `BatchPrefetchImages` RPC に一本化

### 2. `handleImageProxy` のエラーハンドリング改善

```
変更前: すべてのエラー → 502 Bad Gateway
変更後:
  - context.DeadlineExceeded → 504 Gateway Timeout
  - context.Canceled → 499 (client disconnected)
  - 署名/ドメイン検証失敗 → 403 Forbidden（変更なし）
  - その他 → 502 Bad Gateway（変更なし）
```

加えて、リクエストコンテキストに 25 秒のタイムアウトを設定。nginx の `proxy_read_timeout`（30s）以内に確実にレスポンスを返し、nginx による 502 を防止する。

### 3. `WarmCache` goroutine のタイムアウト追加

`BatchPrefetchImages` が起動する `WarmCache` goroutine に `context.Background()` を直接渡していたため、上流の画像サーバーが応答しない場合に goroutine がリークする可能性があった。60 秒のタイムアウトを追加した。

### 4. visual-preview SSR で `BatchPrefetchImages` を使用

`+page.server.ts` の SSR ロードで、`fetchArticleContent` から proxy URL を取得する代わりに、記事取得後に `batchPrefetchImages` を別途呼び出す設計に変更した。

```
変更前: fetchArticleContent → ogImageProxyUrl を直接使用
変更後: fetchArticleContent → articleId 取得 → batchPrefetchImages → proxyUrl 取得
```

`batchPrefetchImages` の呼び出しが失敗した場合は、raw `og_image_url` にフォールバックする。

### 5. `triggerBatchImagePrefetch` のタイミングバグ修正

`articlePrefetcher.getCachedArticleId()` の代わりに `feed.articleId` を直接参照するように変更した。

`feed.articleId` はバックエンドの feeds API レスポンスに含まれるフィールドで、プリフェッチキャッシュの状態に依存しない。これにより、新しく読み込んだフィードに対して即座にバッチプリフェッチが機能する。

### 6. `articlePrefetcher` の OGP キャッシュ方針変更

`FetchArticleContent` レスポンスの `og_image_proxy_url` が空になるため、プリフェッチャーのキャッシュロジックから proxy URL フォールバックを除去した。

```
変更前: ogImageCache.set(key, response.og_image_proxy_url || response.og_image_url)
変更後: ogImageCache.set(key, response.og_image_url)
```

visual-preview モードでは、`BatchPrefetchImages` の結果が `seedCache` 経由で proxy URL を上書きする。

### 不採用案

| 不採用案 | 理由 |
|---------|------|
| `FetchArticleContent` にモードフラグを追加して proxy URL 生成を制御 | RPC にモード概念を持ち込むと結合度が上がる。バッチ API への一本化のほうがクリーン |
| nginx の `proxy_read_timeout` を延長 | 根本解決にならず、他のスロークエリにも影響する。バックエンド側でのタイムアウト制御が適切 |
| `triggerBatchImagePrefetch` を article content プリフェッチ完了後に呼ぶ | タイミングの依存関係が複雑になる。`feed.articleId` が既に利用可能であり、キャッシュに依存する必要がない |

## 結果・影響

### 動作確認

| 確認項目 | 結果 |
|---------|------|
| `go test ./usecase/image_proxy_usecase/... ./rest/... ./connect/v2/articles/...` | 全パス |
| `bun test` (frontend) | 既存の pre-existing failures のみ（変更に起因するものなし） |
| コンテナ再ビルド+起動 | healthy |
| Backend health check | `{"status":"healthy"}` |
| Frontend health check | `{"status":"ok"}` |

### PROS

- `FetchArticleContent` が純粋なコンテンツ取得 RPC に戻り、画像プロキシとの結合が解消された
- エラー分類の改善により、クライアント側でタイムアウト（504）と上流エラー（502）を区別でき、適切なリトライ戦略が可能になった
- 25s コンテキストタイムアウトにより、nginx の 502 発生を防止。バックエンドが自ら 504 を返す制御に移行
- `triggerBatchImagePrefetch` が実際に機能するようになり、visual-preview モードでの OGP 画像表示が改善される
- `WarmCache` の goroutine リーク防止

### CONS, TRADEOFF

- visual-preview SSR で 1 追加 RPC 呼び出し（`batchPrefetchImages`）が発生する。ただし SSR は streaming pattern を使用しているため、FCP への影響は軽微
- `og_image_proxy_url` Proto フィールドは後方互換のために残存する。将来のクリーンアップで削除予定
- `feed.articleId` が null のフィード（バックエンドにまだ記事が保存されていない新規フィード）では、バッチプリフェッチが機能しない。この場合は個別の `FetchArticleContent` → `seedCache` の経路で raw `og_image_url` がキャッシュされる

## 付録

### 変更ファイル一覧

| ファイル | 変更 |
|---------|------|
| `alt-backend/app/connect/v2/articles/handler.go` | `FetchArticleContent` から proxy URL 生成削除、`WarmCache` に 60s タイムアウト追加 |
| `alt-backend/app/rest/image_proxy_handlers.go` | 25s コンテキストタイムアウト追加、エラー分類改善（504/499/403/502） |
| `alt-frontend-sv/.../visual-preview/+page.server.ts` | `batchPrefetchImages` 呼び出しに変更 |
| `alt-frontend-sv/.../swipe/SwipeFeedScreen.svelte` | `triggerBatchImagePrefetch` で `feed.articleId` を直接使用、`seedCache` から proxy URL パラメータ除去 |
| `alt-frontend-sv/src/lib/utils/articlePrefetcher.ts` | OGP キャッシュから `og_image_proxy_url` フォールバック除去 |

### 画像プロキシ URL 生成の責務移動

```
変更前:
  FetchArticleContent → GenerateProxyURL (同期、毎回)
  BatchPrefetchImages → BatchGenerateProxyURLs (バッチ)

変更後:
  FetchArticleContent → og_image_url のみ（プロキシ URL 生成なし）
  BatchPrefetchImages → BatchGenerateProxyURLs (バッチ、一本化)
```

### エラーハンドリングフロー

```
Client → nginx (30s timeout) → Backend (25s timeout) → 外部画像サーバー

ケース 1: 外部サーバー 20s で応答 → 200 OK
ケース 2: 外部サーバー 28s で応答 → Backend 25s timeout → 504 Gateway Timeout
ケース 3: クライアントが先に切断 → 499
ケース 4: 署名不正 → 403 Forbidden
ケース 5: 外部サーバーエラー → 502 Bad Gateway
```
