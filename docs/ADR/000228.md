# ADR-000228: 検索結果の重複 ID による Svelte reconcile クラッシュ修正

## STATUS

Accepted（実装完了・コンテナデプロイ・動作確認済み）

## CONTEXT

ADR-227 の infinite scroll 修正後もなお、検索ページで Svelte ランタイムエラーが発生していた:

```
RangeError: Invalid array length
    at Array.push (<anonymous>)
    at reconcile (...)

TypeError: Cannot read properties of undefined (reading 'prev')
    at reconcile (...)
```

これらのエラーは Svelte 5 の `reconcile` 関数（keyed `{#each}` ブロックの差分更新処理）で発生しており、ADR-227 で修正した infinite scroll の停止ロジックとは別の根本原因が存在していた。

### 根本原因

Proto レスポンスの `FeedItem.Id` フィールドにフィードソース URL が使用されていたが、検索結果では **同一フィードソースから複数の記事が返却される** ため、`Id` が重複していた。

**データフロー:**

```
Meilisearch → SearchArticleHit { ID: "article-uuid-123", Title, Content }
    ↓
Usecase → FeedItem { Link: urlMap["article-uuid-123"] }  // = Feed source URL
    ↓
Handler → Proto FeedItem { Id: feed.Link }  // = Feed source URL（重複する）
    ↓
Frontend → {#each feeds as feed (feed.id)}  // 重複キーで reconcile が破綻
```

具体例: 「LLM」で検索した場合、同一フィードソースから複数の記事がヒットし、全て同じ `Id`（フィードソース URL）を持つ。Svelte の keyed each は一意なキーを前提としているため、重複キーが存在すると内部のリンクリスト操作で不正な状態になり、`RangeError` や `TypeError` が発生する。

### 影響範囲

- `/desktop/feeds/search` — デスクトップ検索ページ
- `/(app)/feeds/search` — レスポンシブ検索ページ

（通常のフィード一覧では `Link` が記事固有の URL であるため影響なし）

## DECISION MAKING

### ArticleID を FeedItem に保持し、Proto Id に使用

検索ヒットの `hit.ID`（Meilisearch の記事 ID）を `FeedItem.ArticleID` フィールドに保持し、Proto 変換時に `ArticleID` が存在する場合はそれを `Id` として使用する。

**理由:**

1. `hit.ID` は Meilisearch のドキュメント ID であり、記事ごとに一意
2. `domain.FeedItem` に既に `ArticleID` フィールドが定義されているため、新しいフィールドの追加が不要
3. 通常のフィード一覧（検索以外）では `ArticleID` が設定されていない場合もあるため、フォールバックとして `Link` を使い続ける

### 代替案: Frontend で index をキーに使う

```svelte
{#each feeds as feed, index (index)}
```

この方法も重複キー問題は解消するが、Svelte の keyed each のメリット（DOM 再利用による効率的な更新）が失われる。Backend 側で正しいユニークキーを設定する方が根本的な解決策であるため不採用。

## RESULTS

### 変更ファイル

| ファイル | 変更内容 |
|---------|---------|
| `alt-backend/app/usecase/search_feed_usecase/search_feed_meilisearch_usecase.go` | 検索ヒットの `ArticleID` を `FeedItem` に保持 |
| `alt-backend/app/connect/v2/feeds/helpers.go` | `convertFeedsToProto` で `ArticleID` 優先の `Id` 設定 |

### Usecase の変更

```go
// Before: ArticleID 未設定
feedItems[i] = &domain.FeedItem{
    Title:       hit.Title,
    Description: hit.Content,
    Link:        urlMap[hit.ID],
}

// After: ArticleID を保持
feedItems[i] = &domain.FeedItem{
    Title:       hit.Title,
    Description: hit.Content,
    Link:        urlMap[hit.ID],
    ArticleID:   hit.ID,         // Preserve article ID for unique identification
}
```

### Proto 変換の変更

```go
// Before: 常に Link を Id として使用
item := &feedsv2.FeedItem{
    Id: feed.Link,
    // ...
}

// After: ArticleID があればそれを優先
id := feed.Link
if feed.ArticleID != "" {
    id = feed.ArticleID
}
item := &feedsv2.FeedItem{
    Id: id,
    // ...
}
```

### 検証結果

| 検証項目 | 結果 |
|---------|------|
| Backend usecase テスト | 全件 PASS |
| Backend connect handler テスト | 全件 PASS |
| `alt-backend` コンテナ再ビルド・起動 | 正常 (`healthy`) |
| `alt-frontend-sv` コンテナ再ビルド・起動 | 正常 (`healthy`) |

## PROS

1. **クラッシュ解消**: Svelte の `reconcile` での `RangeError` / `TypeError` が発生しなくなる
2. **正しいキー設計**: 検索結果に記事ごとのユニーク ID を使用するため、DOM 差分更新が正確に動作
3. **既存動作に影響なし**: 通常のフィード一覧（検索以外）では `ArticleID` が空のため、従来通り `Link` が `Id` として使われる
4. **最小限の変更**: 既存の `ArticleID` フィールドを活用し、新しいフィールドの追加は不要

## CONS, TRADEOFF

1. **ID の一貫性**: 検索結果のみ `Id` が記事 UUID となり、通常のフィード一覧では URL が使われる。Frontend 側で `Id` の形式に依存した処理がある場合は注意が必要（現状はキーとしてのみ使用しているため問題なし）

## APPENDIX

### Svelte 5 の reconcile 関数と重複キー

Svelte 5 の keyed `{#each}` ブロックは、内部的にリンクリスト構造でキーと DOM ノードの対応を管理している。重複キーが存在すると:

1. 同じキーに対して複数のノードが紐づく
2. 差分更新時にリンクリストの `prev`/`next` ポインタが不正な状態になる
3. `TypeError: Cannot read properties of undefined (reading 'prev')` が発生
4. 配列操作が不正な長さを生成し `RangeError: Invalid array length` が発生

Svelte は重複キーの検出・警告を行わないため、開発時に気付きにくい問題である。
