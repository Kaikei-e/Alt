# ADR-000269: OGP 画像表示遅延の修正 — Svelte リアクティビティ + バックエンド軽量クエリ

## ステータス

承認済み

## コンテキスト

### 背景

ADR-000268 で OGP 画像取得をバックエンド抽出方式に移行し、`ArticlePrefetcher` の `ogImageCache` で管理する構成とした。プリフェッチチェーン自体は正しく動作し 5 枚先まで取得できていたが、**取得結果が UI に反映されない**問題が発生した。

### 原因分析

#### 原因 1: ogImageCache が非リアクティブ（主因）

`ArticlePrefetcher` の `ogImageCache` は素の `Map` であり、Svelte 5 の `$state` ではない。`prefetchContent()` が `ogImageCache.set()` で値を書き込んでも、Svelte はその変更を検知できない。

`SwipeFeedScreen.svelte` のテンプレート式:

```svelte
thumbnailUrl={articlePrefetcher.getCachedOgImage(activeFeed.normalizedUrl) ?? null}
```

この式は `{#key activeFeed.id}` でコンポーネント生成時に **一度だけ評価** される。プリフェッチがまだ完了していなければ `null` が渡り、後から完了しても再評価されない。

対照的に、`getCachedContent` は関数 prop として渡され、`VisualPreviewCard` 内部の `onMount` で呼ばれるためこの問題は生じなかった。

#### 原因 2: バックエンドで不要な head_html カラムを取得

`article_head_driver.go` の `FetchArticleHeadByArticleID` が `head_html`（5-50KB の TEXT）を毎回 SELECT していた。`og_image_url` だけで十分な場面で、不要な大きな TEXT カラムの I/O が発生していた。

## 意思決定

### 方針

1. `ArticlePrefetcher` にコールバックを追加し、Svelte 側でバージョンカウンタを介してリアクティビティを実現する
2. バックエンドに `og_image_url` のみ SELECT する軽量メソッドを追加し、不要な I/O を削減する

### 不採用案

| 不採用案 | 理由 |
|---------|------|
| `ogImageCache` を `$state(new Map())` に変更 | `ArticlePrefetcher` はクラスインスタンスとして `+page.svelte` の外で生成されるため、Svelte runes のリアクティビティスコープ外。`$state` が動作しない |
| `svelte/store` の writable を使う | Svelte 5 Runes ベースのコードベースに store を混在させることになり、一貫性が損なわれる |
| VisualPreviewCard 内で自前 fetch する | content と同じフォールバック方式だが、OGP 画像は API レスポンスに含まれるため別途 fetch は無駄 |

### フロントエンド変更

#### ArticlePrefetcher — コールバック追加

`onContentFetched` と同じパターンで `onOgImageFetched` コールバックを追加。`prefetchContent` 内で `ogImageCache.set()` の直後に発火する。

```typescript
private onOgImageFetched: (() => void) | null = null;

public setOnOgImageFetched(cb: (() => void) | null): void {
    this.onOgImageFetched = cb;
}
```

#### SwipeFeedScreen — リアクティブ OGP 画像追跡

バージョンカウンタ + `$derived.by()` パターンで、`ogImageCache` の変更を Svelte のリアクティビティシステムに橋渡しする。

```typescript
let ogImageVersion = $state(0);

onMount(() => {
    articlePrefetcher.setOnOgImageFetched(() => { ogImageVersion++; });
    return () => articlePrefetcher.setOnOgImageFetched(null);
});

const currentOgImage = $derived.by(() => {
    void ogImageVersion; // リアクティビティトリガー
    if (!activeFeed) return null;
    return articlePrefetcher.getCachedOgImage(activeFeed.normalizedUrl) ?? null;
});
```

テンプレートで `thumbnailUrl={currentOgImage}` に置き換え。`loadMore` 初回パスの直接 `ogImageCache` 書き込み後にも `ogImageVersion++` を追加。

### バックエンド変更

#### 軽量クエリメソッド追加

`article_head_driver.go` に `FetchOgImageURLByArticleID` を追加。`head_html` を読まず `og_image_url` のみ SELECT する。

```sql
SELECT COALESCE(og_image_url, '') FROM article_heads WHERE article_id = $1
```

#### Usecase 変更

`FetchCompliantArticle` の既存記事パスで `FetchArticleHeadByArticleID`（全カラム取得）→ `FetchOgImageURLByArticleID`（1 カラムのみ）に置き換え。

## 結果・影響

### 変更ファイル一覧

#### フロントエンド (alt-frontend-sv)

| ファイル | 変更内容 |
|---------|---------|
| `lib/utils/articlePrefetcher.ts` | `onOgImageFetched` コールバック追加、`prefetchContent` 内で発火 |
| `lib/utils/articlePrefetcher.spec.ts` | コールバック発火・クリア・空 URL 時の 3 テスト追加 |
| `lib/components/mobile/feeds/swipe/SwipeFeedScreen.svelte` | `ogImageVersion` + `currentOgImage` `$derived` 導入、テンプレート修正 |

#### バックエンド (alt-backend)

| ファイル | 変更内容 |
|---------|---------|
| `driver/alt_db/article_head_driver.go` | `FetchOgImageURLByArticleID` 追加 |
| `usecase/fetch_article_usecase/fetch_article_usecase.go` | インターフェースに `FetchOgImageURLByArticleID` 追加、既存記事パスで使用 |
| `mocks/mock_article_repository.go` | `FetchOgImageURLByArticleID` mock 追加 |

### テスト結果

| テストスイート | 結果 |
|--------------|------|
| Backend usecase (`go test ./usecase/fetch_article_usecase/...`) | 9/9 PASS |
| Backend handler (`go test ./rest/...`) | 3/3 PASS |
| Frontend prefetcher (`bun test articlePrefetcher`) | 12/12 PASS |
| 型チェック (`svelte-check --threshold error`) | 0 エラー |

### 検証結果

| 検証項目 | 結果 |
|---------|------|
| コンテナ再ビルド | alt-backend, alt-frontend-sv ビルド成功 |
| Backend ヘルスチェック (`localhost:9000/v1/health`) | healthy |
| `/sv/feeds/swipe/visual-preview` | 正常応答 |
| `/sv/feeds/swipe` (既存) | 正常応答（回帰なし） |

### PROS

- **即座に OGP 画像が表示される**: プリフェッチ完了時にコールバック経由で Svelte が再評価し、`thumbnailUrl` がリアクティブに更新される
- **最小限の変更**: 既存の `ArticlePrefetcher` クラス構造を維持したまま、コールバック 1 つとバージョンカウンタで解決
- **DB I/O 削減**: 既存記事パスで `head_html`（5-50KB TEXT）の読み込みを回避。`og_image_url`（通常 100 バイト未満）のみ取得
- **既存パターンとの一貫性**: `onContentFetched` と同じコールバックパターンを踏襲

### CONS, TRADEOFF

- **バージョンカウンタは全 ogImageCache の変更で発火**: 特定の URL に限定した更新通知ではないため、無関係な記事の OGP 取得でも `$derived` が再評価される。ただし `getCachedOgImage` は `Map.get()` のみで計算コストは無視できる
- **`ArticlePrefetcher` が Svelte のリアクティビティスコープ外**: 根本的にはクラスインスタンスを Svelte runes 管理下に置くリファクタリングが理想だが、影響範囲が大きいため今回はコールバック方式を採用

## 付録

### Svelte 5 における外部状態のリアクティビティパターン

Svelte 5 の `$state` / `$derived` はコンポーネントスコープ内で定義された変数に対して動作する。モジュールスコープで生成されたクラスインスタンスの内部状態変更を Svelte に通知するには、以下のいずれかが必要:

1. **コールバック + バージョンカウンタ**（本 ADR で採用）: 外部クラスのコールバックでコンポーネント内の `$state` カウンタをインクリメントし、`$derived` の依存に含める
2. **`$state` 化されたラッパー**: クラスインスタンス自体を `$state` で管理し、プロパティ変更を Svelte に追跡させる
3. **Svelte Store**: `writable` / `readable` で状態を管理する（Svelte 5 では非推奨方向）

### ADR-000268 からの差分

| 項目 | ADR-000268 | ADR-000269 (本 ADR) |
|------|-----------|---------------------|
| 課題 | フロントエンド regex 抽出の廃止 | ogImageCache の非リアクティブ性 |
| ogImageCache | `Map` で導入 | そのまま維持 + コールバック追加 |
| SwipeFeedScreen | 直接 `getCachedOgImage()` 呼び出し | `$derived` + バージョンカウンタ |
| バックエンド og:image 取得 | `FetchArticleHeadByArticleID`（全カラム） | `FetchOgImageURLByArticleID`（1 カラム） |
