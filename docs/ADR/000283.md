# LATERAL Subquery Optimization for article_tags JOIN Bottleneck

## ADR's STATUS

Accepted — 2026-02-27

## CONTEXT

EXPLAIN ANALYZE audit (ADR-000282) identified 5 queries exceeding performance thresholds, all sharing the same root cause:

```sql
LEFT JOIN article_tags + LEFT JOIN feed_tags + GROUP BY a.id + ORDER BY + LIMIT
```

PostgreSQL cannot push `LIMIT` past `GROUP BY`, so the planner was forced to:

1. Merge Left Join the entire `article_tags` table (~395K rows)
2. External merge sort on disk (16,952 kB work_mem spill)
3. Aggregate all groups, then discard everything except the `LIMIT` rows

| ID | Query | Measured Time | Purpose |
|----|-------|--------------|---------|
| H-05 | FetchArticlesWithCursor (first page) | 824 ms | User-facing article list API |
| H-06 | FetchArticlesWithCursor (cursor) | 368 ms | Same (page 2+) |
| M-01 | ListArticlesWithTags (backward, first) | 1,264 ms | search-indexer batch |
| M-02 | ListArticlesWithTags (backward, cursor) | 1,452 ms | Same |
| M-03 | ListArticlesWithTagsForward | 1,033 ms | search-indexer incremental |

Dataset: ~25K articles, ~395K article_tags rows.

## DECISION MAKING

### Approach: LATERAL Subquery

Replace the flat `JOIN → GROUP BY → LIMIT` pattern with a two-phase approach:

**Before** — join all rows, aggregate, then limit:
```sql
SELECT a.*, ARRAY_AGG(ft.tag_name) as tags
FROM articles a
LEFT JOIN article_tags at ON a.id = at.article_id
LEFT JOIN feed_tags ft ON at.feed_tag_id = ft.id
WHERE a.user_id = $1 AND a.deleted_at IS NULL
GROUP BY a.id
ORDER BY a.created_at DESC LIMIT 20
```

**After** — limit first, then fetch tags per row via LATERAL:
```sql
SELECT a.*,
       COALESCE(tags.tag_names, '{}') as tags
FROM (
    SELECT id, title, url, content, created_at
    FROM articles
    WHERE user_id = $1 AND deleted_at IS NULL
    ORDER BY created_at DESC, id DESC
    LIMIT $2
) a
LEFT JOIN LATERAL (
    SELECT ARRAY_AGG(ft.tag_name) as tag_names
    FROM article_tags at
    JOIN feed_tags ft ON at.feed_tag_id = ft.id
    WHERE at.article_id = a.id
) tags ON TRUE
ORDER BY a.created_at DESC, a.id DESC
```

**Why this works:**

1. The inner subquery applies `ORDER BY` + `LIMIT` first, fetching only N rows via an existing index scan (`idx_articles_active_user_created` or `idx_articles_cover_desc`)
2. `LEFT JOIN LATERAL` executes once per row (N times), each time performing a Nested Loop via `article_tags_pkey` + `feed_tags_pkey`
3. For LIMIT 20: ~20 index scans + ~20 × ~15 tag lookups = ~300 index lookups total (vs scanning 395K rows previously)

**Precedent:** `GetArticleWithTagsByID` (single-article lookup) already uses the same Nested Loop execution plan and completes in 4.8 ms.

### Files Modified

| File | Queries Changed | Query IDs |
|------|----------------|-----------|
| `alt-backend/app/driver/alt_db/fetch_articles_cursor_driver.go` | 2 | H-05, H-06 |
| `alt-backend/app/driver/alt_db/internal_articles_driver.go` | 4 | M-01, M-02, M-03 |
| `search-indexer/app/driver/database_driver.go` | 4 | (same pattern) |

**Total: 10 SQL queries rewritten, 0 interface changes.** Port/Gateway/Usecase/Handler layers are unaffected — this is a pure driver-layer SQL optimization.

### Not Changed

- **FetchRecentArticles** (H-10): 24h window filters to ~285 rows, measured at 21 ms — already passing.
- **GetArticleByID / GetArticleWithTagsByID**: PK lookup, 0.1–5 ms — already passing.
- **FetchArticlesByIDs**: `= ANY()` array lookup, 0.11 ms — already passing.

## RESULTS, EFFECTS

### EXPLAIN ANALYZE Measurements (Post-Change)

| ID | Query | Before | After (warm) | Speedup | Execution Plan |
|----|-------|--------|-------------|---------|----------------|
| H-05 | FetchArticlesWithCursor (first) | 824 ms | **0.86 ms** | 960x | Nested Loop Left Join, Index Scan `idx_articles_active_user_created` |
| H-06 | FetchArticlesWithCursor (cursor) | 368 ms | **4.1 ms** | 90x | Same |
| M-01 | ListArticlesWithTags (backward) | 1,264 ms | **6.7 ms** | 189x | Nested Loop Left Join, Index Scan `idx_articles_cover_desc` |
| M-02 | ListArticlesWithTags (cursor) | 1,452 ms | **7.2 ms** | 201x | Same |
| M-03 | ListArticlesWithTagsForward | 1,033 ms | **38.8 ms** | 27x | Same (ASC direction) |

All queries now under the 50 ms threshold.

**Execution plan characteristics confirmed:**
- Nested Loop Left Join (previously: Merge Left Join with 16,952 kB disk sort)
- Inner subquery: Index Scan with LIMIT pushdown
- LATERAL: Index Only Scan on `article_tags_pkey` + Index Scan on `feed_tags_pkey`
- No Seq Scan on `article_tags` — fully eliminated

**M-03 note:** Higher than others because forward-direction articles (created_at > cutoff) actually have tags assigned (~18 tags/article × 200 rows = 3,599 feed_tags lookups). The backward queries hit the newest articles which have not yet been tagged (0 article_tags rows), making their LATERAL essentially a no-op.

### PROS

- All 5 FAIL queries from ADR-000282 now PASS (< 50 ms)
- No schema changes, no new indexes required
- No interface or API contract changes — pure SQL-layer optimization
- Existing test suites pass without modification
- Pattern is consistent with existing single-article query (`GetArticleWithTagsByID`)

### CONS, TRADEOFF

- LATERAL executes N separate index lookups instead of one bulk join — for very large LIMIT values (e.g., 1000+), the per-row overhead could become noticeable. Current usage is LIMIT 20 (user API) and LIMIT 200 (batch indexer), both well within efficient range.
- `ORDER BY t.tag_name` sort in LATERAL is per-row quicksort in memory (25 kB). Negligible for typical tag counts (~15 tags/article).

## APPENDIX

- ADR-000282: EXPLAIN ANALYZE full audit results
- PostgreSQL LATERAL JOIN reference: https://www.postgresql.org/docs/current/queries-table-expressions.html#QUERIES-LATERAL
