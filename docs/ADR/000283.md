# article_tags JOIN ボトルネックに対する LATERAL サブクエリ最適化

## ADR ステータス

承認済み — 2026-02-27

## 背景

EXPLAIN ANALYZE 監査（ADR-000282）により、パフォーマンス閾値を超える5つのクエリが特定された。すべて同じ根本原因を共有している:

```sql
LEFT JOIN article_tags + LEFT JOIN feed_tags + GROUP BY a.id + ORDER BY + LIMIT
```

PostgreSQL は `LIMIT` を `GROUP BY` の手前にプッシュダウンできないため、プランナは以下を強制される:

1. `article_tags` テーブル全体（約395K行）に対する Merge Left Join
2. ディスク上での外部マージソート（16,952 kB の work_mem スピル）
3. すべてのグループを集約後、`LIMIT` 行以外をすべて破棄

| ID | クエリ | 計測時間 | 用途 |
|----|--------|----------|------|
| H-05 | FetchArticlesWithCursor（最初のページ） | 824 ms | ユーザー向け記事一覧 API |
| H-06 | FetchArticlesWithCursor（カーソル） | 368 ms | 同上（2ページ目以降） |
| M-01 | ListArticlesWithTags（逆順、最初） | 1,264 ms | search-indexer バッチ |
| M-02 | ListArticlesWithTags（逆順、カーソル） | 1,452 ms | 同上 |
| M-03 | ListArticlesWithTagsForward | 1,033 ms | search-indexer 差分更新 |

データセット: 約25K記事、約395K article_tags 行。

## 意思決定

### アプローチ: LATERAL サブクエリ

フラットな `JOIN → GROUP BY → LIMIT` パターンを、2段階アプローチに置き換える:

**変更前** — 全行を結合し、集約後に制限:
```sql
SELECT a.*, ARRAY_AGG(ft.tag_name) as tags
FROM articles a
LEFT JOIN article_tags at ON a.id = at.article_id
LEFT JOIN feed_tags ft ON at.feed_tag_id = ft.id
WHERE a.user_id = $1 AND a.deleted_at IS NULL
GROUP BY a.id
ORDER BY a.created_at DESC LIMIT 20
```

**変更後** — 先に制限し、LATERAL で行ごとにタグを取得:
```sql
SELECT a.*,
       COALESCE(tags.tag_names, '{}') as tags
FROM (
    SELECT id, title, url, content, created_at
    FROM articles
    WHERE user_id = $1 AND deleted_at IS NULL
    ORDER BY created_at DESC, id DESC
    LIMIT $2
) a
LEFT JOIN LATERAL (
    SELECT ARRAY_AGG(ft.tag_name) as tag_names
    FROM article_tags at
    JOIN feed_tags ft ON at.feed_tag_id = ft.id
    WHERE at.article_id = a.id
) tags ON TRUE
ORDER BY a.created_at DESC, a.id DESC
```

**なぜこれが有効か:**

1. 内側のサブクエリが先に `ORDER BY` + `LIMIT` を適用し、既存のインデックススキャン（`idx_articles_active_user_created` または `idx_articles_cover_desc`）を使って N 行のみを取得
2. `LEFT JOIN LATERAL` は行ごとに1回実行（N回）、各回で `article_tags_pkey` + `feed_tags_pkey` による Nested Loop を実行
3. LIMIT 20 の場合: 約20回のインデックススキャン + 約20 × 約15回のタグルックアップ = 合計約300回のインデックスルックアップ（以前は395K行のスキャン）

**前例:** `GetArticleWithTagsByID`（単一記事の検索）は既に同じ Nested Loop 実行プランを使用しており、4.8 ms で完了する。

### 変更対象ファイル

| ファイル | 変更クエリ数 | クエリ ID |
|----------|-------------|-----------|
| `alt-backend/app/driver/alt_db/fetch_articles_cursor_driver.go` | 2 | H-05, H-06 |
| `alt-backend/app/driver/alt_db/internal_articles_driver.go` | 4 | M-01, M-02, M-03 |
| `search-indexer/app/driver/database_driver.go` | 4 | （同パターン） |

**合計: 10個の SQL クエリを書き換え、インターフェース変更は0件。** Port/Gateway/Usecase/Handler レイヤーに影響なし — 純粋なドライバーレイヤーの SQL 最適化。

### 変更対象外

- **FetchRecentArticles**（H-10）: 24時間ウィンドウで約285行にフィルタリングされ、計測値 21 ms — 既に合格。
- **GetArticleByID / GetArticleWithTagsByID**: PK ルックアップ、0.1–5 ms — 既に合格。
- **FetchArticlesByIDs**: `= ANY()` 配列ルックアップ、0.11 ms — 既に合格。

## 結果・影響

### EXPLAIN ANALYZE 計測結果（変更後）

| ID | クエリ | 変更前 | 変更後（ウォーム） | 高速化倍率 | 実行プラン |
|----|--------|--------|-------------------|-----------|------------|
| H-05 | FetchArticlesWithCursor（最初） | 824 ms | **0.86 ms** | 960倍 | Nested Loop Left Join, Index Scan `idx_articles_active_user_created` |
| H-06 | FetchArticlesWithCursor（カーソル） | 368 ms | **4.1 ms** | 90倍 | 同上 |
| M-01 | ListArticlesWithTags（逆順） | 1,264 ms | **6.7 ms** | 189倍 | Nested Loop Left Join, Index Scan `idx_articles_cover_desc` |
| M-02 | ListArticlesWithTags（カーソル） | 1,452 ms | **7.2 ms** | 201倍 | 同上 |
| M-03 | ListArticlesWithTagsForward | 1,033 ms | **38.8 ms** | 27倍 | 同上（ASC 方向） |

すべてのクエリが 50 ms の閾値を下回った。

**確認された実行プラン特性:**
- Nested Loop Left Join（以前: 16,952 kB ディスクソートを伴う Merge Left Join）
- 内側サブクエリ: LIMIT プッシュダウン付き Index Scan
- LATERAL: `article_tags_pkey` の Index Only Scan + `feed_tags_pkey` の Index Scan
- `article_tags` の Seq Scan なし — 完全に排除

**M-03 に関する注記:** 他のクエリより高いのは、順方向の記事（created_at > カットオフ）にはタグが付与されているため（約18タグ/記事 × 200行 = 3,599回の feed_tags ルックアップ）。逆順クエリはまだタグ付けされていない最新記事にヒットする（article_tags 行が0件）ため、LATERAL は実質ノーオペレーションとなる。

### 利点

- ADR-000282 で FAIL だった5つのクエリがすべて PASS（< 50 ms）
- スキーマ変更不要、新規インデックス不要
- インターフェースや API 契約の変更なし — 純粋な SQL レイヤーの最適化
- 既存テストスイートが修正なしで通過
- 既存の単一記事クエリ（`GetArticleWithTagsByID`）と一貫したパターン

### 欠点・トレードオフ

- LATERAL は一括結合の代わりに N 回の個別インデックスルックアップを実行する — LIMIT 値が非常に大きい場合（例: 1000以上）、行あたりのオーバーヘッドが顕著になる可能性がある。現在の使用量は LIMIT 20（ユーザー API）および LIMIT 200（バッチインデクサー）であり、いずれも効率的な範囲内。
- LATERAL 内の `ORDER BY t.tag_name` ソートはメモリ上の行ごとクイックソート（25 kB）。一般的なタグ数（約15タグ/記事）では無視できるレベル。

## 付録

- ADR-000282: EXPLAIN ANALYZE 完全監査結果
- PostgreSQL LATERAL JOIN リファレンス: https://www.postgresql.org/docs/current/queries-table-expressions.html#QUERIES-LATERAL
