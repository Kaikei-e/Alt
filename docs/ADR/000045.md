# article_tags テーブルへの PRIMARY KEY 制約追加

## ADR's STATUS

**承認済み（Accepted）** - 2026年1月

## CONTEXT

tag-generator サービスが以下のエラーを出力し、タグの保存に失敗していた：

```
Database operation failed: there is no unique or exclusion constraint matching the ON CONFLICT specification
```

### 問題の原因

`article_tags` テーブルにおいて、`ON CONFLICT (article_id, feed_tag_id) DO NOTHING` を使用したUPSERT操作を行っていたが、該当カラムにPRIMARY KEY制約が存在しなかった。

| テーブル | 期待される制約 | 実際の状態 |
|----------|---------------|-----------|
| `feed_tags` | UNIQUE (feed_id, tag_name) | 存在 |
| `article_tags` | PRIMARY KEY (article_id, feed_tag_id) | **存在しない** |

### 定量的な影響

- **重複データ**: 145,970件の重複ペアが存在
- **エラー頻度**: 処理サイクルごとにエラーが発生
- **影響範囲**: すべてのタグ保存処理が失敗

### 根本原因

マイグレーション `20240101002700_create_article_tags_table.sql` では PRIMARY KEY が定義されていたが、実際のデータベースには適用されていなかった。

## DECISION MAKING

### マイグレーションによる PRIMARY KEY 制約追加

1. **重複データの削除**（古いレコードを保持）
2. **PRIMARY KEY 制約の追加**

```sql
-- Step 1: Remove duplicate rows, keeping only the oldest one
DELETE FROM article_tags a
USING (
    SELECT article_id, feed_tag_id, MIN(ctid) as min_ctid
    FROM article_tags
    GROUP BY article_id, feed_tag_id
    HAVING COUNT(*) > 1
) b
WHERE a.article_id = b.article_id
  AND a.feed_tag_id = b.feed_tag_id
  AND a.ctid <> b.min_ctid;

-- Step 2: Add primary key constraint
ALTER TABLE article_tags
    ADD PRIMARY KEY (article_id, feed_tag_id);
```

### 修正ファイル

| ファイル | 変更内容 |
|----------|----------|
| `migrations-atlas/migrations/20260102000000_add_article_tags_primary_key.sql` | 新規マイグレーション |

## RESULTS, EFFECTS

### 修正前のテーブル構造

```
Indexes:
    "idx_article_tags_created_at" btree (created_at)
    "idx_article_tags_feed_tag_id" btree (feed_tag_id)
```

### 修正後のテーブル構造

```
Indexes:
    "article_tags_pkey" PRIMARY KEY, btree (article_id, feed_tag_id)
    "idx_article_tags_created_at" btree (created_at)
    "idx_article_tags_feed_tag_id" btree (feed_tag_id)
```

### PROS

1. **エラー解消**
   - `ON CONFLICT` が正常に動作
   - tag-generator のタグ保存処理が成功

2. **データ整合性の向上**
   - 重複データの防止
   - 参照整合性の強化

3. **クエリパフォーマンス**
   - PRIMARY KEY インデックスによる検索高速化

### CONS, TRADEOFF

1. **データ削除**
   - 145,970件の重複レコードを削除
   - 古いレコードのみ保持（created_at が早いもの）

2. **マイグレーション時間**
   - 大量データの削除処理が必要（実行時間: 約0.5秒）

## APPENDIX

### PostgreSQL ON CONFLICT のベストプラクティス

`ON CONFLICT` を使用するには、以下の制約が必要：

1. **PRIMARY KEY** - 推奨
2. **UNIQUE INDEX** - 代替手段
3. **EXCLUSION CONSTRAINT** - 特殊ケース

参考資料:
- [PostgreSQL ON CONFLICT Guide](https://www.dbvis.com/thetable/postgresql-upsert-insert-on-conflict-guide/)
- [pganalyze U125: Unmatched ON CONFLICT](https://pganalyze.com/docs/log-insights/app-errors/U125)
