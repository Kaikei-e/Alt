# フィード自動収集の停止バグ修正

## ADR ステータス

承認済み — 2026-02-28

## 背景

Feed Activity（フィード自動収集）が完全に停止し、収集件数が 0 になる事象が発生した。

### 調査結果

ログ分析とコードレビューにより、2 つの独立した根本原因を特定した。

**原因 1: `validateFeedURL` の HEAD リクエストによる誤検知**

`validateFeedURL` 関数は、フィードの解析前に HEAD リクエストで URL の到達性を検証していた。しかし、多くの RSS フィードサーバーは HEAD リクエストに対して 403 を返す一方、GET リクエストでは正常にフィードを配信する。

さらに `isPersistentError` 関数が 403 を永続的エラーとして分類していたため、以下の連鎖反応が発生した:

1. `validateFeedURL` が HEAD リクエストを送信
2. サーバーが 403 を返す（HEAD 非対応）
3. `isPersistentError` が 403 を永続的エラーと判定
4. `handleFeedError` が `feed_link_availability` の `consecutive_failures` をインクリメント
5. 閾値（5 回）到達で `is_active = false` に自動更新
6. `FetchRSSFeedURLs` の WHERE 句 `fla.is_active = true` により当該フィードが除外

この連鎖により、正常に GET で取得可能なフィードが次々と無効化され、最終的に収集対象が 0 件になった。

**原因 2: `feed_link_id` の未伝播**

`FetchRSSFeedURLs` は `[]url.URL`（URL のみ）を返しており、`feed_links.id` を取得していなかった。結果として `feeds` テーブルの `feed_link_id` カラムが常に NULL となり、フィードの出処追跡ができない状態だった。

## 意思決定

2 つの修正を実施した。

### Fix 1: `validateFeedURL` の簡素化と `isPersistentError` からの 403 除外

`validateFeedURL` から HEAD リクエストとレスポンス検証ロジックをすべて削除し、スキーム（http/https）とホストの存在チェックのみに簡素化した。ネットワーク到達性の検証は `gofeed.ParseURL`（GET リクエスト）に委譲する。

```go
// 変更前: HEAD リクエスト + ステータスコード検証 + Content-Type チェック（約 30 行）
// 変更後: スキームとホストの検証のみ（4 行）
func validateFeedURL(_ context.Context, feedURL url.URL) error {
    if feedURL.Scheme != "http" && feedURL.Scheme != "https" {
        return fmt.Errorf("invalid URL scheme: %s (must be http or https)", feedURL.Scheme)
    }
    if feedURL.Host == "" {
        return fmt.Errorf("missing host in URL")
    }
    return nil
}
```

`isPersistentError` から 403 を除外した。403 は WAF やレートリミットによる一時的なブロックであることが多く、永続的なクライアントエラーとは限らない。

```go
func isPersistentError(err error) bool {
    // ...
    return strings.Contains(errStr, "400") ||
        // 403 は除外: WAF/rate-limit による一時的ブロックの可能性が高い
        strings.Contains(errStr, "404") ||
        strings.Contains(errStr, "Failed to detect feed type")
}
```

### Fix 2: `feed_link_id` の伝播

`FetchRSSFeedURLs` の戻り値を `[]url.URL` から `[]domain.FeedLink`（`ID` + `URL` を持つ構造体）に変更し、SQL クエリで `fl.id` も取得するようにした。`CollectMultipleFeeds` 内でフィードアイテム変換後に `FeedLinkID` を設定し、`job_runner.go` で `models.Feed` に渡すことで、`feeds` テーブルへの `feed_link_id` の永続化を実現した。

```go
// CollectMultipleFeeds 内
items := ConvertFeedToFeedItem([]*rssFeed.Feed{feed})
feedLinkIDStr := feedLink.ID.String()
for _, item := range items {
    item.FeedLinkID = &feedLinkIDStr
}
```

### 変更ファイル一覧

| ファイル | 変更内容 |
|----------|---------|
| `alt-backend/app/driver/alt_db/fetch_rss_feed_urls_driver.go` | 戻り値を `[]domain.FeedLink` に変更、SQL で `fl.id` を追加取得 |
| `alt-backend/app/job/feed_collector.go` | `validateFeedURL` 簡素化、`isPersistentError` から 403 除外、`CollectMultipleFeeds` のシグネチャ変更と `feed_link_id` 設定 |
| `alt-backend/app/job/feed_collector_test.go` | 403 テストケースの期待値を `true` → `false` に変更、`TestValidateFeedURL` テスト追加 |
| `alt-backend/app/job/job_runner.go` | `feedURLs` → `feedLinks` リネーム、`FeedLinkID` を `models.Feed` に設定 |
| `alt-backend/app/gateway/fetch_feed_gateway/single_feed_gateway.go` | `FetchRSSFeedURLs` の新しい戻り値型に対応、`url.Parse` を追加 |

### 検証結果

| 検証項目 | 結果 |
|----------|------|
| `go test ./...` | 全テスト PASS |
| コンテナ再ビルド・再起動 | 正常起動 |
| `Found RSS feed URLs` count | 73（> 0 を確認） |
| Feed collection summary | successful=73, failed=0, total=73 |
| HEAD リクエスト起因エラー | 再起動後 0 件 |

## 結果・影響

### 利点

- HEAD リクエストの廃止により、HEAD 非対応サーバーからのフィード収集が正常化する。各フィードあたり 1 リクエスト（GET のみ）に削減され、外部サーバーへの負荷も軽減される
- 403 を永続的エラーから除外することで、WAF やレートリミットによる一時的なブロックでフィードが恒久的に無効化されることを防ぐ
- `feed_link_id` の伝播により、どの `feed_link` から取得された記事かを追跡可能になり、フィード品質の分析やデバッグが容易になる

### 欠点・トレードオフ

- `validateFeedURL` がネットワーク検証を行わなくなったため、到達不能な URL に対しても `gofeed.ParseURL` が GET リクエストを試行する。ただし、GET リクエストは実際のフィード取得と兼用されるため、追加のネットワークコストは発生しない
- 403 を永続的エラーから除外したことで、真に 403 を返すフィード（アクセス制限等）に対する自動無効化が機能しなくなる。これらは手動での確認・無効化が必要になる

## 付録

### デプロイ後のワンショット SQL

過去に誤って無効化されたフィードを復元し、失敗カウントをリセットする。

```sql
-- 1. 誤って無効化されたフィードの復元
UPDATE feed_link_availability
SET is_active = true,
    consecutive_failures = 0,
    last_error = NULL,
    updated_at = NOW()
WHERE is_active = false;

-- 2. 復元件数の確認
SELECT COUNT(*) AS restored_count
FROM feed_link_availability
WHERE is_active = true AND updated_at > NOW() - INTERVAL '1 minute';
```

### バックフィル戦略

`feeds.feed_link_id` が NULL の既存レコードについては、`feeds.link` のドメインと `feed_links.url` のドメインを突合させることでバックフィル可能だが、1:N の関係（同一ドメインに複数の feed_link が存在するケース）があるため完全な自動マッチングは困難である。運用上の必要性に応じて段階的に対応する。
