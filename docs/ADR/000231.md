# ADR-000231: Recap ページ TTS 音読機能のフロントエンド実装

## STATUS

Accepted（実装完了・29 件のユニットテスト全件 PASS・lint/format/type-check 全 PASS）

## CONTEXT

ADR-230 で tts-speaker (Kokoro-82M) マイクロサービスと alt-butterfly-facade 経由の connect-rpc ルーティングが整備された。次のステップとして、Recap ページのジャンル別サマリーをブラウザ上で音声読み上げする UI を追加する必要があった。

### 要件

- Recap ページでジャンル選択時に、サマリーと Key Points をワンクリックで音読開始できること
- 読み上げ中の停止操作ができること
- ジャンル切替時に再生を自動停止すること
- 長文テキストをチャンク分割して順次再生すること（TTS サービスの 5000 文字制限対応）
- Desktop ビュー対応（v1）

### 技術的前提

- 通信経路: alt-frontend-sv → alt-butterfly-facade (BFF) → tts-speaker
- BFF は `/alt.tts.v1.TTSService/` を tts-speaker へルーティング済み
- SvelteKit API プロキシは全パスを BFF へ転送済み
- **バックエンド変更不要** — フロントエンドのみの実装

## DECISION MAKING

### レイヤー構成

Clean Architecture に従い、4 レイヤーで責務を分離した。

```
RecapDetail.svelte (UI 統合)
  └── useTtsPlayback.svelte.ts (状態管理・再生制御)
        ├── tts.ts (Connect-RPC クライアント)
        └── audio.ts (WAV 再生ユーティリティ)
```

### テキスト分割戦略

TTS サービスの 5000 文字制限に対し、`splitTextForTts()` でチャンク分割を行う。

1. 日本語句点 `。` で分割（自然な区切り優先）
2. 改行 `\n` で分割（次善の区切り）
3. 上記が見つからない場合はハードカット

### 再生制御パターン

`useTtsPlayback` フックで以下の状態遷移を管理する。

```
idle → loading → playing → idle
  ↑       ↓         ↓
  └── error ←────────┘
```

- `play()`: チャンク分割 → 順次合成 → 順次再生（`onEnded` チェーン）
- `stop()`: `pendingResolve` パターンで再生中の Promise を即座に解決し、`cancelled` フラグで後続チャンクをスキップ
- ジャンル切替: `$effect` の cleanup 関数で `stop()` を呼び出し

### ブラウザ自動再生ポリシー

ユーザーのボタンクリックが起点のため、初回チャンクの `audio.play()` はブラウザに許可される。後続チャンクは `onEnded` コールバック内で再生開始されるため、ユーザーインタラクション起点のオーディオコンテキストが継続する。

### 代替案: Web Audio API

`HTMLAudioElement` の代わりに Web Audio API (`AudioContext` + `decodeAudioData`) を使う案もあったが、以下の理由で `HTMLAudioElement` を選択した。

1. WAV バイナリの再生には `new Audio(blobURL)` で十分
2. Web Audio API はオーディオグラフ構築が必要で過剰
3. `onEnded` イベントによるチャンク連結が直感的

## RESULTS

### 新規ファイル

| ファイル | 責務 |
|---------|------|
| `src/lib/gen/alt/tts/v1/tts_pb.ts` | Proto 生成コード（`buf generate`） |
| `src/lib/utils/audio.ts` | `createAudioFromWav()`, `splitTextForTts()` |
| `src/lib/utils/audio.test.ts` | 15 テスト |
| `src/lib/connect/tts.ts` | `createTtsClient()`, `synthesizeSpeech()`, `listVoices()` |
| `src/lib/connect/tts.test.ts` | 6 テスト |
| `src/lib/hooks/useTtsPlayback.svelte.ts` | Svelte 5 Runes フック |
| `src/lib/hooks/useTtsPlayback.test.ts` | 8 テスト |

### 修正ファイル

| ファイル | 変更内容 |
|---------|---------|
| `proto/alt/tts/v1/tts.proto` | `go_package` オプション追加 |
| `src/lib/connect/index.ts` | TTS クライアントのエクスポート追加 |
| `src/lib/components/desktop/recap/RecapDetail.svelte` | TTS ボタン UI 追加 |
| `compose/bff.yaml` | BFF に `extra_hosts` (tts-external) 追加 |

### UI 設計

ジャンル名の右側にアイコンボタンを配置。状態に応じてアイコンが変化する。

| 状態 | アイコン (Lucide) | クリック動作 |
|------|------------------|------------|
| idle | `Volume2` | 音読開始 |
| loading | `Loader2` (animate-spin) | キャンセル |
| playing | `Square` | 停止 |
| error | `Volume2` + エラーテキスト | リトライ |

```
┌─────────────────────────────────────┐
│ genre_name                  [🔊]   │  ← ヘッダー行に音読ボタン
│ N articles · M clusters            │
│ TTS error message (if any)         │
├─────────────────────────────────────┤
│ Summary                             │
│ ...                                 │
```

### 読み上げ対象テキスト

```typescript
genre.summary + "\n" + genre.bullets.join("\n")
```

サマリー本文と Key Points を改行区切りで連結し、TTS に送信する。

### テスト結果

```
29 tests passed across 3 files
```

| テストファイル | 件数 | カバー範囲 |
|-------------|------|-----------|
| `audio.test.ts` | 15 | Blob 生成、play/stop/cleanup、onEnded、空データエラー、テキスト分割（句点・改行・ハードカット・境界値） |
| `tts.test.ts` | 6 | クライアント生成、デフォルト/カスタムオプション、エラー伝播、ボイスリスト |
| `useTtsPlayback.test.ts` | 8 | 初期状態、再生ライフサイクル、空テキスト、エラー状態、マルチチャンク、停止・クリーンアップ |

## PROS

1. **バックエンド変更ゼロ**: フロントエンドのみの追加で TTS 機能を実現。既存の BFF ルーティングを活用
2. **TDD**: 29 件のテストで全パスをカバー。Proto モックにより tts-speaker 無しでテスト可能
3. **チャンク分割**: 5000 文字制限を自動分割で吸収。ユーザーは文字数を意識する必要がない
4. **リソース管理**: `URL.revokeObjectURL()` による確実なメモリ解放、ジャンル切替時の自動停止

## CONS, TRADEOFF

1. **Desktop のみ対応**: モバイルビューは v1 スコープ外。将来的に `RecapDetail` のモバイル版にも同様のフックを適用可能
2. **順次合成の遅延**: チャンクごとに TTS リクエストを送信するため、チャンク間に合成待ち時間が発生する。プリフェッチによる改善は将来課題
3. **エラー時の部分再生**: マルチチャンクの途中で TTS エラーが発生した場合、既に再生済みのチャンクは巻き戻せない
4. **ボイス固定**: デフォルトボイス `jf_alpha` をハードコード。UI からのボイス選択機能は将来課題
