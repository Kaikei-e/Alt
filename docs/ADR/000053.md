# RAGベクトル検索における責務分離：時間制限付き検索と全文検索

## ステータス

採択（Accepted）

## コンテキスト

RAGオーケストレーターのベクトル検索機能において、以下の2つの異なるユースケースが存在していた：

1. **全文検索（Augur）**: 全記事コーパスからの質問応答
2. **時間制限付き検索（Morning Letter）**: 直近N時間の記事のみを対象とした要約生成

従来の実装では、単一の`Search`メソッドがTwo-Stage Search戦略を採用し、両方のユースケースを処理しようとしていた：

```go
// 旧実装
func (r *ragChunkRepository) Search(
    ctx context.Context,
    queryVector []float32,
    candidateArticleIDs []string,  // 時間制限用フィルタ
    limit int,
) ([]SearchResult, error)
```

### 問題点

Two-Stage Searchは以下のように動作していた：

- **Stage 1**: HNSWインデックスを効率的に活用するため、全チャンクから類似度上位N件を取得（article_idフィルタなし）
- **Stage 2**: 取得したチャンクに対して`candidateArticleIDs`でフィルタリング

この設計には致命的な問題があった：

Stage 1で取得したN件のチャンクは類似度順で選ばれるため、直近24時間の記事（全体のごく少数）からのチャンクが含まれる確率は極めて低い。Stage 2でarticle_idフィルタを適用すると、結果が**0件**になる問題が発生していた。

```
// 実際のログ
{"msg":"vector_search_completed","original_hits":0,"expanded_hits_unique":0,"final_contexts":0}
```

## 決定

責務を明確に分離し、2つの専用メソッドを実装する：

### 1. インターフェース設計

```go
type RagChunkRepository interface {
    // Search: 全文検索（Augur用）
    // Two-Stage SearchでHNSWインデックスを効率的に活用
    Search(ctx context.Context, queryVector []float32, limit int) ([]SearchResult, error)

    // SearchWithinArticles: 時間制限付き検索（Morning Letter用）
    // 事前フィルタリングによる確実な記事絞り込み
    SearchWithinArticles(ctx context.Context, queryVector []float32, articleIDs []string, limit int) ([]SearchResult, error)
}
```

### 2. 全文検索（Search）の実装

従来のTwo-Stage Search戦略を維持：

```go
func (r *ragChunkRepository) Search(ctx context.Context, queryVector []float32, limit int) ([]SearchResult, error) {
    // Stage 1: HNSWインデックスを活用した純粋なベクトル検索
    stage1Query := `
        SELECT c.id, (c.embedding <=> $1) as distance
        FROM rag_chunks c
        ORDER BY distance ASC
        LIMIT $2
    `

    // Stage 2: メタデータ付与（current_versionのみ）
    stage2Query := `
        SELECT c.id, c.content, d.article_id, v.title, v.url
        FROM rag_chunks c
        JOIN rag_document_versions v ON c.version_id = v.id
        JOIN rag_documents d ON v.document_id = d.id
        WHERE c.id = ANY($1) AND d.current_version_id = v.id
    `
    // ...
}
```

### 3. 時間制限付き検索（SearchWithinArticles）の実装

Single-pass queryで事前フィルタリングを適用：

```go
func (r *ragChunkRepository) SearchWithinArticles(ctx context.Context, queryVector []float32, articleIDs []string, limit int) ([]SearchResult, error) {
    // 事前フィルタリング + ベクトル検索を1クエリで実行
    // HNSWインデックスは使えないが、対象チャンク数が少ないため許容範囲
    query := `
        SELECT c.id, c.content, d.article_id, v.title, v.url,
               (c.embedding <=> $1) as distance
        FROM rag_chunks c
        JOIN rag_document_versions v ON c.version_id = v.id
        JOIN rag_documents d ON v.document_id = d.id
        WHERE d.article_id = ANY($2)
          AND d.current_version_id = v.id
        ORDER BY distance ASC
        LIMIT $3
    `
    // ...
}
```

### 4. ユースケース層での呼び分け

```go
func (u *retrieveContextUsecase) Execute(ctx context.Context, input RetrieveContextInput) (*RetrieveContextOutput, error) {
    // ...

    hasCandidateArticles := len(input.CandidateArticleIDs) > 0

    for i, queryVector := range embeddings {
        go func(idx int, qv []float32) {
            var results []domain.SearchResult
            var err error
            if hasCandidateArticles {
                // 時間制限付き検索: 指定記事内のみ検索
                results, err = u.chunkRepo.SearchWithinArticles(ctx, qv, input.CandidateArticleIDs, searchLimit)
            } else {
                // 全文検索: 全チャンクから検索
                results, err = u.chunkRepo.Search(ctx, qv, searchLimit)
            }
            // ...
        }(i, queryVector)
    }
}
```

## 結果

### メリット

1. **責務の明確化**: 各メソッドが単一の責務を持ち、意図が明確
2. **確実な動作**: 時間制限付き検索が確実に指定期間の記事から結果を返す
3. **パフォーマンス最適化**: 全文検索はHNSWインデックスを最大限活用
4. **テスタビリティ**: 各ユースケースを独立してテスト可能

### トレードオフ

1. **SearchWithinArticlesのパフォーマンス**: HNSWインデックスを効率的に使えないが、対象チャンク数が限定的（通常数千件）なため許容範囲
2. **インターフェースの拡大**: メソッドが1つ増加するが、責務の明確化により保守性は向上

### 性能特性

| メソッド | インデックス活用 | 対象チャンク数 | 典型的なレイテンシ |
|----------|------------------|----------------|---------------------|
| Search | HNSW最適化 | 全件（30万+） | 50-100ms |
| SearchWithinArticles | フルスキャン | 限定的（数千件） | 30-80ms |

## 参考

- [pgvector HNSW Index](https://github.com/pgvector/pgvector#hnsw)
- [PostgreSQL Index-Only Scans](https://www.postgresql.org/docs/current/indexes-index-only-scans.html)
