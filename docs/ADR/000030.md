# Connect-RPC Phase 2-3: Feed List / Search エンドポイントの移行

## ステータス

**採択・実装完了（Accepted & Implemented）** - 2025年12月31日

## コンテキスト

### 背景

ADR-000028で導入したConnect-RPC基盤のPhase 1（Feed Stats）が完了し、Phase 2-3としてFeed List / Search エンドポイントの移行を実施した。

### 対象エンドポイント

| Phase | REST (v1) | Connect-RPC (v2) | 説明 |
|-------|-----------|------------------|------|
| 2 | `GET /v1/feeds/fetch/cursor` | `FeedService.GetUnreadFeeds` | 未読フィード一覧 |
| 2 | `GET /v1/feeds/fetch/viewed/cursor` | `FeedService.GetReadFeeds` | 既読フィード一覧 |
| 2 | `GET /v1/feeds/fetch/favorites/cursor` | `FeedService.GetFavoriteFeeds` | お気に入り一覧 |
| 3 | `POST /v1/feeds/search` | `FeedService.SearchFeeds` | フィード検索 |

### 技術的課題

1. **ページネーション方式の違い**
   - Feed List: カーソルベース（RFC3339タイムスタンプ）
   - Search: オフセットベース（整数）

2. **レスポンス変換**
   - `domain.FeedItem` → `feedsv2.FeedItem` への変換
   - HTML sanitization, 相対時刻フォーマット等

3. **Usecase戻り値の差異**
   - `FetchUnreadFeedsListCursorUsecase`: `(feeds, hasMore, error)` を返す
   - `FetchReadFeedsListCursorUsecase`: `(feeds, error)` を返す（hasMoreなし）
   - `FetchFavoriteFeedsListCursorUsecase`: `(feeds, error)` を返す（hasMoreなし）

## 意思決定

### 決定1: 個別RPCパターンの採用

**検討した代替案:**

| パターン | メリット | デメリット |
|----------|----------|------------|
| 単一RPC（GetFeedsWithFilter） | 拡張が容易、DRY | フィルタロジックが複雑化 |
| **個別RPC（推奨）** | 明確なセマンティクス、型安全 | RPC数が増加 |

**採用理由:**
- 各フィードタイプのセマンティクスが明確（unread/read/favorite）
- 将来的なフィルタ追加時も、既存RPCに影響しない
- Connect-RPCの推奨パターンに準拠

### 決定2: FeedItemメッセージの設計

```protobuf
message FeedItem {
  string id = 1;          // Link をIDとして使用
  string title = 2;
  string description = 3; // HTML sanitized
  string link = 4;
  string published = 5;   // "2h ago" 形式
  string created_at = 6;  // RFC3339
  string author = 7;
}
```

**設計判断:**
- `id`に`link`を使用: 既存フロントエンドとの互換性維持
- `published`を相対時刻: UXの一貫性（既存REST APIと同様）
- `created_at`をRFC3339: プログラム処理用の正確なタイムスタンプ

### 決定3: カーソル/ページネーション設計

**Feed List（カーソルベース）:**
```protobuf
message GetUnreadFeedsRequest {
  optional string cursor = 1;  // RFC3339 timestamp
  int32 limit = 2;
  optional string view = 3;    // "swipe" for single card
}

message GetUnreadFeedsResponse {
  repeated FeedItem data = 1;
  optional string next_cursor = 2;
  bool has_more = 3;
}
```

**Search（オフセットベース）:**
```protobuf
message SearchFeedsRequest {
  string query = 1;
  optional int32 cursor = 2;  // offset
  optional int32 limit = 3;
}

message SearchFeedsResponse {
  repeated FeedItem data = 1;
  optional int32 next_cursor = 2;
  bool has_more = 3;
}
```

**理由:**
- Feed List: 時系列データに適したカーソルページネーション
- Search: Meilisearchのオフセットベース API との整合性

### 決定4: hasMore の算出ロジック

Usecase間で戻り値が異なるため、以下のパターンを採用:

```go
// FetchUnreadFeedsListCursorUsecase: hasMoreを直接返す
feeds, hasMore, err := h.container.FetchUnreadFeedsListCursorUsecase.Execute(ctx, cursor, limit)

// FetchReadFeedsListCursorUsecase, FetchFavoriteFeedsListCursorUsecase: hasMoreを算出
feeds, err := h.container.FetchReadFeedsListCursorUsecase.Execute(ctx, cursor, limit)
hasMore := len(feeds) >= limit
```

**理由:**
- 既存Usecaseの戻り値を変更せず、ハンドラー層で吸収
- `len(feeds) >= limit` は一般的なカーソルページネーションのhasMore算出パターン

### 決定5: ヘルパー関数の分離

`helpers.go` を新規作成し、変換ロジックを集約:

```go
// helpers.go
func convertFeedsToProto(feeds []*domain.FeedItem) []*feedsv2.FeedItem
func deriveNextCursor(feeds []*domain.FeedItem, hasMore bool) *string
func sanitizeDescription(html string) string
func formatTimeAgo(t time.Time) string
func formatAuthor(author domain.Author, authors []domain.Author) string
```

**理由:**
- ハンドラーのテスト容易性向上
- REST handlers（`rest_feeds/utils.go`）との重複を避けつつ、Connect-RPC用に最適化
- 単一責任原則の遵守

## 結果・影響

### 実装内容

#### Proto定義追加（feeds.proto）

```protobuf
// FeedItem メッセージ
message FeedItem {
  string id = 1;
  string title = 2;
  string description = 3;
  string link = 4;
  string published = 5;
  string created_at = 6;
  string author = 7;
}

// Phase 2: Feed List
message GetUnreadFeedsRequest { ... }
message GetUnreadFeedsResponse { ... }
message GetReadFeedsRequest { ... }
message GetReadFeedsResponse { ... }
message GetFavoriteFeedsRequest { ... }
message GetFavoriteFeedsResponse { ... }

// Phase 3: Search
message SearchFeedsRequest { ... }
message SearchFeedsResponse { ... }

service FeedService {
  // Phase 1 (既存)
  rpc GetFeedStats(...) returns (...);
  rpc GetDetailedFeedStats(...) returns (...);
  rpc GetUnreadCount(...) returns (...);
  rpc StreamFeedStats(...) returns (stream ...);

  // Phase 2 (新規)
  rpc GetUnreadFeeds(GetUnreadFeedsRequest) returns (GetUnreadFeedsResponse);
  rpc GetReadFeeds(GetReadFeedsRequest) returns (GetReadFeedsResponse);
  rpc GetFavoriteFeeds(GetFavoriteFeedsRequest) returns (GetFavoriteFeedsResponse);

  // Phase 3 (新規)
  rpc SearchFeeds(SearchFeedsRequest) returns (SearchFeedsResponse);
}
```

#### バックエンドハンドラー（handler.go）

4つの新規RPCハンドラーを実装:

```go
func (h *Handler) GetUnreadFeeds(ctx, req) (*connect.Response[feedsv2.GetUnreadFeedsResponse], error)
func (h *Handler) GetReadFeeds(ctx, req) (*connect.Response[feedsv2.GetReadFeedsResponse], error)
func (h *Handler) GetFavoriteFeeds(ctx, req) (*connect.Response[feedsv2.GetFavoriteFeedsResponse], error)
func (h *Handler) SearchFeeds(ctx, req) (*connect.Response[feedsv2.SearchFeedsResponse], error)
```

各ハンドラーの責務:
1. 認証チェック（`middleware.GetUserContext`）
2. リクエストパラメータのバリデーション
3. Usecase呼び出し
4. Proto変換とレスポンス構築

#### フロントエンドクライアント（feeds.ts）

```typescript
// 型定義
interface ConnectFeedItem { id, title, description, link, published, createdAt, author }
interface FeedCursorResponse { data: ConnectFeedItem[], nextCursor: string | null, hasMore: boolean }
interface FeedSearchResponse { data: ConnectFeedItem[], nextCursor: number | null, hasMore: boolean }

// クライアント関数
export async function getUnreadFeeds(transport, cursor?, limit?, view?): Promise<FeedCursorResponse>
export async function getReadFeeds(transport, cursor?, limit?): Promise<FeedCursorResponse>
export async function getFavoriteFeeds(transport, cursor?, limit?): Promise<FeedCursorResponse>
export async function searchFeeds(transport, query, cursor?, limit?): Promise<FeedSearchResponse>
```

### テスト

ユニットテストを`handler_test.go`に追加:

- `TestConvertFeedsToProto` - Proto変換
- `TestConvertFeedsToProto_EmptyList` - 空リスト
- `TestDeriveNextCursor_WithHasMore` - カーソル生成（hasMore=true）
- `TestDeriveNextCursor_WithoutHasMore` - カーソル生成（hasMore=false）
- `TestDeriveNextCursor_EmptyFeeds` - 空フィードでのカーソル
- `TestSanitizeDescription` - HTML sanitization
- `TestFormatTimeAgo` - 相対時刻フォーマット
- `TestFormatAuthor` - 著者名抽出
- `TestGetUnreadFeedsResponse_Construction` - レスポンス構築
- `TestSearchFeedsResponse_Construction` - 検索レスポンス構築

### PROS

1. **型安全なフィード取得**
   - Protocol Buffersによる厳密な型定義
   - TypeScript側でコンパイル時チェック

2. **一貫したページネーション**
   - カーソル/オフセット両方式に対応
   - `hasMore`フラグで明確な終端判定

3. **REST API並行運用**
   - 既存フロントエンドへの影響ゼロ
   - 段階的な切り替えが可能

4. **テスト容易性**
   - ヘルパー関数の単体テスト
   - モック不要のレスポンス構築テスト

### CONS, TRADEOFF

1. **RPC数の増加**
   - 4つの新規RPC追加
   - Protoファイルの肥大化

2. **Usecase戻り値の非統一**
   - hasMoreの有無がUsecaseにより異なる
   - ハンドラー層での吸収が必要

3. **重複ロジック**
   - REST handlers（`rest_feeds/utils.go`）と類似のヘルパー
   - 将来的な統合・リファクタリングの余地

## 付録

### 変更ファイル一覧

**新規作成:**

| ファイル | 説明 |
|----------|------|
| `alt-backend/app/connect/v2/feeds/helpers.go` | 変換ヘルパー関数 |

**変更:**

| ファイル | 変更内容 |
|----------|----------|
| `proto/alt/feeds/v2/feeds.proto` | FeedItem, Phase 2-3 メッセージ/RPC追加 |
| `alt-backend/app/connect/v2/feeds/handler.go` | 4つのRPCハンドラー追加 |
| `alt-backend/app/connect/v2/feeds/handler_test.go` | ユニットテスト追加 |
| `alt-frontend-sv/src/lib/connect/feeds.ts` | クライアント関数追加 |

**生成:**

| ファイル | 説明 |
|----------|------|
| `alt-backend/app/gen/proto/alt/feeds/v2/*.go` | Goコード再生成 |
| `alt-frontend-sv/src/lib/gen/alt/feeds/v2/*.ts` | TypeScriptコード再生成 |

### 移行ロードマップ更新

| Phase | 対象エンドポイント | 状態 |
|-------|-------------------|------|
| 1 | Feed Stats（3エンドポイント + Streaming） | **完了** |
| 2 | Feed List（カーソルページネーション） | **完了** |
| 3 | Feed Search | **完了** |
| 4 | Articles（content, archive） | 未着手 |
| 5 | RSS Feed Links（CRUD） | 未着手 |
| 6 | Streaming（summarize） | 未着手 |

### 使用例

**サーバーサイド（+page.server.ts）:**

```typescript
import { createServerTransport, getUnreadFeeds } from "$lib/connect";

export async function load({ request }) {
    const transport = await createServerTransport(request.headers.get("cookie"));
    const feeds = await getUnreadFeeds(transport, undefined, 20);
    return { feeds: feeds.data, hasMore: feeds.hasMore };
}
```

**クライアントサイド:**

```typescript
import { createClientTransport, searchFeeds } from "$lib/connect";

const transport = createClientTransport();
const results = await searchFeeds(transport, "typescript", 0, 20);
```

### 参考資料

- [ADR-000028: Buf Connect-RPCの導入とREST APIからの段階的移行](./000028.md)
- [ADR-000029: Connect-RPC Server Streaming認証におけるUserContext完全性の確保](./000029.md)
- [Connect-RPC公式ドキュメント](https://connectrpc.com/)
- [Protocol Buffers Language Guide](https://protobuf.dev/programming-guides/proto3/)

---

**作成日:** 2025年12月31日
