# ADR-000227: 検索 infinite scroll が停止しないバグの修正

## STATUS

Accepted（実装完了・コンテナデプロイ・動作確認済み）

## CONTEXT

デスクトップ検索ページ (`/desktop/feeds/search`) および レスポンシブ検索ページ (`/(app)/feeds/search`) で検索を実行した後、ローディングスピナーが永久に回り続ける問題が発生していた。

### 根本原因

Meilisearch は `offset/limit` ページネーションモードにおいて、正確な件数ではなく `estimatedTotalHits`（推定値）を返す。この値はデフォルト上限の **1000** でキャップされている。

Backend の `ExecuteWithPagination` における `hasMore` 判定:

```go
hasMore := offset + len(feedItems) < totalCount
```

`totalCount`（= `estimatedTotalHits`）が常に 1000 を返すため、実際の検索結果が数十件しかなくても `hasMore` が常に `true` となり、フロントエンドが際限なく次ページをリクエストし続けていた。

参考: [Meilisearch Pagination Docs](https://www.meilisearch.com/docs/guides/front_end/pagination) — `offset/limit` モードは `estimatedTotalHits`（非正確な推定値）を返す。`page/hitsPerPage` モードのみ `totalHits`（正確な値）を返す。

### 影響範囲

- `/desktop/feeds/search` — デスクトップ検索ページ
- `/(app)/feeds/search` — レスポンシブ検索ページ

## DECISION MAKING

### 2層防御アプローチ

`estimatedTotalHits` を完全に無視し、Backend + Frontend の2つのレイヤーで確実にページネーションを停止する設計を採用した。

#### Layer 1: Backend — hasMore 判定の修正

`estimatedTotalHits` に依存せず、2つの決定論的な条件で `hasMore` を判定する:

1. **返却件数チェック**: `len(feedItems) >= limit` — 返却件数が要求件数未満なら結果が尽きている
2. **上限キャップ**: `offset + len(feedItems) < maxSearchResults(200)` — 検索結果に確定的な上限を設ける

#### Layer 2: Frontend — 防御的チェック

Backend の修正だけでなく、フロントエンド側にも安全弁を追加:

1. **MAX_SEARCH_RESULTS チェック**: `feeds.length >= 200` で API 呼び出し前にページネーションを停止
2. **空結果ガード**: API が空配列を返した場合にページネーションを停止

### TDD アプローチ

TDD ワークフローに従い、RED → GREEN の順序で実装:

1. 先に失敗するテストを追加（`estimatedTotalHits=1000` のシナリオを再現）
2. テストが FAIL することを確認（RED）
3. `hasMore` ロジックを修正し、全テスト PASS を確認（GREEN）

### maxSearchResults = 200 の根拠

- 検索はキーワードに対する関連度順の結果であり、200 件目以降の精度は実用的でない
- Meilisearch の `offset/limit` モードで確実に動作する安全な範囲
- `estimatedTotalHits` の 1000 キャップとは独立した、アプリケーション側の上限

## RESULTS

### 変更ファイル

| ファイル | 変更内容 |
|---------|---------|
| `alt-backend/app/usecase/search_feed_usecase/search_feed_meilisearch_usecase.go` | `hasMore` 判定を `len >= limit && offset+len < 200` に変更 |
| `alt-backend/app/usecase/search_feed_usecase/search_feed_meilisearch_usecase_test.go` | TDD テスト 4 件追加 |
| `alt-frontend-sv/src/routes/desktop/feeds/search/+page.svelte` | `MAX_SEARCH_RESULTS` + 空結果ガード追加 |
| `alt-frontend-sv/src/routes/(app)/feeds/search/+page.svelte` | 同上 |
| `alt-frontend-sv/src/routes/desktop/feeds/search/page.search.spec.ts` | テスト 2 件追加 |

### Backend の変更

```go
// Before (estimatedTotalHits に依存 — 常に 1000 が返るため hasMore が常に true)
hasMore := offset+len(feedItems) < totalCount

// After (estimatedTotalHits を無視、決定論的な判定)
const maxSearchResults = 200
hasMore := len(feedItems) >= limit && offset+len(feedItems) < maxSearchResults
```

### Frontend の変更

```typescript
const MAX_SEARCH_RESULTS = 200;

async function loadMore() {
    if (isFetchingNextPage || !hasNextPage) return;
    // Layer 2: フロントエンド側の上限チェック
    if (feeds.length >= MAX_SEARCH_RESULTS) {
        hasNextPage = false;
        return;
    }
    // ...
    // Layer 2: 空結果の防御
    if (result.data.length === 0) {
        hasNextPage = false;
        return;
    }
    // ...
}
```

### テスト追加

**Backend (4 件)**:
- `hasMore true when full page returned and under max cap` — offset=0, 20件返却, total=1000 → true
- `hasMore false when partial page returned even if estimatedTotalHits is large` — 15件返却, total=1000 → false
- `hasMore false when empty results returned` — 0件, total=1000 → false
- `hasMore false when offset plus results exceeds max search cap` — offset=180, 20件, total=1000 → false

**Frontend (2 件)**:
- `stops pagination when feeds exceed MAX_SEARCH_RESULTS` — 200件到達で API 未呼出
- `stops pagination when API returns empty results with has_more true` — 空結果で停止

### 検証結果

| 検証項目 | 結果 |
|---------|------|
| Backend テスト (`go test ./usecase/search_feed_usecase/`) | 全件 PASS (11 pagination tests) |
| Frontend テスト (`bun test page.search`) | 19/19 PASS |
| `alt-backend` コンテナ再ビルド・起動 | 正常 (`healthy`) |
| `alt-frontend-sv` コンテナ再ビルド・起動 | 正常 (`healthy`) |

## PROS

1. **バグ修正**: `estimatedTotalHits=1000` による無限スクロールが解消
2. **2層防御**: Backend + Frontend の両方でガードしており、片方に不具合があっても安全
3. **estimatedTotalHits 非依存**: Meilisearch の不正確な推定値に一切依存しない設計
4. **テスト充実**: バグの再現シナリオ（total=1000）をテストで明示的にカバー
5. **既存テスト互換**: 既存の 7 件のテストは修正なしで全て PASS

## CONS, TRADEOFF

1. **検索結果の上限**: 最大 200 件に制限されるため、それ以上の結果が存在してもユーザーには表示されない。検索は関連度順であり 200 件以降の精度は実用的でないため許容範囲
2. **totalCount の未使用**: `SearchFeedsWithPagination` の戻り値の `totalCount` を `hasMore` 判定に使用しなくなったが、ログ出力には引き続き含めている（デバッグ用途）

## APPENDIX

### Meilisearch のページネーションモードの違い

| モード | パラメータ | 返却値 | 正確性 |
|--------|-----------|--------|--------|
| offset/limit | `offset`, `limit` | `estimatedTotalHits` | 推定値（上限キャップあり） |
| page/hitsPerPage | `page`, `hitsPerPage` | `totalHits`, `totalPages` | 正確 |

本システムは `offset/limit` モードを使用しているため、`estimatedTotalHits` は信頼できない。`page/hitsPerPage` モードへの移行は将来の選択肢だが、Backend/Gateway/Frontend の全レイヤーに変更が必要なため、今回は `hasMore` 判定の修正で対処した。

### 修正前の障害フロー

```
検索実行
    ↓
Meilisearch: estimatedTotalHits=1000, 20件返却
    ↓
Backend: hasMore = (0+20 < 1000) = true
    ↓
Frontend: スクロール → 次ページリクエスト
    ↓
... 繰り返し (offset=980 まで50回リクエスト) ...
    ↓
Svelte: 配列が巨大化 → RangeError: Invalid array length
```

### 修正後のフロー

```
検索実行
    ↓
Meilisearch: estimatedTotalHits=1000, 20件返却
    ↓
Backend: hasMore = (20>=20 && 0+20<200) = true
    ↓
... 正常にページネーション進行 ...
    ↓
offset=180: hasMore = (20>=20 && 180+20<200) = false  ← 停止
    ↓
Frontend: hasNextPage=false → スピナー停止、「No more results」表示
```
