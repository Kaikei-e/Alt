# ADR-000222: Desktop検索 Infinite Scroll を `bind:this` + `$effect` パターンに移行

## STATUS

Accepted（実装完了・テスト通過・コンテナ再ビルド/再起動確認済み）

## CONTEXT

ADR-000219〜221 で Desktop `/sv/feeds/search` の infinite scroll スピナー永続表示バグに段階的に対処してきた。しかし、`use:infiniteScroll` Svelte action を使用したアーキテクチャの構造的問題が根本原因として残っていた。

### 構造的問題

1. **条件付き sentinel rendering**: `{#if hasMore}<div use:infiniteScroll>` により sentinel div が DOM から destroy/recreate されるたびに IntersectionObserver のライフサイクルが崩壊する
2. **action 内の unobserve → rAF → re-observe サイクル**: コールバック実行後に observer を再セットアップする過程で、タイミングによっては失敗しうる
3. **`disabled` toggle による observer 再作成**: `isLoadingMore` の変化が action の `update()` を発火し、observer の不要な disconnect → recreate を誘発する

### 既存の安定パターン

同プロジェクト内の **Viewed ページ** (`viewed/+page.svelte`) および **FeedGrid** (`FeedGrid.svelte`) は `bind:this` + `$effect` + `IntersectionObserver` パターンを使用しており、これらのページではスピナー問題は発生していなかった。

## DECISION MAKING

`use:infiniteScroll` action を検索ページから削除し、Viewed ページと同じ `bind:this` + `$effect` パターンに統一する。

### 変更方針

- trigger div を常に DOM 内に配置し、条件付き rendering を排除
- `$effect` の return で observer を自動 cleanup（手動の unobserve/re-observe サイクル不要）
- guard 条件（`hasNextPage && !isFetchingNextPage`）はコールバック内でチェック。observer 自体は触らない
- 変数名を Viewed ページと統一（`isLoadingMore` → `isFetchingNextPage`、`hasMore` → `hasNextPage`）

### `infinite-scroll.ts` action は維持

モバイル版の4コンポーネントが引き続き使用しているため、action 自体は削除しない。

## RESULTS

### 変更ファイル

| ファイル | 変更内容 |
|---------|---------|
| `alt-frontend-sv/src/routes/desktop/feeds/search/+page.svelte` | `use:infiniteScroll` → `bind:this` + `$effect` パターンに移行、変数リネーム、template 下部を単一 trigger div に置換 |
| `alt-frontend-sv/src/routes/desktop/feeds/search/page.search.spec.ts` | `SearchPageState` クラスの変数リネーム、`loadMore()` エラー時の `hasNextPage = false` 追加 |

### 変更しないファイル

| ファイル | 理由 |
|---------|------|
| `alt-frontend-sv/src/lib/actions/infinite-scroll.ts` | モバイル4コンポーネントが使用中 |
| `alt-frontend-sv/src/lib/actions/infinite-scroll.test.ts` | 7テストそのまま維持 |
| `alt-frontend-sv/src/lib/api/client/feeds.ts` | API クライアント変更不要 |

### 主な変更点

**`$effect` による IntersectionObserver 管理**

```typescript
$effect(() => {
    if (!loadMoreTrigger || isLoading) return;
    const observer = new IntersectionObserver(
        (entries) => {
            const [entry] = entries;
            if (entry.isIntersecting && hasNextPage && !isFetchingNextPage) {
                loadMore();
            }
        },
        { threshold: 0.5 },
    );
    observer.observe(loadMoreTrigger);
    return () => { observer.disconnect(); };
});
```

**常時 DOM に存在する trigger div**

```svelte
<div bind:this={loadMoreTrigger} class="py-8 text-center">
    {#if isFetchingNextPage}
        <Loader2 class="..." />
    {:else if hasNextPage}
        <p>Scroll for more</p>
    {:else}
        <p>No more results</p>
    {/if}
</div>
```

### テスト結果

| 実行コマンド | 結果 |
|---|---|
| `bun test src/routes/desktop/feeds/search/page.search.spec.ts` | 17 pass, 0 fail |
| `npx svelte-check --tsconfig ./tsconfig.json` | 0 errors, 0 warnings |
| `biome lint` (対象2ファイル) | 0 errors |

### コンテナ検証

| 検証 | 結果 |
|---|---|
| `docker compose build alt-frontend-sv` | 成功 |
| `docker compose up -d alt-frontend-sv` | 成功 |
| `curl http://localhost:3000/api/health` | `{"status":"ok"}` |

## PROS

1. trigger div が常に DOM 内にあるため、observer のライフサイクルが安定する。条件付き rendering による destroy/recreate サイクルが排除された
2. `$effect` の return による自動 cleanup で、手動の unobserve → rAF → re-observe が不要になった
3. Viewed ページ・FeedGrid と同一パターンに統一され、コードベース全体の一貫性が向上した
4. ADR-000219〜221 で段階的に追加されたクールダウン・disabled toggle 等の対症療法が不要になり、コードが簡潔になった

## CONS, TRADEOFF

1. `use:infiniteScroll` action がデスクトップ検索ページでは未使用になったが、モバイル版で引き続き使用しているため action 自体は残存する。将来的にモバイル版も同パターンに移行する場合は action の削除を検討する
2. trigger div が検索結果がない状態でも DOM 内に存在するが、`{:else}` ブロック内にあるため結果表示時のみ描画される

## APPENDIX

- 前提: ADR-000219（クールダウン追加・検索クライアント改善）、ADR-000220（レイテンシ改善）、ADR-000221（observer 再作成コスト削減）
- 本 ADR は上記3件の対症療法的修正を、構造的な解決策で置き換えるもの
- 参照実装: `alt-frontend-sv/src/routes/desktop/feeds/viewed/+page.svelte` L67-85
