# Desktop Feed Modal 状態管理レースコンディション修正

## ADR's STATUS

Accepted

## CONTEXT

### 背景

`/sv/desktop/feeds` のフィード詳細モーダルで、フィードを連続して既読にすると、遅延ロードされた古い記事が表示される問題が発生していた。

### 現象

1. モーダルで「Mark as Read」をクリック
2. 次のフィードが表示される
3. 素早く連続でクリックすると、意図しない（古い）フィードが突然表示される

### 根本原因

3つの問題が複合していた:

| 問題 | 箇所 | 詳細 |
|------|------|------|
| 混合責務 | `FeedGrid.svelte` | `removeFeedByUrl` が即時更新と非同期フェッチを混合 |
| 不要な再生成 | `FeedGrid.svelte` | `$effect` で `visibleFeeds` 変更ごとに `onReady` が呼ばれる |
| インデックス依存 | `+page.svelte` | `feeds[currentIndex]` が配列変更後にずれる |

#### 問題のコード例

```typescript
// Before: インデックスベースで不安定
await feedGridApi?.removeFeedByUrl(feedUrl);  // 非同期
await tick();
selectedFeed = feeds[currentIndex];  // ← 配列が変わりインデックスがずれる可能性
```

### 検討した選択肢

| 選択肢 | 説明 | 採用 |
|--------|------|------|
| A. ミューテックス追加 | async 処理中は操作をブロック | 不採用: 根本解決にならない |
| B. インデックス再計算 | 削除後にインデックスを調整 | 不採用: 複雑で壊れやすい |
| C. URL ベーストラッキング | URL で状態を追跡し、$derived で解決 | **採用** |

## DECISION MAKING

### 方針

**URL-based トラッキング + 関心の分離 + 処理中フラグ**

1. **同期的なナビゲーション情報取得**: `removeFeedByUrl` を同期関数に変更し、次のフィード URL を即座に返す
2. **URL ベースの状態管理**: `selectedFeedUrl` を使い、`selectedFeed` は `$derived` で解決
3. **責務分離**: 置換フィードのフェッチを別関数 `fetchReplacementFeed` として分離

### 新しい API 設計

```typescript
export type FeedGridApi = {
  // 同期: 即座にナビゲーション情報を返す
  removeFeedByUrl: (url: string) => { nextFeedUrl: string | null; totalCount: number };
  getVisibleFeeds: () => RenderFeed[];
  getFeedByUrl: (url: string) => RenderFeed | null;
  // 非同期: fire-and-forget
  fetchReplacementFeed: () => void;
};
```

### 修正後のフロー

```typescript
// After: URL ベースで安定
const { nextFeedUrl, totalCount } = feedGridApi.removeFeedByUrl(feedUrl);  // 同期
selectedFeedUrl = nextFeedUrl;  // URL ベースなので配列変更に影響されない
feedGridApi.fetchReplacementFeed();  // バックグラウンドで実行
```

## RESULTS, EFFECTS

### 変更ファイル一覧

#### alt-frontend-sv

| ファイル | 変更内容 |
|----------|----------|
| `src/lib/components/desktop/feeds/FeedGrid.svelte` | API 分離、`$effect` 修正 |
| `src/routes/desktop/feeds/+page.svelte` | URL ベーストラッキング、処理中フラグ |
| `src/lib/components/desktop/feeds/FeedDetailModal.svelte` | `disableMarkAsRead` prop 追加 |

### 主要な変更点

#### 1. FeedGrid.svelte - 同期的な removeFeedByUrl

```typescript
function removeFeedByUrl(url: string): RemoveFeedResult {
  const currentIndex = visibleFeeds.findIndex((f) => f.normalizedUrl === url);
  removedUrls = new Set(removedUrls).add(url);  // 同期更新

  const newVisibleFeeds = feeds.filter((f) => !removedUrls.has(f.normalizedUrl));
  // 次のフィード URL を計算して返す
  return { nextFeedUrl: newVisibleFeeds[currentIndex]?.normalizedUrl ?? null, totalCount };
}
```

#### 2. +page.svelte - URL ベースの状態管理

```typescript
let selectedFeedUrl = $state<string | null>(null);

const selectedFeed = $derived.by(() => {
  if (!selectedFeedUrl || !feedGridApi) return null;
  return feedGridApi.getFeedByUrl(selectedFeedUrl);  // URL で検索
});
```

#### 3. onReady の一度だけ呼び出し

```typescript
let onReadyCalled = false;

$effect(() => {
  if (onReadyCalled || isLoading) return;
  onReadyCalled = true;
  onReady?.({ removeFeedByUrl, getVisibleFeeds, getFeedByUrl, fetchReplacementFeed });
});
```

### テスト

TDD で先にテストを作成 (RED -> GREEN)。

| テストファイル | テスト数 | 検証内容 |
|----------------|----------|----------|
| `FeedGrid.logic.spec.ts` | 12 | ナビゲーションロジック、URL 検索 |
| `page.logic.spec.ts` | 9 | 状態管理、連続操作、処理中フラグ |

### PROS

1. **レースコンディション解消**: 同期的にナビゲーション情報を取得するため、配列変更のタイミングに依存しない
2. **安定した参照**: URL ベースの参照は配列の順序変更に影響されない
3. **連続操作対応**: 処理中フラグにより重複クリックを防止
4. **責務分離**: 即時更新と非同期フェッチが明確に分離

### CONS, TRADEOFF

1. **API 変更**: `FeedGridApi` の型が変更され、呼び出し側の修正が必要
2. **$derived の計算コスト**: `selectedFeed` が配列検索を行う（ただし O(n) で実用上問題なし）

## APPENDIX

### 検証方法

```bash
# ユニットテスト
cd alt-frontend-sv
bun run test:server -- FeedGrid.logic.spec.ts page.logic.spec.ts

# TypeScript チェック
bun run check

# コンテナ再ビルド・再起動
docker compose -f compose/compose.yaml -p alt build alt-frontend-sv
docker compose -f compose/compose.yaml -p alt up -d alt-frontend-sv
```

### 手動検証手順

1. `/sv/desktop/feeds` を開く
2. フィードカードをクリックしてモーダルを開く
3. 「Mark as Read」を連続で素早くクリック
4. 正しい「次の」フィードが表示されることを確認
5. 古い（遅延ロードされた）フィードが突然表示されないことを確認

### 参考資料

- [SvelteKit State Management](https://svelte.dev/docs/kit/state-management)
- [Optimistic Update Race Conditions](https://dejan.vasic.com.au/blog/2025/11/solving-optimistic-update-race-conditions-in-sveltekit)
