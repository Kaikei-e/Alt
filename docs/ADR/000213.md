# ADR-000213: ユーザーIDごとのフィード購読フィルタリング

## STATUS

Accepted（実装完了・コンテナ再ビルド・マイグレーション適用・ヘルスチェック確認済み）

## CONTEXT

### 背景

全ユーザーが `feeds` テーブル全体を閲覧する設計だった。ユーザーごとに購読する RSS ソースを選択し、購読中ソースのフィードのみ表示されるようにしたい。

### 課題

1. **ソース追跡の欠如**: `feeds` テーブルに、どの RSS ソース (`feed_links`) 由来かを示す外部キーがなかった
2. **購読関係の不在**: ユーザーと RSS ソースの購読関係を管理するテーブルが存在しなかった
3. **フィルタの未実装**: フィード取得クエリにユーザー購読フィルタが組み込まれていなかった

### 前提

- `feed_links(id, url)` テーブルが RSS ソース URL として既に存在
- `settings/feeds` ページに feed link 管理 UI（追加/削除）が既存
- Clean Architecture (Handler → Usecase → Port → Gateway → Driver) に従う

## DECISION MAKING

### 方針

1. `feeds` テーブルに `feed_link_id` (FK → `feed_links.id`) を追加し、フィードとソースを紐付ける
2. `user_feed_subscriptions` テーブルを新設し、ユーザーごとの購読関係を管理する
3. 4 つのフィード取得クエリ（未読/全件/既読/お気に入り）に購読フィルタを追加する
4. 既存の `settings/feeds` ページに購読トグルスイッチを統合する

### 購読フィルタ設計

`feed_link_id IS NULL` の既存フィードへのフォールバックを含めた条件式:

```sql
AND (f.feed_link_id IN (
    SELECT feed_link_id FROM user_feed_subscriptions WHERE user_id = $N
) OR f.feed_link_id IS NULL)
```

### feed_link_id の伝播設計

フィード登録時に `feed_link_id` を自動設定するため、`RegisterFeedsUsecase` に `FeedLinkIDResolver` インターフェースを導入。URL から `feed_links.id` を引き、UPSERT 時に `COALESCE(feeds.feed_link_id, EXCLUDED.feed_link_id)` で既存値を保持する。

## RESULTS

### DB マイグレーション (2 files)

| ファイル | 内容 |
|---------|------|
| `20260211000001_add_feed_link_id_to_feeds.sql` | `feeds.feed_link_id` カラム追加、FK 制約、複合インデックス |
| `20260211000002_create_user_feed_subscriptions.sql` | `user_feed_subscriptions` テーブル（複合 PK: `user_id`, `feed_link_id`） |

### Proto 定義 (1 file)

| ファイル | 変更内容 |
|---------|---------|
| `proto/alt/feeds/v2/feeds.proto` | `FeedSource` メッセージ、`ListSubscriptions` / `Subscribe` / `Unsubscribe` RPC 追加 |

### Backend (Clean Architecture 全レイヤー)

| レイヤー | ファイル | 変更内容 |
|---------|---------|---------|
| Domain | `domain/subscription.go` (新規) | `FeedSource` struct |
| Domain | `domain/rss_feed.go` | `FeedItem` に `FeedLinkID *string` 追加 |
| Port | `port/subscription_port/subscription_port.go` (新規) | `SubscriptionPort` インターフェース |
| Driver | `driver/alt_db/subscription_driver.go` (新規) | `FetchSubscriptions` / `InsertSubscription` / `DeleteSubscription` |
| Driver | `driver/alt_db/feed_link_driver.go` | `FetchFeedLinkIDByURL` 追加 |
| Driver | `driver/alt_db/fetch_feed_driver.go` | 4 メソッドに購読フィルタ追加 |
| Driver | `driver/alt_db/register_feeds_driver.go` | UPSERT に `feed_link_id` 追加 |
| Driver | `driver/models/feed.go` | `FeedLinkID *string` フィールド追加 |
| Gateway | `gateway/subscription_gateway/` (新規) | `SubscriptionPort` 実装 |
| Gateway | `gateway/register_feed_gateway/feeds_gateway.go` | `FeedLinkID` パススルー |
| Usecase | `usecase/subscription_usecase/` (新規) | `ListSubscriptions` / `Subscribe` / `Unsubscribe` |
| Usecase | `usecase/register_feed_usecase/feeds_usecase.go` | `FeedLinkIDResolver` インターフェース |
| Handler | `connect/v2/feeds/handler.go` | 3 RPC ハンドラ追加 |
| DI | `di/container.go` | 全コンポーネント配線 |

### Frontend (3 files)

| ファイル | 変更内容 |
|---------|---------|
| `src/lib/connect/feeds.ts` | `listSubscriptions` / `subscribe` / `unsubscribe` 関数追加 |
| `src/lib/api/client/feeds.ts` | クライアントサイドラッパー関数追加 |
| `src/routes/(app)/settings/feeds/+page.svelte` | 購読トグルスイッチ（デスクトップ + モバイル） |

### 自動生成ファイル (buf-generate)

| ファイル | 生成元 |
|---------|--------|
| `alt-backend/app/gen/proto/alt/feeds/v2/feeds.pb.go` | proto |
| `alt-backend/app/gen/proto/alt/feeds/v2/feedsv2connect/feeds.connect.go` | proto |
| `alt-frontend-sv/src/lib/gen/alt/feeds/v2/feeds_pb.ts` | proto |
| `alt-butterfly-facade/internal/gen/proto/alt/feeds/v2/feeds.pb.go` | proto |
| `rag-orchestrator/internal/gen/proto/alt/feeds/v2/feeds.pb.go` | proto |

## VERIFICATION

### 自動検証

| 検証 | 結果 |
|------|------|
| `go build ./...` (alt-backend) | 成功 |
| `go test ./...` (alt-backend) | 全テスト PASS (0 failures) |
| `svelte-check --tsconfig ./tsconfig.json` | 0 errors, 0 warnings |

### コンテナ検証

| 検証 | 結果 |
|------|------|
| `docker compose build alt-backend alt-frontend-sv alt-butterfly-facade` | 成功 |
| Atlas マイグレーション (2 migrations, 7 SQL statements) | 成功 (330ms) |
| Backend ヘルスチェック (`/v1/health`) | `{"database":"connected","status":"healthy"}` |
| Frontend ヘルスチェック (`/api/health`) | `{"status":"ok"}` |
| `ListSubscriptions` エンドポイント (backend 直接) | CSRF エラー返却 (ルーティング成功) |

## PROS

1. **Clean Architecture 準拠**: 全レイヤーを通した一貫した実装。Port インターフェースによるテスト容易性
2. **後方互換性**: `feed_link_id IS NULL` フォールバックにより、既存フィードは購読フィルタ適用前と同様に表示される
3. **既存 UI への統合**: 新規ページ不要。既存の `settings/feeds` に購読トグルを自然に追加
4. **UPSERT 安全性**: `COALESCE(feeds.feed_link_id, EXCLUDED.feed_link_id)` により、既存の `feed_link_id` 値を上書きしない

## CONS, TRADEOFF

1. **バックフィル未自動化**: 既存 `feeds` レコードの `feed_link_id` 設定と、初回ユーザーの購読データ投入はワンショットの手動 SQL が必要
2. **単一ユーザー前提**: `user_feed_subscriptions` テーブルはマルチユーザー対応だが、現時点では単一ユーザーを想定した運用
3. **購読フィルタのパフォーマンス**: サブクエリによるフィルタリングはインデックス (`idx_ufs_user_id`) で緩和されるが、大量データ時の影響は要モニタリング

## APPENDIX

### バックフィルSQL（手動実行）

```sql
-- 1) 現ユーザーを全 feed_links に購読
INSERT INTO user_feed_subscriptions (user_id, feed_link_id)
SELECT '<USER_UUID>', id FROM feed_links
ON CONFLICT DO NOTHING;

-- 2) feeds.feed_link_id バックフィル
UPDATE feeds f
SET feed_link_id = fl.id
FROM inoreader_articles ia
JOIN inoreader_subscriptions isub ON ia.subscription_id = isub.id
JOIN feed_links fl ON fl.url = isub.feed_url
WHERE f.link = ia.article_url
AND f.feed_link_id IS NULL;
```
