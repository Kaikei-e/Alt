# Tag Trail CJK テキスト対応とフィード解決ロジック改善

## ADR's STATUS

Accepted

## CONTEXT

ADR-167〜171で実装したTag Trail機能において、日本語記事のタグ生成に2つの問題が発生していた。

### 問題1: 日本語テキストがサニタイゼーションでブロックされる

`InputSanitizer._has_unusual_character_frequency()` が日本語の句読点（「」、。・など）を「特殊文字」としてカウントし、テキスト全体の30%を超えるとコンテンツをブロックしていた。

日本語テキストの特性:
- 句読点（、。）が頻出
- かぎ括弧（「」『』）が引用に多用
- 全角記号（【】・）が見出しに使用

これらは正常なコンテンツであり、ブロック対象ではない。

### 問題2: feed_id解決ロジックの不具合

`ArticleProcessor.get_feed_id_from_url()` が記事URLとフィードURLを直接マッチングしていたが、記事URL（例: `https://example.com/articles/123`）はフィードURL（例: `https://example.com/feed.xml`）と異なる。

このミスマッチにより、feed_idが解決できず、タグ生成がスキップされていた。

## DECISION MAKING

### 解決策1: CJKテキスト検出とスキップ

CJK（中国語・日本語・韓国語）テキストを検出し、特殊文字チェックをスキップする。

**Unicode範囲による検出**:
| 範囲 | 説明 |
|-----|------|
| U+4E00 - U+9FFF | CJK Unified Ideographs（漢字） |
| U+3040 - U+309F | Hiragana（ひらがな） |
| U+30A0 - U+30FF | Katakana（カタカナ） |
| U+AC00 - U+D7AF | Korean Hangul（ハングル） |
| U+3000 - U+303F | CJK Punctuation（句読点） |

テキストの10%以上がCJK文字の場合、CJKテキストとして扱い、特殊文字チェックをバイパスする。

### 解決策2: ドメインベースのフィード解決

記事URLからドメインを抽出し、フィードURLのドメインとマッチングする。

```
記事URL: https://example.com/articles/123
         ↓ urlparse().netloc
ドメイン: example.com
         ↓ LIKE '%example.com%'
フィード: https://example.com/feed.xml (マッチ)
```

## RESULTS, EFFECTS

### 実装ファイル

| レイヤー | ファイル | 変更内容 |
|---------|---------|---------|
| Sanitizer | `tag-generator/app/tag_extractor/input_sanitizer.py` | `_is_cjk_text()` メソッド追加、CJKスキップ処理 |
| Processor | `tag-generator/app/tag_generator/article_processor.py` | ドメインベースのfeed_id解決 |
| Tests | `tag-generator/app/tests/unit/test_input_sanitizer_cjk.py` | CJKテスト追加（9テスト） |

### CJKテキスト検出実装

```python
def _is_cjk_text(self, text: str) -> bool:
    """Check if text contains significant CJK characters."""
    if not text:
        return False
    cjk_count = sum(
        1 for c in text
        if "\u4e00" <= c <= "\u9fff"  # CJK Unified Ideographs
        or "\u3040" <= c <= "\u309f"  # Hiragana
        or "\u30a0" <= c <= "\u30ff"  # Katakana
        or "\uac00" <= c <= "\ud7af"  # Korean Hangul
        or "\u3000" <= c <= "\u303f"  # CJK Punctuation
    )
    return cjk_count > len(text) * 0.1
```

### フィード解決実装

```python
def get_feed_id_from_url(self, conn, article_url: str) -> str | None:
    parsed = urlparse(article_url)
    domain = parsed.netloc
    if not domain:
        return None

    cursor.execute(
        "SELECT id::text FROM feeds WHERE link LIKE %s LIMIT 1",
        (f"%{domain}%",),
    )
```

### テストカバレッジ

新規テスト（9件）:
- `test_japanese_text_not_blocked`: 日本語記事がブロックされない
- `test_japanese_with_punctuation`: 句読点多用テキストが通過
- `test_japanese_with_many_quotes`: かぎ括弧多用テキストが通過
- `test_chinese_text_not_blocked`: 中国語テキストが通過
- `test_korean_text_not_blocked`: 韓国語テキストが通過
- `test_english_text_still_checked`: 英語テキストは引き続きチェック
- `test_mixed_cjk_and_english`: 混合テキストが通過
- `test_cjk_detection_threshold`: 10%閾値の検証
- `test_is_cjk_text_method`: `_is_cjk_text`メソッド単体テスト

### PROS

1. **多言語対応**: 日本語・中国語・韓国語コンテンツが正しく処理される
2. **後方互換性**: 英語コンテンツの検証は従来通り維持
3. **堅牢なフィード解決**: ドメインベースマッチングで柔軟に対応
4. **テスト充実**: 9件の専用テストでリグレッション防止

### CONS, TRADEOFF

1. **ドメインマッチングの曖昧性**: 同一ドメインに複数フィードがある場合、最新のフィードが選択される
2. **CJK閾値の固定**: 10%閾値は経験的な値であり、エッジケースでは調整が必要な可能性

## APPENDIX

### Unicode HOWTO

- [Python Unicode HOWTO](https://docs.python.org/3/howto/unicode.html)
- [Detecting Chinese/Japanese Characters](https://stackoverflow.com/questions/34587346/python-check-if-a-string-contains-chinese-character)

### 関連ADR

- ADR-167: Tag Trail基本設計
- ADR-168: オンザフライタグ生成
- ADR-169: タグ名による横断検索
- ADR-170: Tag Trail connect-rpc移行
- ADR-171: リアルタイムタグ反映 (Server Streaming)

### 検証コマンド

```bash
# テスト実行
cd tag-generator/app && uv run pytest tests/unit/test_input_sanitizer_cjk.py -v

# 全サニタイザーテスト
cd tag-generator/app && uv run pytest tests/unit/test_input_sanitizer*.py -v

# コンテナ再ビルド
docker compose -f compose/compose.yaml -p alt up -d --build tag-generator
```
