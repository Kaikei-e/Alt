# Tag Trail リアルタイムタグ反映 (Server Streaming)

## ADR's STATUS

Accepted

## CONTEXT

ADR-167〜170で実装したTag Trail機能において、記事タグの取得は同期的なRequest-Replyパターンで実装されていた。タグがDBに存在しない場合、mq-hub経由でタグ生成を行い、最大30秒待機してから応答を返す設計だった。

### 課題

1. **UXの問題**: タグ生成中、ユーザーは何も表示されない状態で待たされる
2. **タイムアウトリスク**: 長時間のHTTP接続は不安定になりやすい
3. **進捗表示なし**: 生成中なのかエラーなのか判別できない

### 解決策の検討

| オプション | 説明 | 採用 |
|-----------|------|------|
| Connect-RPC Server Streaming | 型安全なストリーミング、HTTP/1.1対応 | ✅ |
| SSE (Server-Sent Events) | シンプルだがConnect-RPCとの統合が弱い | |
| ポーリング | バックエンド変更不要だがUXが劣る | |
| WebSocket | 双方向通信だが新規インフラ必要 | |

## DECISION MAKING

### Connect-RPC Server Streaming採用

既存のConnect-RPCインフラを活用し、`StreamArticleTags` RPCを追加する。

### Proto設計

```protobuf
service ArticleService {
  // 既存RPCs...

  // タグストリーミング
  rpc StreamArticleTags(StreamArticleTagsRequest) returns (stream ArticleTagEvent);
}

message StreamArticleTagsRequest {
  string article_id = 1;
  optional string title = 2;      // オンザフライ生成用
  optional string content = 3;    // オンザフライ生成用
  optional string feed_id = 4;    // オンザフライ生成用
}

message ArticleTagEvent {
  string article_id = 1;
  repeated ArticleTagItem tags = 2;
  EventType event_type = 3;
  optional string message = 4;

  enum EventType {
    EVENT_TYPE_UNSPECIFIED = 0;
    EVENT_TYPE_CACHED = 1;        // DBから取得（即時完了）
    EVENT_TYPE_GENERATING = 2;    // 生成中（ハートビート）
    EVENT_TYPE_COMPLETED = 3;     // 生成完了
    EVENT_TYPE_ERROR = 4;         // エラー
  }
}
```

### イベントフロー

```
┌──────────────────────────────────────────────────────────────────┐
│ Case 1: キャッシュヒット (タグがDBに存在)                           │
├──────────────────────────────────────────────────────────────────┤
│ Client ───StreamArticleTagsRequest───▶ Server                    │
│        ◀───EVENT_TYPE_CACHED + tags────                          │
│ (ストリーム終了)                                                   │
└──────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────┐
│ Case 2: オンザフライ生成                                          │
├──────────────────────────────────────────────────────────────────┤
│ Client ───StreamArticleTagsRequest───▶ Server                    │
│        ◀───EVENT_TYPE_GENERATING───── (生成開始通知)              │
│        ◀───EVENT_TYPE_GENERATING───── (5秒ハートビート)           │
│        ◀───EVENT_TYPE_GENERATING───── (5秒ハートビート)           │
│        ◀───EVENT_TYPE_COMPLETED + tags─ (生成完了)                │
│ (ストリーム終了)                                                   │
└──────────────────────────────────────────────────────────────────┘
```

## RESULTS, EFFECTS

### 実装ファイル

| レイヤー | ファイル | 変更内容 |
|---------|---------|---------|
| Proto | `proto/alt/articles/v2/articles.proto` | `StreamArticleTags` RPC追加 |
| Backend Handler | `alt-backend/app/connect/v2/articles/handler.go` | ストリーミングハンドラ実装 |
| Backend Tests | `alt-backend/app/connect/v2/articles/handler_test.go` | 単体テスト追加 |
| Frontend Client | `alt-frontend-sv/src/lib/connect/articles.ts` | `streamArticleTags` 関数追加 |
| Frontend Export | `alt-frontend-sv/src/lib/connect/index.ts` | エクスポート追加 |
| UI Component | `alt-frontend-sv/src/lib/components/mobile/tag-trail/TagTrailScreen.svelte` | ストリーミング統合 |

### バックエンド実装パターン

既存の`StreamFeedStats`パターンを踏襲:

```go
func (h *Handler) StreamArticleTags(
    ctx context.Context,
    req *connect.Request[articlesv2.StreamArticleTagsRequest],
    stream *connect.ServerStream[articlesv2.ArticleTagEvent],
) error {
    // 1. 認証チェック
    // 2. 入力バリデーション
    // 3. DB検索 → キャッシュヒットなら EVENT_TYPE_CACHED で即時返却
    // 4. キャッシュミス → EVENT_TYPE_COMPLETED で空タグ返却
    //    (将来的にオンザフライ生成をストリーミング対応予定)
}
```

### フロントエンド実装パターン

AbortController対応のストリーミング関数:

```typescript
export function streamArticleTags(
  transport: Transport,
  articleId: string,
  onEvent: (event: StreamingArticleTagEvent) => void,
  onError?: (error: Error) => void,
): AbortController {
  const client = createArticleClient(transport);
  const abortController = new AbortController();

  (async () => {
    try {
      const stream = client.streamArticleTags(
        { articleId },
        { signal: abortController.signal },
      );
      for await (const event of stream) {
        onEvent(mapEvent(event));
      }
    } catch (error) {
      if (!abortController.signal.aborted && onError) {
        onError(error);
      }
    }
  })();

  return abortController;
}
```

### Svelteコンポーネント統合

```svelte
<script lang="ts">
  import { onDestroy } from 'svelte';
  import { streamArticleTags } from '$lib/connect';

  let activeControllers = new Map<string, AbortController>();

  function loadArticleTags(articleId: string) {
    const controller = streamArticleTags(
      transport,
      articleId,
      (event) => {
        if (event.eventType === 'cached' || event.eventType === 'completed') {
          updateCache(articleId, event.tags);
        }
      },
    );
    activeControllers.set(articleId, controller);
  }

  onDestroy(() => {
    for (const controller of activeControllers.values()) {
      controller.abort();
    }
  });
</script>
```

### PROS

1. **リアルタイムフィードバック**: 生成中状態をUIに即座に反映可能
2. **型安全**: Proto定義から生成された型を使用
3. **HTTP/1.1互換**: ブラウザ制限なくServer Streamingが動作
4. **既存パターン踏襲**: `StreamFeedStats`, `streamSummarize`と同じ実装パターン
5. **適切なクリーンアップ**: AbortControllerによるストリーム中断対応

### CONS, TRADEOFF

1. **初期実装は簡略版**: オンザフライ生成のストリーミング待機は将来実装
2. **接続管理の複雑化**: アクティブなストリームをコンポーネントで追跡する必要
3. **エラーハンドリング**: ストリーム途中のエラーはコールバックで処理

## APPENDIX

### 参考資料

- [Connect-RPC Streaming Documentation](https://connectrpc.com/docs/go/streaming/)
- [Connect-Web: Protobuf and gRPC in the browser](https://buf.build/blog/connect-web-protobuf-grpc-in-the-browser)

### 関連ADR

- ADR-167: Tag Trail基本設計
- ADR-168: オンザフライタグ生成
- ADR-169: タグ名による横断検索
- ADR-170: Tag Trail connect-rpc移行

### 今後の拡張

1. **オンザフライ生成のストリーミング対応**: mq-hub応答をストリームで返却
2. **ハートビート実装**: 5秒間隔でEVENT_TYPE_GENERATINGを送信
3. **バッチストリーミング**: 複数記事のタグを一度にストリーム取得
