# pre-processor: context canceled エラーの防御的修正

## ADR's STATUS

Accepted

## CONTEXT

### 背景

pre-processor で `context canceled` エラーが複数記事で同一秒に発生するログが継続的に観測されていた。

```
09:09:05 ERROR context canceled
09:09:05 ERROR context canceled
09:09:05 ERROR context canceled
```

### ADR 146 との関係

ADR 146 は `Client.Timeout exceeded while awaiting headers` (タイムアウト問題) を修正した。本 ADR が扱う `context canceled` は別のエラーであり、ADR 146 では解決されていない。

| エラー | Go の型 | 原因 |
|--------|---------|------|
| `Client.Timeout exceeded` | `context.DeadlineExceeded` | タイムアウト到達 (ADR 146 で修正済み) |
| `context canceled` | `context.Canceled` | `cancel()` の明示的呼び出し |

### 根本原因の分析

コンテキスト伝播チェーンを分析した結果:

```
context.Background()
  -> context.WithCancel()        (jobHandler の生成時)
    -> SummarizeArticles()       (バッチ処理ループ)
      -> SummarizeArticle()      (記事ごとの処理)
        -> context.WithTimeout() (HTTP リクエスト)
```

`cancel()` が呼ばれるのは `jobHandler.Stop()` (SIGTERM ハンドラ) のみ。コンテナが再起動すると SIGTERM が送信され、処理中のコンテキストがキャンセルされる。

**同一秒に複数エラーが出るメカニズム:**

1. SIGTERM 受信 -> `cancel()` 呼び出し
2. 処理中の HTTP リクエストが `context canceled` で即座に失敗
3. for ループが継続 -> 次の記事も即座に失敗 (コンテキスト既にキャンセル済み)
4. 残り全記事が同一秒内に連鎖的に失敗 -> 大量のエラーログ

### 追加で発見した問題

`runSummarizationLoop` に `recover()` がなく、パニック発生時にプロセス全体がクラッシュする。他のループ関数 (`runQualityCheckLoop`, `runArticleSyncLoop`) には `recover()` が存在しており、一貫性が欠けていた。

## DECISION MAKING

### 方針

コンテキストキャンセル時の無駄な処理とエラーログの連鎖を防ぐ防御的プログラミングを導入する。

### 修正内容

| # | 修正 | 目的 |
|---|------|------|
| 1 | `runSummarizationLoop` に `recover()` を追加 | パニック時のプロセスクラッシュ防止 |
| 2 | `SummarizeArticles` の for ループに `ctx.Err()` チェックを追加 | キャンセル時の連鎖的エラー防止 |
| 3 | `ProcessQueue` の for ループに `ctx.Err()` チェックを追加 | キャンセル時の連鎖的エラー防止 |

### TDD テスト

各修正に対してテストを先に書いた (RED -> GREEN)。

| テストファイル | 検証内容 |
|----------------|----------|
| `handler/job_handler_test.go` | `processSummarizationBatch` のパニック伝播の確認、`runSummarizationLoop` の安全な終了 |
| `service/article_summarizer_test.go` | コンテキストキャンセル時にバッチ途中で処理を停止すること |
| `service/summarize_queue_worker_test.go` | コンテキストキャンセル時に残りジョブをスキップすること |

## RESULTS, EFFECTS

### 変更ファイル一覧

| ファイル | 変更内容 |
|----------|----------|
| `handler/job_handler.go` | `runSummarizationLoop` に `defer recover()` を追加 |
| `service/article_summarizer.go` | for ループ先頭に `ctx.Err()` チェックと `break` を追加 |
| `service/summarize_queue_worker.go` | for ループ先頭に `ctx.Err()` チェックと `break` を追加 |
| `handler/job_handler_test.go` | 新規: recover とパニックの検証テスト |
| `service/article_summarizer_test.go` | 追加: コンテキストキャンセル時の早期リターンテスト |
| `service/summarize_queue_worker_test.go` | 新規: コンテキストキャンセル時の早期リターンテスト |

### 修正パターン (共通)

```go
for _, item := range items {
    if ctx.Err() != nil {
        logger.WarnContext(ctx, "context canceled, skipping remaining items",
            "remaining", ...,
            "reason", ctx.Err())
        break
    }
    // ... process item
}
```

### PROS

1. **エラーログの大幅削減**: キャンセル後の連鎖的エラー (N-1 件) が Warn 1 件に集約される
2. **不要な処理の排除**: キャンセル済みコンテキストで HTTP リクエストを発行しなくなる
3. **パニック耐性**: `runSummarizationLoop` のパニックがプロセスクラッシュを引き起こさなくなる
4. **既存パターンとの一貫性**: `runQualityCheckLoop`、`runArticleSyncLoop` と同じ `recover()` パターンに統一

### CONS, TRADEOFF

1. **バッチ処理の中断**: コンテキストキャンセル時にバッチの残りがスキップされる。ただし、キャンセルされたコンテキストで処理を続けても全て失敗するため、実質的なデメリットはない
2. **recover() による暗黙の回復**: パニックがログに記録されるのみで、ループ自体は停止する。自動再開は行わない (コンテナの `restart: always` ポリシーが再起動を担当)

## APPENDIX

### 検証方法

```bash
# テスト実行
cd pre-processor/app && go test ./...

# コンテナ再ビルド・再起動
docker compose -f compose/compose.yaml -p alt build pre-processor
docker compose -f compose/compose.yaml -p alt up -d pre-processor

# ログ監視 (修正前: context canceled の大量出力 -> 修正後: skipping remaining の Warn 1 件)
docker compose -f compose/compose.yaml -p alt logs pre-processor -f \
  | grep -E "context canceled|panic|skipping remaining"
```

### `context.Canceled` vs `context.DeadlineExceeded`

| | `context.Canceled` | `context.DeadlineExceeded` |
|---|---|---|
| トリガー | `cancel()` の明示的呼び出し | タイムアウト到達 |
| 典型的な原因 | SIGTERM、親コンテキストのキャンセル | HTTP/context タイムアウト |
| 本修正の対象 | **対象** | 対象外 (ADR 146 で対応済み) |
