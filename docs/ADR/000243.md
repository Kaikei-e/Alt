# ADR-000243: Streaming Semaphore Leak 修正 (Defense-in-Depth)

## STATUS

Accepted

## CONTEXT

### 問題

LLM ストリーミング要約処理が完全に停止する障害が発生。ストリーミングリクエストがキューに入るが処理されず、タイムアウトで purge される状態が継続した。

### 根本原因

ADR-142 で導入した Eager Semaphore Acquisition パターンにおいて、async generator の `finally` ブロックが信頼できないケースが存在した。

ストリーミングパスの処理フロー:

```
1. セマフォ取得 (Eager Acquisition)
2. async generator を返す
3. クライアントが generator を消費
4. finally でセマフォ解放 ← クライアント切断時に実行されない場合がある
```

Python の async generator 仕様 (PEP 525) では、`aclose()` が呼ばれない限り `finally` ブロックの実行は保証されない。FastAPI の `StreamingResponse` がクライアント切断時に generator を適切にクローズしない場合、セマフォスロットが永久にリークする。

`OLLAMA_NUM_PARALLEL=2`, `RT_RESERVED_SLOTS=1` の構成では、1スロットのリークでRT処理が完全に停止する。

### 関連 ADR

| ADR | 内容 | 関連 |
|-----|------|------|
| 140 | Hybrid RT/BE Priority Semaphore 導入 | RT/BEスロット分離設計 |
| 142 | Eager Semaphore Acquisition | streaming前にセマフォ取得 (リーク箇所) |
| 145 | 8K + OLLAMA_NUM_PARALLEL=2 | 並行処理構成 |

## DECISION MAKING

### アプローチ: 多層防御 (Defense in Depth)

単一の修正箇所に依存するのではなく、Handler / Usecase / Gateway / Semaphore の各レイヤーで独立した防御を実装する。いずれか1つのレイヤーが失敗しても、他のレイヤーがセマフォリリースを保証する。

```
Layer 1: Handler  (aclosing)        ... 確実に aclose() を呼ぶ
Layer 2: Usecase  (try/finally)     ... inner generator を確実にクローズ
Layer 3: Gateway  (GeneratorExit)   ... セマフォリリース + ログ
Layer 4: Semaphore (leak detection) ... 安全網として長時間占有を検知
```

### 代替案と却下理由

| 選択肢 | 却下理由 |
|--------|---------|
| Gateway の finally のみ修正 | PEP 525 により finally 実行が保証されない。単一レイヤーの修正では不十分 |
| `cancel_on_disconnect` task group パターン | `aclosing()` + `try/finally` の多層防御がよりシンプルで確実 |
| セマフォに TTL (自動リリース) を追加 | 正常な長時間推論を誤って中断するリスクがある。検知のみに留める |

### 調査リソース

- PEP 525 - Asynchronous Generators: `aclose()` なしでは `finally` 実行が保証されない仕様
- `contextlib.aclosing()`: 例外発生時でも確実に `aclose()` を呼ぶ標準ライブラリ
- FastAPI の `StreamingResponse`: クライアント切断時に generator を適切にクローズしない既知の問題

## RESULTS, EFFECTS

### Layer 1: Handler (`summarize_handler.py`)

`stream_task()` 内で `original_stream` を `contextlib.aclosing()` でラップ。タスクキャンセル時 (クライアント切断) も確実に generator がクローズされる。

```python
from contextlib import aclosing

async def stream_task():
    try:
        async with aclosing(original_stream) as stream:
            async for chunk in stream:
                ...
    except Exception as e:
        logger.error(...)
    finally:
        stopped.set()
        await data_queue.put(None)
```

### Layer 2: Usecase (`summarize_usecase.py`)

`generate_summary_stream()` 内で `stream_gen` (gateway から返される async generator) を `try/finally` でラップし、`finally` で明示的に `aclose()` を呼ぶ。

`aclosing()` ではなく `try/finally` を使用する理由: この関数自身が `yield` する async generator であるため、`async with aclosing()` の中で `yield` すると `aclosing` のスコープが不定になる。

```python
stream_gen = await self.llm_provider.generate(prompt, stream=True, ...)
try:
    async for chunk in stream_gen:
        yield chunk.response
finally:
    await stream_gen.aclose()
```

### Layer 3: Gateway (`ollama_gateway.py`)

`response_generator()` に以下を追加:

1. **`except GeneratorExit`**: クライアント切断を明示的にキャッチしてログ出力 (再 raise)
2. **`except Exception`**: 予期しないエラーのログ出力
3. **セマフォリリースログを `DEBUG` → `INFO` に昇格**: 本番環境でのスロットライフサイクル監視に不可欠

```python
async def response_generator():
    try:
        async for chunk in stream_iterator:
            yield LLMGenerateResponse(...)
    except GeneratorExit:
        logger.info("Stream generator closed by client disconnect or explicit aclose()")
        raise
    except Exception:
        logger.error("Stream generator error", exc_info=True)
        raise
    finally:
        self._semaphore.release(was_high_priority=is_high_priority)
        logger.info("Released semaphore after streaming", ...)
```

### Layer 4: Semaphore (`hybrid_priority_semaphore.py`)

既に実装済みの安全網:

- `AcquiredSlot` dataclass でスロット取得時刻を追跡
- `_track_acquire()` / `_track_release()` で自動追跡
- `check_leaks()` メソッドで長時間占有スロットを検知 (5分閾値)
- `queue_status()` に `acquired_slots` 数を含む

### 変更ファイル一覧

| ファイル | 変更内容 |
|----------|----------|
| `news-creator/app/news_creator/handler/summarize_handler.py` | `aclosing()` で stream_task 内の generator をラップ |
| `news-creator/app/news_creator/usecase/summarize_usecase.py` | inner generator の `try/finally` + `aclose()` |
| `news-creator/app/news_creator/gateway/ollama_gateway.py` | `GeneratorExit` handling、リリースログ INFO 昇格 |

### 検証結果

| 検証項目 | 結果 |
|---------|------|
| `uv run pytest` (gateway, usecase, handler, semaphore) | 80 tests passed |
| コンテナ再ビルド・起動 | healthy |
| ヘルスチェック (`/health`) | 200 OK |

### PROS

1. **多層防御**: いずれか1つのレイヤーが失敗しても、他のレイヤーがセマフォリリースを保証
2. **可観測性の向上**: `GeneratorExit` ログとリリースログの INFO 昇格により、本番でのリーク発生を即座に検知可能
3. **PEP 525 準拠**: `aclosing()` + 明示的 `aclose()` により、async generator の仕様に正しく対応
4. **非破壊的**: 既存の Eager Acquisition パターン (ADR-142) の設計を変更せず、クリーンアップのみ強化
5. **安全網**: セマフォのリーク検知により、万が一の新たなリークパスも検出可能

### CONS, TRADEOFF

1. **ログ量の増加**: セマフォリリースを INFO に昇格したため、ストリーミングリクエスト毎に1行追加。可観測性とのトレードオフ
2. **冗長な防御**: 正常系では Layer 1 の `aclosing()` だけで十分。Layer 2-4 は異常系のためのコストだが、リーク障害の深刻さを考慮すると妥当

## APPENDIX

### Async Generator クリーンアップの仕様 (PEP 525)

```
正常完了:   generator exhausted → finally 実行される
aclose():   明示的クローズ     → GeneratorExit → finally 実行される
GC:         ガーベジコレクション → CPython では finally 実行されるが保証なし
未消費放置: aclose() なし       → finally 実行されない可能性がある ← 今回の問題
```

### 修正前後のスロットライフサイクル

```
修正前:
  acquire → return generator → [client disconnect] → (finally 未実行) → SLOT LEAKED

修正後:
  acquire → return generator → [client disconnect]
    → Layer 1: aclosing() が aclose() を呼ぶ
    → Layer 2: usecase finally が aclose() を呼ぶ
    → Layer 3: gateway GeneratorExit → finally でセマフォ release
    → Layer 4: check_leaks() で検知 (安全網)
```
