# デスクトップ検索ページ 無限スクロール実装

## ADR's STATUS

Accepted (実装完了・コンテナ起動確認済み)

## CONTEXT

### 問題点

デスクトップ検索ページ (`/sv/desktop/feeds/search`) は `searchFeedsClient(query, undefined, 50)` で1回だけ50件をロードして表示していた。検索結果が50件を超える場合、ユーザーは残りの結果にアクセスできなかった。

一方、モバイル版検索 (`SearchResults.svelte`) は既に `IntersectionObserver` ベースの無限スクロールを20件バッチで実装済みであり、デスクトップ版との機能差が存在していた。

### 既存インフラ

バックエンドの search-indexer (Connect-RPC) は既に `offset`/`limit` ページネーションに対応しており、レスポンスに `next_cursor` と `has_more` を含む。フロントエンドの `searchFeedsClient()` もこれに対応済みだった。また、`infiniteScroll` action (`$lib/actions/infinite-scroll.ts`) が既に存在し、モバイル版で実績があった。

## DECISION MAKING

### 方針

既存インフラを最大限再利用し、モバイル版と同等の無限スクロールをデスクトップ検索に適用する。

- `infiniteScroll` action を再利用 (IntersectionObserver ベース、rootMargin 200px の先読み)
- `searchFeedsClient()` の offset/limit パラメータを活用
- バッチサイズを50件から20件に変更 (Meilisearch のベストプラクティスに準拠)

### 修正内容

#### 1. ページネーション状態の追加

```typescript
// Pagination state
let cursor = $state<number | null>(null);
let hasMore = $state(false);
let isLoadingMore = $state(false);
```

#### 2. 初回検索のバッチサイズ変更 (50 → 20)

```typescript
// Before
const result = await searchFeedsClient(searchQuery.trim(), undefined, 50);

// After
const result = await searchFeedsClient(searchQuery.trim(), undefined, 20);
cursor = result.next_cursor ?? null;
hasMore = result.has_more ?? false;
```

#### 3. loadMore 関数の追加

モバイル版 `SearchResults.svelte` のパターンを参考に、cursor ベースでの追加ロード関数を実装。`isLoadingMore` ガードによる二重実行防止付き。

#### 4. 無限スクロールセンチネルの追加

結果グリッドの下部に `use:infiniteScroll` ディレクティブを付与したセンチネル要素を配置。ビューポートに近づくと自動的に `loadMore` が呼ばれる。

#### 5. モーダルナビゲーションの拡張

`handleNext()` を拡張し、最後のカードに到達した場合に `loadMore` を呼び出して次のバッチをロードしてからナビゲーションを継続するようにした。`hasNext` の判定も `hasMore` を考慮するよう変更。

## RESULTS, EFFECTS

### 変更ファイル一覧

| ファイル | 変更内容 |
|---------|---------|
| `alt-frontend-sv/src/routes/desktop/feeds/search/+page.svelte` | 無限スクロール対応 (ページネーション状態、loadMore、センチネル要素、モーダルナビ拡張) |
| `alt-frontend-sv/src/routes/desktop/feeds/search/page.search.spec.ts` | 新規テストファイル (17テスト) |

### 検証結果

| 検証項目 | 結果 |
|---------|------|
| `bun test` (関連テスト 3ファイル) | PASS (38テスト) |
| `bun run check` (svelte-check) | 0 errors, 0 warnings |
| `bun run lint` | 新規 warning なし |
| コンテナビルド | 成功 |
| コンテナ起動 | healthy (ヘルスチェック 200) |

### テストカバレッジ

`page.search.spec.ts` で以下のケースを検証:

- 初回検索が20件バッチで API を呼ぶこと
- レスポンスの `next_cursor` / `has_more` が状態に反映されること
- `loadMore` が cursor を使って次のバッチを取得すること
- 結果がフィード配列に追記されること
- `isLoadingMore` ガードによる二重ロード防止
- `hasMore=false` 時にロードしないこと
- API エラー時に既存フィードが保持されること
- 検索クエリ変更時に cursor/hasMore がリセットされること
- モーダルの handleNext が最後のフィードで loadMore を呼ぶこと

### PROS

- **50件制限の撤廃**: ユーザーがスクロールで全検索結果にアクセス可能になった
- **モバイル版との機能パリティ**: デスクトップ・モバイル両方で同等の無限スクロール体験
- **既存インフラの再利用**: `infiniteScroll` action と `searchFeedsClient` をそのまま活用し、新規コード量を最小化
- **モーダルナビゲーション連携**: モーダル内の「次へ」操作で自動的に追加ロードが行われ、シームレスなブラウジングが可能

### CONS, TRADEOFF

- **バッチサイズの縮小 (50 → 20)**: 初回表示件数が減少するが、UX 上は無限スクロールによりシームレスに追加ロードされるため影響は軽微
- **Meilisearch offset 上限**: offset ベースのページネーションには Meilisearch の上限 (1000件) が存在するが、通常の検索ユースケースでは十分

## APPENDIX

### 無限スクロール構成

```
+page.svelte
├── handleSearch()      ... 初回検索 (20件バッチ、状態リセット)
├── loadMore()          ... 追加ロード (cursor ベース、ガード付き)
├── handleNext()        ... モーダルナビ (最後尾で loadMore 呼び出し)
├── Grid                ... フィードカード表示
├── Loading indicator   ... Loader2 + "Loading more..."
├── "No more results"   ... hasMore=false 時
└── Sentinel div        ... use:infiniteScroll (IntersectionObserver)
```

### 再利用した既存リソース

| リソース | パス | 役割 |
|---------|------|------|
| `infiniteScroll` action | `$lib/actions/infinite-scroll.ts` | IntersectionObserver ベースの自動ロードトリガー |
| `searchFeedsClient()` | `$lib/api/client/feeds.ts` | offset/limit 対応済み検索 API クライアント |
| `FeedSearchResult` 型 | `$lib/schema/search.ts` | `next_cursor`, `has_more` 対応済みレスポンス型 |
| モバイル版 `SearchResults.svelte` | `$lib/components/mobile/search/SearchResults.svelte` | 実装パターンの参考 |
