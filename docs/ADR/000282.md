# ADR-000282: alt-backend SQL 総点検 — 正確性バグ修正・パフォーマンス改善・インデックス最適化

## ステータス

承認済み

## コンテキスト

alt-backend の PostgreSQL SQL を3つの専門家視点（SQL 正確性・パフォーマンス・スキーマ設計）で網羅的に分析した。70 以上のドライバファイル、18 テーブル、71 マイグレーションを調査し、Critical 2件、High 7件、Medium 10件の問題を特定した。

主な問題カテゴリ:

1. **正確性バグ**: Outbox パターンのロック不備、フィード登録のレースコンディション
2. **データ漏洩**: soft-delete (`deleted_at`) フィルタの適用漏れ、マルチテナントフィルタの欠落
3. **パフォーマンス劣化**: TEXT カラムの GROUP BY、URL 文字列ベースの相関サブクエリ、N+1 クエリパターン
4. **冗長性**: 不要なテーブル JOIN、冗長な DISTINCT、重複インデックス

## 意思決定

### Phase 1: Critical (P0) — 正確性バグ修正

#### 1-1. Outbox の FOR UPDATE SKIP LOCKED をトランザクション内に移動

`FetchPendingOutboxEvents` は `r.pool.Query()` で直接実行されていたため、autocommit モードで `FOR UPDATE SKIP LOCKED` のロックが即座に解放され、複数ワーカーが同一イベントを重複処理する可能性があった。

**修正**: `FetchAndLockPendingOutboxEvents` に名称変更し、トランザクション内で SELECT + ステータス更新を一括実行するようにした。

```
BEGIN
  SELECT ... FOR UPDATE SKIP LOCKED  -- ロック取得
  UPDATE ... SET status = 'PROCESSING'  -- 同一 tx 内でステータス更新
COMMIT  -- ここでロック解放
```

処理完了後の `PROCESSED` 更新は別トランザクションで OK（べき等）。

#### 1-2. RegisterSingleFeed の TOCTOU レース解消

`SELECT → INSERT/UPDATE` パターンを `ON CONFLICT (link) DO UPDATE` に置換。同一ファイルの `RegisterMultipleFeeds` が既に正しいパターンを使用していたため、それに合わせた。トランザクションが不要になり、コードも簡素化された。

### Phase 2: High (P1) — パフォーマンス・データ整合

#### 2-1. GROUP BY から TEXT カラム (content) を除去

PostgreSQL 9.1+ では PK による関数従属性が認識されるため、`GROUP BY a.id` のみで十分。content は数十 KB の TEXT で、ハッシュテーブルが肥大化していた。

対象: `fetch_articles_cursor_driver.go`, `fetch_recent_articles_driver.go`, `internal_articles_driver.go`, `fetch_articles_by_ids_driver.go` の全クエリ（計 9 箇所）。

#### 2-2. URL 文字列ベースの相関サブクエリを FK ベースに変更

```sql
-- Before: per-row URL 文字列比較
(SELECT a.id FROM articles a WHERE a.url = f.link LIMIT 1) AS article_id

-- After: FK (feed_id) ベースの高速ルックアップ
(SELECT a.id FROM articles a WHERE a.feed_id = f.id AND a.deleted_at IS NULL
 ORDER BY a.created_at DESC LIMIT 1) AS article_id
```

対象: `fetch_feed_driver.go` の 6 箇所。

#### 2-3. soft-delete フィルタ (`deleted_at IS NULL`) の追加

以下のクエリに `AND a.deleted_at IS NULL` を追加し、論理削除済み記事が返却されないようにした:

- `FetchArticleByURL`, `FetchArticleByID`
- `FetchArticlesWithCursor`
- `FetchRecentArticles` (RAG オーケストレーターに削除済み記事が投入されていた)
- `FetchArticlesByIDs`
- `FetchRecapArticles`
- `FetchTotalArticlesCount`

#### 2-4. FetchTrendStats の feed_activity CTE にユーザーフィルタ追加

articles CTE は `user_id = $2` でフィルタされていたが、feeds CTE にはフィルタがなく、他ユーザーのフィード活動が混入していた。`user_feed_subscriptions` による絞り込みを追加。

### Phase 3: Medium (P2) — 最適化

#### 3-1. N+1 タグ Upsert のバッチ化

`UpsertArticleTags` / `BatchUpsertArticleTags` で、タグごとに 2 回のラウンドトリップ（feed_tags UPSERT + article_tags INSERT）が発生していた。

CTE で 2 クエリを 1 クエリに統合し、さらに `pgx.Batch` で全タグを 1 回のラウンドトリップにまとめた。

```sql
WITH ft AS (
    INSERT INTO feed_tags (...) VALUES (...) ON CONFLICT DO UPDATE ... RETURNING id
)
INSERT INTO article_tags (article_id, feed_tag_id)
SELECT $4::uuid, ft.id FROM ft
ON CONFLICT DO NOTHING
```

#### 3-2. FetchFeedTags の不要な 3 テーブル JOIN 除去

`feed_tags` テーブルに直接 `feed_id` カラムがあるにもかかわらず、`article_tags → articles` を経由して JOIN していた。直接 `WHERE t.feed_id = $1` に変更。

#### 3-3. MarkArticleAsRead の単一クエリ化

SELECT（フィード検索）+ BEGIN + UPSERT + COMMIT の 4 ステップを、`INSERT ... SELECT ... ON CONFLICT` の 1 クエリに統合。トランザクションが不要になった。

#### 3-4. FetchUserFeedIDs の冗長 DISTINCT 除去

`(feed_id, user_id)` に UNIQUE 制約があるため、`user_id` フィルタ時に DISTINCT は不要。

#### 3-5. FetchFeedsList に安全上限 LIMIT 追加

無制限の SELECT を防止するため `LIMIT 10000` を追加。

### Phase 4: インデックス最適化

#### 追加したインデックス (4 件)

| インデックス名 | 定義 | 用途 |
|---------------|------|------|
| `idx_articles_url_not_deleted` | `articles (url) WHERE deleted_at IS NULL` | soft-delete 対応の URL 検索 |
| `idx_articles_active_user_created` | `articles (user_id, created_at DESC, id DESC) WHERE deleted_at IS NULL` | カーソルページネーション |
| `idx_read_status_user_read_at_desc` | `read_status (user_id, read_at DESC) WHERE is_read = TRUE` | 既読フィード一覧のカーソルページネーション |
| `idx_read_status_user_feed` | `read_status (user_id, feed_id)` | ユーザーフィード ID の index-only scan |

#### 削除した冗長インデックス (5 件 + 1 制約)

| インデックス名 | 削除理由 |
|---------------|---------|
| `idx_feeds_created_at` | `idx_feeds_created_at_link` の左プレフィックスと重複 |
| `idx_read_status_is_read` | boolean の低選択性、部分インデックスや複合インデックスでカバー済み |
| `idx_read_status_feed_id` | `(feed_id, user_id)` UNIQUE 制約 + `(feed_id, is_read)` 複合インデックスでカバー済み |
| `idx_user_reading_status_user_article` | UNIQUE 制約の暗黙インデックスと重複 |
| `idx_user_reading_status_user_id` | 同上 |
| `idx_feed_links_id_url` (UNIQUE 制約) | PK on `id` + UNIQUE on `url` と重複 |

### 不採用・延期

| 項目 | 理由 |
|------|------|
| カーソルページネーションの `(created_at, id)` 複合カーソル化 | Handler → Usecase → Port → Gateway → Driver の全レイヤー変更が必要。API 互換性の問題あり、別 PR で対応 |
| `COUNT(*) OVER()` の分離 (recapArticlesQuery) | ページネーションモデルの変更が必要。`deleted_at IS NULL` フィルタの追加で当面の正確性は確保 |
| `CREATE INDEX CONCURRENTLY` の使用 | Atlas マイグレーションがトランザクション内で実行されるため使用不可。通常の `CREATE INDEX` で適用 |

## 結果・影響

### 動作確認

| 確認項目 | 結果 |
|---------|------|
| `go test ./...` (alt-backend 全テスト) | 全パス |
| `go test -count=1 ./driver/alt_db/...` (ドライバテスト, キャッシュなし) | 全パス (53 テスト) |
| `go test -count=1 ./job/...` (ジョブテスト) | 全パス |
| `go test -count=1 ./gateway/... ./usecase/...` | 全パス |
| マイグレーション適用 (10 SQL statements) | 成功 |
| コンテナ再ビルド + 起動 | healthy |
| Backend health check (`/v1/health`) | `{"database":"connected","status":"healthy"}` |
| 新インデックス作成確認 (4 件) | 全て存在 |
| 冗長インデックス削除確認 (5 件 + 1 制約) | 全て削除済み |

### PROS

- Outbox ワーカーの重複処理リスクを排除（本番でのイベント二重配信を防止）
- soft-delete フィルタの網羅的適用により、削除済み記事の漏洩を防止（RAG、Recap、記事一覧全てに適用）
- `GROUP BY a.id` への統一で、数十 KB の TEXT カラムをハッシュテーブルに載せていた非効率を解消
- URL 文字列比較の相関サブクエリを FK ベースに変更し、Seq Scan → Index Scan の改善が期待される
- N+1 タグ Upsert のバッチ化で、タグ数 N に対するラウンドトリップを 2N → 1 に削減
- 6 つの冗長インデックスの削除により、書き込み性能の改善とストレージ削減

### CONS, TRADEOFF

- `CREATE INDEX CONCURRENTLY` が使えなかったため、本番適用時はマイグレーション中のテーブルロックに注意が必要（データ量が少なければ問題なし）
- カーソルページネーションの同一タイムスタンプ問題は未解決（別 PR で対応予定）
- `FetchFeedsList` に `LIMIT 10000` を追加したが、これはハードコードされた安全上限であり、将来的にはカーソルベースに移行すべき

## 付録

### 変更ファイル一覧

| ファイル | 変更内容 | 優先度 |
|---------|---------|--------|
| `app/driver/alt_db/save_outbox_event_driver.go` | FOR UPDATE SKIP LOCKED をトランザクション内に移動、PROCESSING ステータス更新 | P0 |
| `app/job/outbox_worker.go` | 新メソッド名に更新 | P0 |
| `app/driver/alt_db/register_feeds_driver.go` | ON CONFLICT パターンに置換 | P0 |
| `app/driver/alt_db/fetch_articles_cursor_driver.go` | GROUP BY a.id + deleted_at IS NULL | P1 |
| `app/driver/alt_db/fetch_recent_articles_driver.go` | GROUP BY a.id + deleted_at IS NULL | P1 |
| `app/driver/alt_db/internal_articles_driver.go` | GROUP BY a.id (5 箇所) | P1 |
| `app/driver/alt_db/fetch_articles_by_ids_driver.go` | GROUP BY a.id + deleted_at IS NULL | P1 |
| `app/driver/alt_db/fetch_article_driver.go` | deleted_at IS NULL (2 クエリ) | P1 |
| `app/driver/alt_db/recap_articles_driver.go` | deleted_at IS NULL | P1 |
| `app/driver/alt_db/fetch_total_articles_count_driver.go` | deleted_at IS NULL | P1 |
| `app/driver/alt_db/fetch_feed_driver.go` | URL JOIN → FK JOIN (6 箇所) + LIMIT 10000 | P1 |
| `app/driver/alt_db/fetch_trend_stats_driver.go` | feed_activity CTE にユーザーフィルタ追加 | P1 |
| `app/driver/alt_db/upsert_article_tags_driver.go` | CTE + pgx.Batch でバッチ化 | P2 |
| `app/driver/alt_db/fetch_feed_tags_driver.go` | 3 テーブル JOIN → 直接クエリ | P2 |
| `app/driver/alt_db/user_reading_status_driver.go` | 単一クエリ化（SELECT + tx → INSERT...SELECT） | P2 |
| `app/driver/alt_db/fetch_user_feed_ids_driver.go` | 冗長 DISTINCT 除去 | P2 |
| `migrations-atlas/migrations/20260227000000_optimize_indexes.sql` | インデックス 4 追加 / 5+1 削除 | P1-P2 |
