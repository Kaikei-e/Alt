# Recap Job ステータス不整合の修正

## ADR'S STATUS

Accepted

## CONTEXT

### 背景

Job Status Dashboard（ADR-109）で、一部のジョブが `status = 'pending'` かつ `last_stage = 'persist'` という矛盾した状態で表示される問題が報告された。

正常なフローでは:
- `pending` → ジョブ開始前、`last_stage` は NULL
- `running` → パイプライン実行中、`last_stage` は完了したステージ名
- `completed` → 全ステージ完了、`last_stage = 'persist'`

`pending` + `last_stage = 'persist'` は論理的に発生し得ない状態であり、データ不整合を示す。

### 問題の原因

調査の結果、以下の原因を特定:

1. **`update_job_status` が `rows_affected` をチェックしていない**
   - UPDATE文が0行に影響した場合でも `Ok(())` を返す
   - ジョブが存在しない/削除済みの場合、サイレントに失敗

2. **非アトミックな状態更新**
   - `save_state()` は2つの独立したDB操作を実行:
     1. `save_stage_state()` → `recap_stage_state` テーブル
     2. `update_job_status()` → `recap_jobs` テーブル
   - 1が成功し2が失敗した場合、不整合が発生

### 発生シナリオ

```
Timeline:
1. save_stage_state() 成功 → recap_stage_state に保存
2. (ジョブが何らかの理由で削除/変更)
3. update_job_status() → 0行更新、エラーなし
4. 結果: stage_state は存在するが job status は未更新
```

## DECISION MAKING

### 決定

1. **警告ログの追加**: `update_job_status` で `rows_affected == 0` の場合に警告を出力
2. **デバッグログの強化**: `save_state` の各DB操作前後にログ追加
3. **データ修復スクリプト**: 既存の不整合データを修復するマイグレーション追加

### 設計根拠

- **エラーではなく警告**: 既存の動作との互換性を維持しつつ、問題を可視化
- **トランザクション化は見送り**: 将来的な検討事項として残す（現時点では警告で十分）
- **修復ロジック**: `recap_outputs` の存在有無で `completed` / `failed` を判定

## RESULTS, EFFECTS

### 変更ファイル

| ファイル | 種別 | 内容 |
|----------|------|------|
| `recap-worker/recap-worker/src/store/dao/job.rs` | 変更 | `rows_affected` チェックと警告ログ追加 |
| `recap-worker/recap-worker/src/pipeline/executor.rs` | 変更 | `save_state` にデバッグログ追加 |
| `recap-worker/recap-worker/src/store/dao/mod.rs` | 変更 | テスト追加 |
| `recap-worker/recap-worker/src/store/dao/mock.rs` | 変更 | MockRecapDao にダッシュボード用メソッド追加 |
| `recap-migration-atlas/migrations/20260116100000_repair_stuck_pending_jobs.sql` | 新規 | データ修復マイグレーション |

### コード変更

**job.rs - `update_job_status`**:
```rust
let result = sqlx::query(...)
    .execute(pool)
    .await
    .context("failed to update job status")?;

if result.rows_affected() == 0 {
    tracing::warn!(
        %job_id,
        ?status,
        ?last_stage,
        "update_job_status affected 0 rows - job may not exist or was deleted"
    );
}
```

**executor.rs - `save_state`**:
```rust
tracing::debug!(%job_id, %stage, "saving stage state to recap_stage_state");
self.orchestrator.recap_dao().save_stage_state(...).await?;

tracing::debug!(%job_id, %stage, "updating job status in recap_jobs");
self.orchestrator.recap_dao().update_job_status(...).await?;

tracing::debug!(%job_id, %stage, "stage state saved and job status updated successfully");
```

### 修復マイグレーション

```sql
-- 出力があるジョブ → completed
UPDATE recap_jobs rj
SET status = 'completed', updated_at = NOW()
WHERE status = 'pending' AND last_stage = 'persist'
  AND EXISTS (SELECT 1 FROM recap_outputs WHERE job_id = rj.job_id);

-- 出力がないジョブ → failed
UPDATE recap_jobs
SET status = 'failed', updated_at = NOW()
WHERE status = 'pending' AND last_stage = 'persist'
  AND NOT EXISTS (SELECT 1 FROM recap_outputs WHERE job_id = recap_jobs.job_id);
```

### PROS

1. **問題の可視化**: 0行更新時に警告ログが出力され、運用監視で検知可能
2. **デバッグ容易性**: 各DB操作のログにより問題発生箇所を特定しやすい
3. **既存データ修復**: マイグレーションで不整合を解消

### CONS, TRADEOFF

1. **根本解決ではない**: トランザクション化すれば完全に防げるが、今回は見送り
2. **警告のみ**: エラーを返さないため、呼び出し元での対処は不要だが検知が遅れる可能性

## APPENDIX

### テスト

```bash
cargo test update_job_status --lib
```

```
running 2 tests
test store::dao::tests::update_job_status_updates_existing_job ... ok
test store::dao::tests::update_job_status_warns_on_nonexistent_job ... ok
test result: ok. 2 passed; 0 failed
```

### 関連ADR

- ADR-109: Recap Job Status Dashboard 実装
- ADR-112: Recap Job 手動トリガー機能

### 今後の検討事項

1. **トランザクション化**: `save_stage_state` と `update_job_status` を同一トランザクションで実行
2. **ヘルスチェック**: 不整合状態を定期検出するメトリクス追加
3. **自動修復**: 不整合検出時の自動リカバリ機構
