# ADR-000275: rag-orchestrator の goroutine リーク・CPU 浪費を Exponential Backoff で修正

## ステータス

承認済み

## コンテキスト

### 背景

`rag-orchestrator` のワーカーが異常な CPU 使用率（593%、14 日分の CPU TIME）を記録した。

### 根本原因

2 つの問題が組み合わさってタイトなリトライループを形成していた:

1. **Worker の無制限ポーリング**: `embedder-external` が到達不能な場合、ワーカーが 100ms 間隔でジョブを取得し続け、全て embed ステップで即座に失敗。失敗後もポーリング間隔が変わらないため、毎分約 600 回のリトライが発生。

2. **Handler のコンテキスト問題**: `UpsertIndex` ハンドラが caller の `ctx.Request().Context()` をそのまま下流に渡していた。caller が切断するとコンテキストが即キャンセルされ、呼び出し元が再リトライすることでさらにループが加速。また、`processNextJob` が timeout なしの `context.Background()` を使用しており、embedder がハングした場合にジョブが永遠にブロックされるリスクもあった。

## 意思決定

### 方針: Exponential Backoff + Context Timeout

pre-processor の `orchestrator/runner.go` で実績のある `ticker.Reset` パターンを採用し、連続失敗時にポーリング間隔を指数的に拡大する。加えて、全てのジョブ処理とハンドラリクエストに適切な timeout を設定する。

### 変更内容

#### 1. Worker — Exponential Backoff + Job Timeout (`worker.go`)

定数定義:

| 定数 | 値 | 用途 |
|-----|-----|------|
| `defaultPollInterval` | 100ms | 正常時のポーリング間隔 |
| `jobTimeout` | 60s | 1 ジョブあたりの処理タイムアウト |
| `initialBackoff` | 1s | 最初の失敗後の待機時間 |
| `maxBackoff` | 5min | backoff の上限 |

主な変更:
- `JobWorker` 構造体に `backoff` フィールドを追加
- `processNextJob()`: `context.Background()` → `context.WithTimeout(context.Background(), 60s)` に変更
- 処理失敗時: `backoff` を倍増（1s → 2s → 4s → ... → 5min cap）、`ticker.Reset(backoff)` でポーリング間隔を動的に拡大
- 処理成功時: `backoff` を 0 にリセット、`ticker.Reset(defaultPollInterval)` で通常間隔に復帰
- `nextBackoff()` メソッドを追加（倍増ロジック + 上限キャップ）

#### 2. Handler — Server-Side Timeout (`handler.go`)

`UpsertIndex` ハンドラで `context.WithTimeout(ctx.Request().Context(), 90s)` を設定。caller の切断とは独立した server-side deadline を設けることで、caller 切断 → 即リトライのループを防止。

### 不採用案

| 不採用案 | 理由 |
|---------|------|
| Circuit Breaker パターン | 実装が大きく、現時点では exponential backoff で十分。将来必要になれば追加可能 |
| 固定 sleep による待機 | ポーリング間隔が一律に遅くなり、復旧時のレスポンスが悪化 |
| embedder のヘルスチェックを事前に行う | ネットワークレベルの到達可能性と実際のリクエスト成功は異なる。失敗ベースの backoff の方が確実 |
| Worker の停止 + 手動再起動 | 運用負荷が高く、自動復旧できない |

## 結果・影響

### 期待効果

| 指標 | 修正前 | 修正後 |
|-----|-------|-------|
| Worker poll rate (embedder down) | ~600 回/分 | 最大 1 回/5 分 (max backoff 時) |
| CPU 使用率 | 593% | < 1% |
| `processNextJob` context | timeout なし | 60s timeout |
| `UpsertIndex` handler context | caller 依存 | 90s server-side timeout |

### 動作確認

| 確認項目 | 結果 |
|---------|------|
| Worker テスト (4 件) | 全 PASS |
| Handler テスト (1 件追加) | 全 PASS |
| 全体テスト (`go test ./...`) | 全 PASS |
| コンテナ再ビルド + 再起動 | 正常起動 |
| CPU 使用率 | < 1% |

### PROS

- 最小限の変更で CPU 浪費を根本解決
- `ticker.Reset` パターンは pre-processor で実績あり、コードベース内で一貫性がある
- embedder 復旧時は成功をトリガーに即座に通常間隔に復帰
- timeout により embedder ハング時のリソースリークも防止

### CONS, TRADEOFF

- max backoff（5 分）到達時、embedder が復旧しても最大 5 分の遅延が発生してからジョブ処理が再開される
- backoff 状態はインメモリのため、コンテナ再起動でリセットされる（意図的な設計: 再起動後は新鮮な状態で開始すべき）

## 付録

### 変更ファイル一覧

| ファイル | 変更 |
|---------|------|
| `rag-orchestrator/internal/worker/worker.go` | exponential backoff + context timeout 追加 |
| `rag-orchestrator/internal/worker/worker_test.go` | 新規作成: テスト 4 件 |
| `rag-orchestrator/internal/adapter/rag_http/handler.go` | `UpsertIndex` に server-side timeout 追加 |
| `rag-orchestrator/internal/adapter/rag_http/handler_test.go` | timeout 検証テスト 1 件追加 |

### 関連 ADR

| ADR | 内容 |
|-----|------|
| ADR-000275 (本 ADR) | rag-orchestrator の goroutine リーク・CPU 浪費修正 |
