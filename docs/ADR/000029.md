# Connect-RPC Server Streaming認証におけるUserContext完全性の確保

## ステータス

**採択・実装完了（Accepted & Implemented）** - 2025年12月30日

## コンテキスト

### 発生した問題

ADR-000028で実装したConnect-RPC v2のServer Streaming RPC（`FeedService.StreamFeedStats`）において、以下の認証エラーが発生した：

```
ConnectError: [unauthenticated] invalid user context
```

**症状：**
- ブラウザ: 3回のリトライ後に"Max retry attempts reached"
- バックエンド: 200 OKを返すが、ストリーム内でエラーが発生
- フロントエンド: Streaming接続が確立されるが、即座に切断される

### 根本原因の調査

ログとコード分析により、以下の根本原因を特定：

**`alt-backend/app/connect/v2/middleware/auth_interceptor.go`の問題:**

```go
// 問題のあったコード (Lines 165-170)
return &domain.UserContext{
    UserID:    userID,
    Email:     claims.Email,
    Role:      domain.UserRole(claims.Role),
    SessionID: claims.Sid,
    // ❌ TenantID, LoginAt, ExpiresAt が欠落
}
```

**`alt-backend/app/domain/user_context.go`のバリデーション:**

```go
func (uc *UserContext) IsValid() bool {
    return uc.UserID.String() != "00000000-0000-0000-0000-000000000000" &&
        uc.Email != "" &&
        uc.ExpiresAt.After(time.Now())  // ❌ ゼロ値のExpiresAtは常にfalse
}
```

**UserContextの必須フィールド:**
- `ExpiresAt`: JWTトークンの有効期限（`IsValid()`でチェックされる）
- `LoginAt`: ログイン時刻（監査ログ用）
- `TenantID`: テナントID（マルチテナント対応の基盤）

ゼロ値の`ExpiresAt`（`0001-01-01 00:00:00 UTC`）は常に`time.Now()`より前になるため、`IsValid()`が必ず`false`を返し、`domain.GetUserFromContext()`が"invalid user context"エラーを返していた。

### Connect-RPC Streaming特有の動作

Web検索（[Connect-RPC Streaming Docs](https://connectrpc.com/docs/go/streaming/)、[Connect-RPC Errors](https://connectrpc.com/docs/go/errors/)）により、以下の仕様を確認：

- **Server Streaming RPCは常に200 OKを返す**
  - エラーはHTTP trailerまたはレスポンスbodyの最後に含まれる
  - これにより、初期接続は成功するように見えるが、後続でエラーが発生する

この挙動により、認証エラーの発見が遅れた（200 OKが返るため、一見成功しているように見えた）。

## 意思決定

### 決定1: JWT RegisteredClaimsからタイムスタンプを取得

`BackendClaims`は`jwt.RegisteredClaims`を埋め込んでおり、標準JWTフィールド（`ExpiresAt`, `IssuedAt`）を持つ。

**実装方針:**
- `claims.ExpiresAt.Time`を`UserContext.ExpiresAt`に設定
- `claims.IssuedAt.Time`を`UserContext.LoginAt`に設定
- nil チェックを追加（JWTがオプションフィールドを含まない場合への対応）

**理由：**
- JWT標準フィールドを活用することで、トークン発行側（auth-token-manager）との整合性を保つ
- `jwt.NumericDate`型の`.Time`フィールドを使用することで、Go標準の`time.Time`に変換
- セキュリティ上、トークンの有効期限を必ず検証する必要がある

### 決定2: Single-tenant architectureにおけるTenantID設計

**採用方針: `TenantID = UserID`**

auth-hubの実装パターンを踏襲：

```go
// auth-hub/handler/validate.go のパターン
return &domain.UserContext{
    UserID:   userID,
    TenantID: userID,  // Single-tenant model
    // ...
}
```

**理由：**
- 現状のAltアーキテクチャはsingle-tenant（ユーザーごとに独立したデータ空間）
- 将来のmulti-tenant化の際も、マイグレーションパスが明確
- auth-hubとの設計一貫性を保つ（認証レイヤー全体で統一されたパターン）

**multi-tenant化の可能性:**
現在は検討していないが、将来的にテナント概念を導入する場合：
- JWTに`tenant_id` claimを追加
- auth-token-managerでテナント情報を発行
- `TenantID = UserID`から`TenantID = claims.TenantID`に変更

### 決定3: エラーハンドリングの強化

nil チェックを追加することで、JWTが一部フィールドを持たない場合への耐性を向上：

```go
var expiresAt, loginAt time.Time
if claims.ExpiresAt != nil {
    expiresAt = claims.ExpiresAt.Time
}
if claims.IssuedAt != nil {
    loginAt = claims.IssuedAt.Time
}
```

**理由：**
- JWTの`ExpiresAt`, `IssuedAt`はオプショナルフィールド（RFC 7519）
- auth-token-managerは現在これらを発行しているが、将来の変更に対する防御的プログラミング
- ゼロ値の`time.Time`でもプログラムはクラッシュせず、`IsValid()`で適切に検証される

## 結果と影響

### 修正内容

**ファイル:** `alt-backend/app/connect/v2/middleware/auth_interceptor.go`

```diff
import (
    "context"
    "errors"
    "fmt"
    "log/slog"
+   "time"

    "connectrpc.com/connect"
    "github.com/golang-jwt/jwt/v5"
    "github.com/google/uuid"

    "alt/config"
    "alt/domain"
)

func (a *AuthInterceptor) validateToken(tokenStr string) (*domain.UserContext, error) {
    // ... 省略: トークンパース、検証

    // Parse user ID
    userID, err := uuid.Parse(claims.Subject)
    if err != nil {
        return nil, fmt.Errorf("invalid user ID in token: %w", err)
    }

+   // Get expiration and issued-at times from standard JWT claims
+   var expiresAt, loginAt time.Time
+   if claims.ExpiresAt != nil {
+       expiresAt = claims.ExpiresAt.Time
+   }
+   if claims.IssuedAt != nil {
+       loginAt = claims.IssuedAt.Time
+   }

+   // Note: Using UserID as TenantID (single-tenant architecture per auth-hub)
    return &domain.UserContext{
        UserID:    userID,
        Email:     claims.Email,
        Role:      domain.UserRole(claims.Role),
+       TenantID:  userID,  // Use UserID as TenantID (single-tenant model)
        SessionID: claims.Sid,
+       LoginAt:   loginAt,
+       ExpiresAt: expiresAt,
    }, nil
}
```

### 動作確認

修正後、以下を確認：

1. `https://curionoah.com/sv/desktop/stats`にアクセス
2. ブラウザコンソール:
   - ✅ 認証エラーが発生しない
   - ✅ 5秒ごとにstats更新が届く
3. バックエンドログ:
   - ✅ `StreamFeedStats`が正常に実行される
   - ✅ 認証エラーログが出ない

### デバッグログの削除

本番品質向上のため、以下のデバッグログを削除：

**ファイル:** `alt-frontend-sv/src/lib/hooks/useFeedStats.svelte.ts`
- `console.log("[useFeedStats] Initializing...")`
- `console.log("[useFeedStats] Using Connect-RPC Streaming")`
- `console.log("[useFeedStats] Using SSE (legacy)")`

**ファイル:** `alt-frontend-sv/src/lib/hooks/useStreamingFeedStats.svelte.ts`
- `console.log("[useStreamingFeedStats] Attempting to connect...")`
- `console.log("[useStreamingFeedStats] Creating client transport...")`
- `console.log("[useStreamingFeedStats] Transport created...")`
- `console.log("[useStreamingFeedStats] Received stats:", stats)`
- `console.log("[useStreamingFeedStats] Connection established")`
- `console.log("[useStreamingFeedStats] Scheduling reconnect...")`

**残したログ:**
- `console.error("[useStreamingFeedStats] Max retry attempts reached")` - エラー検知に必要
- `console.error("[useStreamingFeedStats] Stream error:", error)` - エラー検知に必要
- `console.error("[useStreamingFeedStats] Connection failed:", error)` - エラー検知に必要

## メリット（PROS）

### 1. 認証整合性の確保

- UserContextの全フィールドが適切に設定され、`IsValid()`が正しく動作
- JWTトークンの有効期限が確実にチェックされる
- セキュリティ上の重要な検証が確実に実行される

### 2. auth-hubとの設計一貫性

- auth-hubと同じ`TenantID = UserID`パターンを採用
- 認証レイヤー全体で統一された設計
- 将来的なリファクタリング時の混乱を回避

### 3. 防御的プログラミング

- nil チェックにより、JWTの一部フィールド欠落に対する耐性
- ゼロ値の`time.Time`でもプログラムはクラッシュしない
- `IsValid()`で適切に検証される

### 4. JWT標準仕様への準拠

- RFC 7519のRegistered Claimsを活用
- トークン発行側（auth-token-manager）との明確な契約
- 標準的なJWTライブラリとの互換性

### 5. 本番品質の向上

- 不要なデバッグログを削除
- エラーログのみを残し、障害検知を維持
- ブラウザコンソールのノイズ削減

## デメリットと考慮事項（CONS, TRADEOFF）

### 1. Single-tenant前提の設計

**問題:**
- `TenantID = UserID`はsingle-tenant専用の設計
- 真のmulti-tenantには不適切

**対策:**
- 将来のmulti-tenant化は想定済み
- JWTに`tenant_id` claimを追加するだけで移行可能
- データモデルは既に`TenantID`フィールドを持っている

### 2. JWT依存の強化

**問題:**
- UserContextの重要フィールドがJWTに依存
- トークン発行側の変更がバックエンドに影響

**対策:**
- Protocol BuffersでJWT契約を明示化する選択肢もある
- 現状は、auth-token-managerのドキュメント化で対処

### 3. ゼロ値の扱い

**問題:**
- `ExpiresAt`, `LoginAt`がnilの場合、ゼロ値（`0001-01-01`）が設定される
- `IsValid()`は通るが、実質的に"期限切れ"扱いになる

**対策:**
- auth-token-managerは現在、必ず`ExpiresAt`を発行
- 将来的には、`ExpiresAt`が必須であることをバリデーションで強制する選択肢もある

### 4. デバッグの困難化

**問題:**
- デバッグログを削除したことで、問題発生時の追跡が難しくなる可能性

**対策:**
- エラーログは残しているため、障害検知は可能
- 開発時は構造化ログ（`slog`）で詳細をトレース
- 必要に応じて、`slog.Debug`レベルでログを追加

## 付録（APPENDIX）

### 関連するアーキテクチャ決定

- **ADR-000028**: Buf Connect-RPCの導入とREST APIからの段階的移行
  - Server Streaming RPCの基盤となる決定
  - 本ADRはADR-000028の実装過程で発見された問題への対処

### 参考リンク

- [Connect-RPC Streaming Documentation](https://connectrpc.com/docs/go/streaming/)
- [Connect-RPC Error Handling](https://connectrpc.com/docs/go/errors/)
- [RFC 7519: JSON Web Token (JWT)](https://datatracker.ietf.org/doc/html/rfc7519)
- [golang-jwt/jwt Documentation](https://pkg.go.dev/github.com/golang-jwt/jwt/v5)

### 影響を受けるコンポーネント

**バックエンド:**
- `alt-backend/app/connect/v2/middleware/auth_interceptor.go` - 修正
- `alt-backend/app/domain/user_context.go` - 参照のみ（変更なし）

**フロントエンド:**
- `alt-frontend-sv/src/lib/hooks/useFeedStats.svelte.ts` - デバッグログ削除
- `alt-frontend-sv/src/lib/hooks/useStreamingFeedStats.svelte.ts` - デバッグログ削除

**認証サービス:**
- `auth-hub/handler/validate.go` - 参考実装（変更なし）
- `auth-token-manager/handler/exchange.go` - JWT発行側（変更なし）

### テスト戦略

**手動テスト:**
1. `/sv/desktop/stats`にアクセス
2. Streaming接続が確立され、5秒ごとに更新されることを確認
3. ブラウザコンソールで認証エラーが出ないことを確認

**将来の自動テスト:**
- `auth_interceptor_test.go`で`validateToken`のユニットテスト追加を推奨
- JWT claims（ExpiresAt, IssuedAt）が正しくUserContextに反映されることをテスト
- nilフィールドの扱いをテスト

### 今後の改善案

1. **JWT契約の明示化**
   - Protocol Buffersで`BackendClaims`のスキーマを定義
   - auth-token-managerとの契約を型レベルで保証

2. **`IsValid()`のバリデーション強化**
   - `ExpiresAt`が未来の時刻であることを明示的にチェック
   - `LoginAt`がゼロ値でないことをチェック（オプション）

3. **構造化ログの活用**
   - 認証成功時に`slog.Debug`でUserContext詳細を記録
   - 開発時のデバッグを容易にする

4. **テスト追加**
   - `auth_interceptor_test.go`にユニットテスト追加
   - `StreamFeedStats`のE2Eテスト追加

---

**作成日:** 2025年12月30日
**作成者:** Claude (Code Assistant)
**レビュー:** 未実施
**関連Issue:** N/A
**関連PR:** N/A
