# Connect-Timeout-Ms セマンティクスによる FetchArticleContent 502 タイムアウトの修正

## ADR ステータス

承認済み — 2026-02-27

## 背景

ブラウザからの `FetchArticleContent` API 呼び出しが、常に正確に30秒後に HTTP 502 を返していた。根本原因は BFF（Backend-For-Frontend）サービスにおけるタイムアウト階層の競合だった。

**観測された症状:**

| レイヤー | 証拠 |
|---------|------|
| nginx | すべてのリクエストが `rt=30.00x` で 502 を表示 |
| BFF | `context deadline exceeded (Client.Timeout exceeded while awaiting headers)` |
| バックエンド | `rate limit wait failed: context canceled`（BFF からのコンテキストキャンセルが伝播） |

バックエンド自体は正常に動作していたが、記事コンテンツ取得のワークフロー — レートリミッター待機（5秒）+ robots.txt チェック + HTTP フェッチ（10–30秒）— は、キャッシュされていない記事に対して日常的に30秒を超えていた。

**根本原因:** BFF の `http.Client` に `Timeout: 30s` がハードコードされていた。フロントエンドが2分間のタイムアウトを要求するために `Connect-Timeout-Ms: 120000` を送信していたにもかかわらず、Go の `http.Client.Timeout` が先に発火してリクエストをキャンセルしていた。Connect-RPC のセマンティクスでは、プロキシではなく**クライアント**が `Connect-Timeout-Ms` ヘッダーでタイムアウトを制御する。

## 意思決定

### アプローチ: Connect-Timeout-Ms からのリクエストごとのコンテキストデッドライン

グローバルな `http.Client.Timeout` を削除し、代わりに `Connect-Timeout-Ms` ヘッダーからリクエストごとの `context.WithTimeout` を導出する。これは、発信元クライアントが待機時間を決定するという Connect-RPC のタイムアウト伝播セマンティクスを尊重するものである。

### タイムアウト解決ロジック

```
1. Connect-Timeout-Ms ヘッダーをパース
2. 有効かつ > 0 → タイムアウトとして使用
3. 未指定または無効 → defaultTimeout（30秒、設定可能）を使用
4. maxConnectTimeout（5分）でキャップし、悪用を防止
5. リクエストのコンテキストデッドラインとして適用
```

ストリーミングクライアントは、ストリーミングのライフサイクル特性が異なるため、独自の `http.Client.Timeout` をセーフティネットとして保持する。

### 変更対象ファイル

| ファイル | 変更内容 |
|----------|---------|
| `alt-butterfly-facade/internal/client/backend_client.go` | `httpClient.Timeout` を削除、`DefaultTimeout()` ゲッターを追加 |
| `alt-butterfly-facade/internal/handler/proxy_handler.go` | `defaultTimeout` フィールド、`ServeHTTP` 内に `applyConnectTimeout()` メソッドを追加 |
| `alt-butterfly-facade/internal/handler/bff_handler.go` | BFF 用ハンドラに同じ `applyConnectTimeout()` パターンを適用 |
| `alt-butterfly-facade/internal/server/server.go` | 設定済みタイムアウトをハンドラコンストラクタに渡すよう変更 |
| `alt-frontend-sv/src/lib/connect/articles.ts` | `fetchArticleContent` に `timeoutMs: 120_000` を設定 |

### 追加テスト

| テスト | 検証内容 |
|--------|---------|
| `TestBackendClient_HttpClientTimeout_IsZero` | `httpClient.Timeout` が無効（0）であること |
| `TestBackendClient_DefaultTimeout` | ゲッターが設定値を返すこと |
| `TestProxyHandler_ApplyConnectTimeout_WithHeader` | 120000ms ヘッダー → 120秒のコンテキストデッドライン |
| `TestProxyHandler_ApplyConnectTimeout_WithoutHeader` | ヘッダー未指定 → 30秒のデフォルト |
| `TestProxyHandler_ApplyConnectTimeout_CappedAt5Minutes` | 過大な値 → 5分でキャップ |
| `TestBFFHandler_ApplyConnectTimeout_*` | BFF ハンドラでの同じ3つのシナリオ |

## 結果・影響

### リクエストフロー（変更後）

```
フロントエンド              BFF                         バックエンド
   |                         |                            |
   |-- Connect-Timeout-Ms ---|                            |
   |   120000                |                            |
   |                         |-- ctx deadline: 120s ----->|
   |                         |                            |-- レートリミット (5s)
   |                         |                            |-- robots.txt
   |                         |                            |-- HTTP フェッチ (10-30s)
   |                         |<--- レスポンス --------------|
   |<--- レスポンス ----------|                            |
```

以前は、BFF の30秒 `http.Client.Timeout` が破線の位置で発火し、バックエンドの処理中の作業をキャンセルしていた。現在は120秒のコンテキストデッドラインにより、バックエンドに十分な時間が与えられる。

### 利点

- Connect-RPC のタイムアウト伝播セマンティクスを尊重 — クライアントがタイムアウトを制御
- リクエスト単位の粒度: 長時間実行エンドポイント（FetchArticleContent）が他に影響せずに追加時間を要求可能
- 5分のキャップにより無制限のリソース保持を防止
- `Connect-Timeout-Ms` ヘッダーのない既存エンドポイントは以前の30秒動作にフォールバック — 未変更クライアントへの動作変更はゼロ
- ストリーミングクライアントのタイムアウトは影響なし

### 欠点・トレードオフ

- BFF はユナリリクエストに対するグローバルハードタイムアウトを強制しなくなった。不正なクライアントが最大5分間（キャップ値）接続を保持する可能性がある。BFF は nginx の背後にある内部サービスであり、nginx 独自のタイムアウト制御があるため、これは許容範囲内。
- `FetchArticleContent` のクライアントタイムアウトが120秒になった。バックエンドが本当に応答しない場合、ユーザーがエラーを確認するまでの待機時間が長くなる。これは意図されたトレードオフであり、30秒で常に失敗するよりも、記事コンテンツのために2分間待つ方が望ましい。

## 付録

- Connect-RPC タイムアウト仕様: https://connectrpc.com/docs/protocol/#unary-request
- Go `http.Client.Timeout` とコンテキストデッドラインの比較: `http.Client.Timeout` はリクエストのライフサイクル全体に適用され、リクエスト単位でオーバーライドできない。コンテキストデッドラインは合成可能であり、コールチェーン全体に伝播する。
