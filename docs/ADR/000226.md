# ADR-000226: 検索ページ追加ロード時のスピナー永続表示バグ修正

## STATUS

Accepted（実装完了・コンテナデプロイ・動作確認済み）

## CONTEXT

ADR-224 で `$effect` 内の `isLoading` ガードを除去した後、デスクトップ検索ページ (`/desktop/feeds/search`) において、infinite scroll による追加ロード時にローディングスピナーが停止しない問題が発生していた。

### 再現条件

1. 検索を実行し、結果が複数ページにわたる場合
2. スクロールして追加ロードが発火
3. スピナーが表示されたまま消えない

### 原因

検索ページおよび FeedGrid コンポーネントは、素の `$effect` + `IntersectionObserver` で infinite scroll を実装していたが、以下の問題があった:

1. **unobserve/re-observe パターン未実装**: `loadMore()` 完了後、trigger 要素が viewport 内に残っている場合、IntersectionObserver は交差**変化**時のみ発火するため再発火しない
2. **callback を await していない**: observer callback が非同期でないため、`loadMore()` の Promise 完了を待たずに処理が進み、re-observe タイミングを制御できない
3. **try-finally 未使用**: `loadFeeds()` が例外を throw した場合に `isFetchingNextPage = false` に到達しないため、スピナーが永続表示になる

### 影響範囲

同じパターンを使用していた全 4 箇所:

- `/desktop/feeds/search` — 検索ページ
- `FeedGrid.svelte` — デスクトップフィード一覧
- `/desktop/feeds/viewed` — デスクトップ閲覧履歴
- `/(app)/feeds/viewed` — レスポンシブ閲覧履歴

## DECISION MAKING

### 既存の `infiniteScroll` action への統一

`src/lib/actions/infinite-scroll.ts` に、ベストプラクティスを実装済みの Svelte action が既に存在していた。この action は以下を提供する:

- **unobserve → callback 実行 → requestAnimationFrame → re-observe**: trigger が viewport 内に残っている場合でも連続ロードが正しく動作する
- **callback の await**: `loadMore()` の Promise 完了を待ってから re-observe するため、タイミング制御が正確
- **`disabled` プロパティ**: loading 中や最終ページ到達時に observer を適切に無効化
- **`rootMargin` によるプリフェッチ**: viewport に到達する 200px 前にロードを開始し、体感的な待ち時間を削減

各ページで独自に `$effect` + `IntersectionObserver` を実装するのではなく、この共通 action に統一することで、バグの再発防止とコードの一貫性を実現した。

### try-finally の追加

`loadMore()` 関数に `try-finally` を追加し、API 呼び出しが失敗した場合でも `isFetchingNextPage` フラグが確実にリセットされるようにした。

### 独自 `$effect` を使わない理由

- `$effect` 内で `IntersectionObserver` を手動管理すると、unobserve/re-observe のタイミング制御が煩雑になる
- Svelte の `use:action` ディレクティブは、`update()` メソッドにより reactive な props 変更に自動追従するため、`disabled` 状態の変化に対して observer の再構築が自動的に行われる
- action パターンは再利用性が高く、テストも容易

## RESULTS

### 変更ファイル

| ファイル | 変更内容 |
|---------|---------|
| `src/routes/desktop/feeds/search/+page.svelte` | `loadMoreTrigger` state + `$effect` 削除、`use:infiniteScroll` に置換 |
| `src/lib/components/desktop/feeds/FeedGrid.svelte` | `loadMore` に try-finally 追加、`loadMoreTrigger` + `$effect` 削除、`use:infiniteScroll` に置換 |
| `src/routes/desktop/feeds/viewed/+page.svelte` | `loadMore` に try-finally 追加、`loadMoreTrigger` + `$effect` 削除、`use:infiniteScroll` に置換 |
| `src/routes/(app)/feeds/viewed/+page.svelte` | `loadMore` に try-finally 追加、`loadMoreTrigger` + `$effect` 削除、`use:infiniteScroll` に置換 |

### 変更パターン

各ファイルで共通の変更パターン:

**Before** — 素の `$effect` + `IntersectionObserver`:

```svelte
<script>
let loadMoreTrigger = $state<HTMLDivElement | undefined>(undefined);

$effect(() => {
    if (!loadMoreTrigger) return;
    const observer = new IntersectionObserver(
        (entries) => {
            const [entry] = entries;
            if (entry.isIntersecting && hasNextPage && !isFetchingNextPage) {
                loadMore();  // await なし、re-observe なし
            }
        },
        { threshold: 0.5 },
    );
    observer.observe(loadMoreTrigger);
    return () => observer.disconnect();
});

async function loadMore() {
    if (isFetchingNextPage || !hasNextPage) return;
    isFetchingNextPage = true;
    await loadFeeds(nextCursor);
    isFetchingNextPage = false;  // 例外時に到達しない
}
</script>

<div bind:this={loadMoreTrigger} class="py-8 text-center">
```

**After** — `use:infiniteScroll` action + try-finally:

```svelte
<script>
import { infiniteScroll } from "$lib/actions/infinite-scroll";

async function loadMore() {
    if (isFetchingNextPage || !hasNextPage) return;
    isFetchingNextPage = true;
    try {
        await loadFeeds(nextCursor);
    } finally {
        isFetchingNextPage = false;
    }
}
</script>

<div
    use:infiniteScroll={{
        callback: loadMore,
        disabled: isFetchingNextPage || !hasNextPage,
        threshold: 0.1,
        rootMargin: "0px 0px 200px 0px",
    }}
    class="py-8 text-center"
>
```

### 検証結果

| 検証項目 | 結果 |
|---------|------|
| 検索ページ ユニットテスト (`bun test src/routes/desktop/feeds/search/`) | 17/17 PASS |
| `svelte-check --tsconfig ./tsconfig.json` | 0 errors, 0 warnings |
| `alt-frontend-sv` コンテナ再ビルド・起動 | 正常 (`healthy`) |
| `GET /api/health` (フロントエンド) | `{"status":"ok"}` |
| `GET /v1/health` (バックエンド) | `{"status":"healthy"}` |

## PROS

1. **バグ修正**: スピナー永続表示問題が解消される。unobserve/re-observe パターンにより、trigger が viewport 内に残っていても正しく連続ロードが発火する
2. **コード統一**: 4 箇所で独自に実装されていた IntersectionObserver ロジックが、共通の `infiniteScroll` action に統一された
3. **堅牢性向上**: try-finally により、API エラー時にも `isFetchingNextPage` が確実にリセットされる
4. **UX 改善**: `rootMargin: "0px 0px 200px 0px"` により、ユーザーが trigger に到達する前にプリフェッチが開始される
5. **コード削減**: 各ファイルから `loadMoreTrigger` state 変数と `$effect` ブロック（約 15 行）が削除され、`use:infiniteScroll` ディレクティブ（6 行）に置換

## CONS, TRADEOFF

1. `use:infiniteScroll` action は `disabled` props の変更ごとに observer を再構築する。高頻度で `disabled` が切り替わるケースでは微小なオーバーヘッドがあるが、infinite scroll のユースケースでは無視できるレベル
2. action 内部で `requestAnimationFrame` を使用しているため、re-observe に 1 フレーム分の遅延が生じる。これは DOM 更新を待つための意図的な設計

## APPENDIX

### `infiniteScroll` action の動作フロー

```
observe(element)
    ↓
IntersectionObserver 発火 (isIntersecting = true)
    ↓
unobserve(element)          ← 重複発火を防止
    ↓
await callback()            ← loadMore() を await
    ↓
await requestAnimationFrame ← DOM 更新を待機
    ↓
observer && !disabled ?
    ├── yes → observe(element)  ← trigger が viewport 内なら再発火
    └── no  → 終了
```

### IntersectionObserver の発火条件

IntersectionObserver は交差状態の**変化**時にのみコールバックを発火する。つまり、要素が viewport 内に留まり続ける場合、初回の交差以降はコールバックが発火しない。これが素の observer 実装でスピナーが停止しなかった根本原因であり、unobserve/re-observe パターンが必要な理由である。
