# nginx動的DNS解決によるコンテナ再起動時の502エラー対策

## ステータス

承認済み（2026-01-29）

## 背景

### 発生した問題

SvelteKitフロントエンドコンテナ（alt-frontend-sv）を再ビルド・再起動した際に、一時的に502 Bad Gatewayエラーが発生していた。

```
connect() failed (111: Connection refused)
upstream: "http://[container-ip]:4173/sv/..."
```

### 原因分析

nginxの`upstream`ブロックは**起動時に1回だけDNS解決**を行い、結果をキャッシュする。Dockerコンテナが再起動すると新しいIPアドレスが割り当てられるが、nginxは古いIPへ接続を試み続ける。

```nginx
# 問題のあった設定
upstream alt-frontend-sv {
    server alt-frontend-sv:4173;
}

location /sv/ {
    proxy_pass http://alt-frontend-sv/sv/;
}
```

`resolver`ディレクティブを設定しても、`upstream`ブロック内のサーバー定義には**適用されない**。

## 決定事項

### アプローチ

nginx公式ドキュメントに基づき、**変数を使った動的DNS解決**に変更する。

> "Parameter value can contain variables. In this case, if an address is specified as a domain name, the name is searched among the described server groups, and, if not found, is determined using a resolver."
> — [nginx proxy_pass documentation](https://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass)

### 実装内容

1. **resolverディレクティブ**（既存設定を活用）

```nginx
# Docker内蔵DNSサーバー、10秒ごとに再解決
resolver 127.0.0.11 valid=10s ipv6=off;
```

2. **upstreamブロックの削除**

```nginx
# 削除: 静的DNS解決のため動的解決が効かない
# upstream alt-frontend-sv {
#     server alt-frontend-sv:4173;
# }
```

3. **locationブロックで変数を使用**

```nginx
location /sv/ {
    # 変数を使うことでresolverによる動的DNS解決が有効になる
    set $sveltekit_backend "http://alt-frontend-sv:4173";
    proxy_pass $sveltekit_backend;
    # ... その他の設定
}
```

### 重要なポイント

**変数使用時のURI処理**（公式ドキュメントより）:

| 設定 | 動作 |
|-----|------|
| `proxy_pass http://upstream/path/;` | locationパスを`/path/`に置換 |
| `proxy_pass $variable;` | リクエストURIをそのまま渡す |
| `proxy_pass $variable/path/;` | `/path/`のみを渡す（元のパスは失われる） |

本実装では`proxy_pass $variable;`（URIなし）を使用し、元のリクエストURI（`/sv/xxx`）をそのままバックエンドに渡す。

## 結果・影響

### 変更ファイル

| ファイル | 変更内容 |
|---------|---------|
| `nginx/conf.d/default.conf` | upstream削除、location内で`set`変数使用に変更 |

### メリット

- **自動復旧**: コンテナ再起動後、最大10秒で新しいIPに自動切り替え
- **ダウンタイム削減**: nginx再起動なしでバックエンド再起動に対応
- **運用負荷軽減**: デプロイ時の手動介入が不要

### デメリット・トレードオフ

- **わずかなオーバーヘッド**: 10秒ごとのDNS解決（実質的に無視できるレベル）
- **keepalive無効化**: upstreamブロックの`keepalive`設定が使えなくなる
  - 影響: 接続の再利用効率がわずかに低下
  - 対策: HTTP/1.1の`Connection: keep-alive`で部分的に補完

### 適用範囲

この変更は`alt-frontend-sv`のみに適用。他のupstream（backend, kratos, auth-hub等）は従来通りupstreamブロックを使用。

理由:
- alt-frontend-svは開発・デプロイで頻繁に再起動される
- 他のサービスはより安定しており、再起動頻度が低い

## 付録

### 動作確認手順

```bash
# 1. nginx設定テスト
docker exec [nginx-container] nginx -t

# 2. nginx設定リロード
docker exec [nginx-container] nginx -s reload

# 3. コンテナ再起動
docker compose -f compose/compose.yaml -p alt restart alt-frontend-sv

# 4. 動作確認（再起動後すぐに復旧）
curl -s -o /dev/null -w "%{http_code}" http://localhost/sv/health
# 期待値: 200
```

### 検証結果

コンテナ再起動後、5秒以内に200 OKを確認。

### 参考資料

- [nginx proxy_pass directive](https://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass)
- [nginx resolver directive](https://nginx.org/en/docs/http/ngx_http_core_module.html#resolver)
- [Docker Compose DNS TTL issue #11467](https://github.com/docker/compose/issues/11467)
- [nginx proxy_pass with variables](https://dev.to/danielkun/nginx-everything-about-proxypass-2ona)

### 関連ADR

- なし
