# MinHash LSH による近似重複検出の導入

## ADR'S STATUS

Accepted

## CONTEXT

### 背景

7days Recap パイプラインにおいて、類似記事の重複検出は完全一致ハッシュのみで行われていた。これにより、軽微な差異（句読点、空白、言い回し）がある近似重複記事を検出できず、重複コンテンツがまとめ記事に混入していた。

### 問題

1. **完全一致のみ**: 1 文字でも異なると別記事として扱われる
2. **近似重複未検出**: 同一ニュースの異なるソースからの記事を識別できない
3. **スケーラビリティ**: 全ペア比較は O(n²) で大規模データに非効率
4. **言語非依存性**: 日本語・英語両方で動作する汎用的な手法が必要

### 実装前の状態

- 重複検出: 完全一致ハッシュのみ
- 近似重複: 未対応
- 計算量: O(n) for exact, O(n²) for pairwise (未実装)

## DECISION MAKING

### 決定

recap-worker (Rust) に MinHash LSH モジュールを新規実装。

#### アルゴリズム概要

```
1. Shingling: テキスト → 文字 n-gram 集合
2. MinHash: n-gram 集合 → 固定長シグネチャ (128 次元)
3. LSH Banding: シグネチャ → バケット (候補ペア生成)
4. Verification: 候補ペアの実際の類似度計算
```

#### 実装詳細

```rust
pub struct MinHashLSH {
    num_perm: usize,           // ハッシュ置換数 (default: 128)
    num_bands: usize,          // LSH バンド数
    rows_per_band: usize,      // バンドあたりの行数
    buckets: Vec<FxHashMap<u64, SmallVec<[usize; 4]>>>,
    signatures: Vec<MinHashSignature>,
    shingle_size: usize,       // 文字 n-gram サイズ (default: 5)
    seeds: Vec<u64>,           // 再現性のための固定シード
}

impl MinHashLSH {
    pub fn check_duplicate(
        &mut self,
        doc_id: &str,
        content: &str,
        index: usize,
        threshold: f64,
        insert_if_unique: bool,
    ) -> DuplicateResult {
        // 1. シグネチャ計算
        // 2. LSH クエリで候補取得
        // 3. 候補との実際の類似度検証
        // 4. 閾値以上なら重複と判定
    }
}
```

#### 技術選定

| 項目 | 選定 | 理由 |
|------|------|------|
| ハッシュ関数 | XXH3 | 高速、衝突耐性、SIMD 最適化 |
| データ構造 | FxHashMap + SmallVec | メモリ効率、キャッシュ効率 |
| シグネチャサイズ | 128 | 精度とメモリのバランス |
| 文字 n-gram | 5 | 日本語・英語両対応、適度な粒度 |

#### LSH パラメータ最適化

類似度閾値 `s` に対し、最適なバンド数 `b` と行数 `r` を自動計算。

```rust
fn optimal_lsh_params(num_perm: usize, threshold: f64) -> (usize, usize) {
    // P(candidate) ≈ 1 - (1 - s^r)^b
    // 閾値での確率が 0.5 になる (b, r) を探索
}
```

**閾値 0.5 の場合**: 128 置換 → 約 16 バンド × 8 行

## RESULTS, EFFECTS

### 変更ファイル

| ファイル | 種別 | 内容 |
|----------|------|------|
| `recap-worker/recap-worker/src/pipeline/minhash.rs` | 新規 | MinHash LSH 実装 |
| `recap-worker/recap-worker/src/pipeline.rs` | 修正 | モジュール追加 |

### 効果

- 近似重複検出（Jaccard 類似度ベース）
- O(1) 候補検索（LSH による定数時間クエリ）
- メモリ効率的（SmallVec による小規模最適化）
- 日本語・英語両対応（文字ベース shingling）

### PROS

1. **高速**: XXH3 + FxHashMap による最適化
2. **スケーラブル**: LSH により O(n) でインデックス構築、O(1) でクエリ
3. **調整可能**: 閾値パラメータで精度/再現率をトレードオフ
4. **メモリ効率**: SmallVec で小規模バケットの割り当てオーバーヘッド削減
5. **再現性**: 固定シードによる決定的動作

### CONS, TRADEOFF

1. **確率的**: LSH は確率的手法のため、偽陰性（検出漏れ）が発生する可能性
2. **パラメータ調整**: 閾値とバンド数の適切な設定が必要
3. **メモリ使用**: シグネチャをメモリに保持（大規模データでは検討が必要）

## APPENDIX

### 参考資料

- [MinHash LSH in Milvus](https://milvus.io/blog/minhash-lsh-in-milvus-the-secret-weapon-for-fighting-duplicates-in-llm-training-data.md)
- [Rensa: High-Performance MinHash in Rust](https://github.com/beowolx/rensa)
- [Bloom Filter 最適化](https://tech.preferred.jp/en/blog/improve-minhashlsh-for-deduplication-on-large-scale-dataset/)
- [XXHash](https://github.com/Cyan4973/xxHash)

### 計算量

| 操作 | 計算量 | 備考 |
|------|--------|------|
| シグネチャ計算 | O(|text| × num_perm) | 文字数 × 置換数 |
| インデックス挿入 | O(num_bands) | バンド数に比例 |
| クエリ | O(num_bands + |candidates|) | 実質 O(1) |
| 類似度検証 | O(num_perm × |candidates|) | 候補数に比例 |
