# tag-generator 日本語タグ品質フィルタリング

## ADR's STATUS

Accepted (実装完了)

## CONTEXT

### 問題点

日本語タグ抽出において、以下の低品質タグが混入する問題が確認された。

| 問題タイプ | 例 |
|------------|-----|
| 長すぎる (20文字超) | `vscodeで使用できるtailwindの公式intellisenseや...` |
| 数字のみ | `2025`, `12` |
| URL/HTML断片 | `https`, `com`, `gt` |
| 動詞終わり | `〜しました`, `〜です` |

### 根本原因

コード調査により以下の問題箇所を特定。

**1. Regex Phase 2で長い断片が混入 (`extract.py`)**
```python
for pattern in patterns:
    matches = re.findall(pattern, text)
    compound_words.extend(matches)  # ← 長さチェックなし
```

**2. Proper Noun Extractionに最大長チェックなし**
```python
if len(compound) >= 3:  # ← 最小のみ、最大なし
    compound_words.append(compound)
```

**3. 候補フィルタリングに文法チェックなし**
```python
candidates = [
    term for term, freq in combined_freq.most_common(...)
    if freq >= 2 or len(term) >= 4  # ← 文法チェックなし
]
```

### 参考資料

- [KeyBERT CountVectorizer Guide](https://maartengr.github.io/KeyBERT/guides/countvectorizer.html)
- [GiNZA Bunsetsu Phrase Extraction](https://megagon.ai/ginza-version-4-0/)

## DECISION MAKING

### 解決策

タグとして不適切なパターンをフィルタリングする `_is_valid_japanese_tag()` メソッドを追加。

```python
MAX_TAG_LENGTH = 20

def _is_valid_japanese_tag(self, tag: str) -> bool:
    """文法的に不適切なタグを除外"""
    # 長さチェック (2-20文字)
    if not (2 <= len(tag) <= MAX_TAG_LENGTH):
        return False

    # 動詞・助動詞で終わる（文章断片の可能性）
    if re.search(r'(です|ます|ました|ている|した|する|ない|ある|いる|れる|られる)$', tag):
        return False

    # 短い助詞終わり（不完全な句）
    if re.search(r'[はがをにでとのへやもかな]$', tag) and len(tag) <= 5:
        return False

    # 数字のみ
    if re.fullmatch(r'\d+', tag):
        return False

    # URL/HTML断片
    if re.fullmatch(r'(https?|www|com|org|net|html|gt|lt|amp|nbsp)', tag, re.IGNORECASE):
        return False

    return True
```

### 適用箇所

1. **Regex Phase 2**: マッチ結果に `MAX_TAG_LENGTH` フィルタ適用
2. **Proper Noun Extraction**: 長さ範囲を `3 <= len(compound) <= MAX_TAG_LENGTH` に変更
3. **候補フィルタリング**: `_is_valid_japanese_tag()` を適用

## RESULTS, EFFECTS

### 変更ファイル

| ファイル | 変更内容 |
|---------|---------|
| `tag_extractor/extract.py` | `MAX_TAG_LENGTH` 定数、`_is_valid_japanese_tag()` メソッド追加、各フェーズにフィルタ適用 |
| `tag_extractor/hybrid_extractor.py` | `_is_valid_tag()` メソッド追加、候補生成時にフィルタ適用 |

### 新規テストファイル

| ファイル | テスト数 | 内容 |
|---------|---------|------|
| `tests/unit/test_tag_quality_filter.py` | 36 | 長さ、動詞終わり、助詞終わり、数字のみ、URL断片フィルタのテスト |

### 追加テスト (既存ファイル)

| ファイル | 追加テスト数 | 内容 |
|---------|-------------|------|
| `tests/unit/test_hybrid_extractor.py` | 12 | HybridExtractor の `_is_valid_tag()` テスト |

### フィルタリング対象

| カテゴリ | フィルタパターン | 理由 |
|---------|----------------|------|
| 長さ | `len(tag) > 20` | 文章断片の可能性が高い |
| 長さ | `len(tag) < 2` | 意味のある単語でない |
| 動詞終わり | `です`, `ます`, `ました`, `ている`, `した`, `する`, `ない`, `ある`, `いる`, `れる`, `られる` | 文章の述部であり名詞句でない |
| 短い助詞終わり | `は`, `が`, `を`, `に`, `で` 等 (5文字以下) | 不完全な句 |
| 数字のみ | `\d+` | 年号等は文脈依存で意味がない |
| URL断片 | `https`, `www`, `com`, `org`, `net`, `html` | HTMLパース残骸 |
| HTML実体参照 | `gt`, `lt`, `amp`, `nbsp` | HTMLパース残骸 |

### PROS

1. **即効性**: 既存パイプラインに最小限の変更で適用可能
2. **TDD準拠**: 36+12の新規テストで品質担保
3. **設定不要**: デフォルトで有効、設定変更不要
4. **パフォーマンス影響なし**: 正規表現チェックのみで高速

### CONS, TRADEOFF

1. **一部の有効なタグが除外される可能性**: 例: `5G` は許可、`2025` は除外
2. **言語固有**: 日本語動詞パターンのみ対応（英語は別処理）

## APPENDIX

### TDD実装フロー

```
1. テスト作成 (RED)
   └─ test_tag_quality_filter.py: 36テスト作成
   └─ test_hybrid_extractor.py: 12テスト追加
   └─ 全テスト: FAILED (AttributeError: '_is_valid_japanese_tag')

2. 実装 (GREEN)
   └─ extract.py: MAX_TAG_LENGTH, _is_valid_japanese_tag() 追加
   └─ hybrid_extractor.py: _is_valid_tag() 追加
   └─ 全テスト: PASSED (205 tests)

3. リファクタリング (REFACTOR)
   └─ ruff format/check 適用
```

### 修正コード概要

```python
# tag_extractor/extract.py

MAX_TAG_LENGTH = 20

class TagExtractor:
    def _is_valid_japanese_tag(self, tag: str) -> bool:
        # 長さチェック
        if not (2 <= len(tag) <= MAX_TAG_LENGTH):
            return False
        # 動詞終わりチェック
        if re.search(r"(です|ます|ました|ている|した|する|ない|ある|いる|れる|られる)$", tag):
            return False
        # 短い助詞終わりチェック
        if re.search(r"[はがをにでとのへやもかな]$", tag) and len(tag) <= 5:
            return False
        # 数字のみチェック
        if re.fullmatch(r"\d+", tag):
            return False
        # URL/HTML断片チェック
        if re.fullmatch(r"(https?|www|com|org|net|html|gt|lt|amp|nbsp)", tag, re.IGNORECASE):
            return False
        return True

    def _extract_compound_japanese_words(self, text: str) -> list[str]:
        # Phase 2: Regex - MAX_TAG_LENGTH フィルタ追加
        for pattern in patterns:
            matches = re.findall(pattern, text)
            compound_words.extend(m for m in matches if len(m) <= MAX_TAG_LENGTH)

        # Phase 3: Proper Noun - 長さ範囲チェック
        if 3 <= len(compound) <= MAX_TAG_LENGTH:
            compound_words.append(compound)

    def _extract_keywords_japanese(self, text: str) -> tuple[list[str], dict[str, float]]:
        # 候補フィルタリング強化
        candidates = [
            term
            for term, freq in combined_freq.most_common(self.config.top_keywords * 5)
            if (freq >= 2 or len(term) >= 4) and self._is_valid_japanese_tag(term)
        ][: self.config.top_keywords * 3]
```

### 関連ADR

- ADR-176: tag-generator 日本語タグ生成品質改善
- ADR-181: tag-generator KeyBERT日本語スコアリング修正
