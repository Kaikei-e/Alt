# pre-processor: HTTP Client.Timeout が Context Timeout を上書きする問題の修正

## ADR's STATUS

Accepted

## CONTEXT

### 背景

pre-processor から news-creator への HTTP リクエストで `Client.Timeout exceeded while awaiting headers` エラーが頻発していた。

### 根本原因

Go の `http.Client.Timeout` と `context.WithTimeout` の 2 つのタイムアウトが競合していた。

| タイムアウト | 値 | 設定箇所 | 挙動 |
|---|---|---|---|
| `http.Client.Timeout` | 120s | `utils/http_client_manager.go` | **常に優先される (ハードシーリング)** |
| `context.WithTimeout` | 600s | `driver/summarizer_api.go` | Client.Timeout により無視される |

Go の仕様上、`http.Client.Timeout` はコネクション確立からレスポンスボディの読み取り完了までの全体タイムアウトであり、context のデッドラインより常に先に発火する。コード中のコメントには「The actual timeout is controlled by context timeout」と記載されていたが、これは誤りであった。

### なぜ 120 秒では不足するか

リクエストの処理パイプラインは以下の通り:

```
pre-processor → news-creator (セマフォキュー待ち) → LLM (テキスト生成)
```

LLM の同時処理数が制限されているため、同時リクエストが上限を超えるとキューイングが発生する。キュー待ちだけで 120 秒を超えるケースが頻繁に発生していた。

| フェーズ | 所要時間 (実測範囲) |
|---|---|
| セマフォキュー待ち | 60 ~ 160 秒 |
| LLM 生成時間 | 2 ~ 157 秒 |
| **合計** | **62 ~ 317 秒** |

### 影響範囲

同じ問題が品質チェッカー (`quality_judger.go`) にも存在していた。品質スコアリングの HTTP クライアントも `Client.Timeout = 120s` で、同じくキュー待ちでタイムアウトが発生する可能性があった。

## DECISION MAKING

### 検討したアプローチ

| Option | 内容 | 評価 |
|--------|------|------|
| A: summaryClient の Client.Timeout を 0 に設定 | context.WithTimeout に完全委譲 | **採用** |
| B: Client.Timeout を 600s に延長 | context と同じ値に合わせる | 不採用: 二重管理になる |
| C: Client.Timeout を 300s に延長 | 中間的な値 | 不採用: 根本解決にならない |

**summaryClient については Option A を採用。** `Client.Timeout = 0` (無制限) に設定することで、`summarizer_api.go` の `context.WithTimeout(ctx, cfg.NewsCreator.Timeout)` (デフォルト 600s) が唯一のタイムアウト制御となる。これが元々の設計意図だった。

**品質チェッカーについては `Client.Timeout = 300s` に延長。** こちらは context ベースのタイムアウト管理が未導入のため、Client.Timeout をキュー待ち + 生成時間 + マージンに合わせた値に設定した。

## RESULTS, EFFECTS

### 変更ファイル一覧

| ファイル | 変更内容 |
|----------|----------|
| `pre-processor/app/utils/http_client_manager.go` | `summaryClient` の `Client.Timeout` を `120s` → `0` に変更、コメント修正 |
| `pre-processor/app/quality-checker/quality_judger.go` | `scoreSummary` の `Client.Timeout` を `120s` → `300s` に変更 |
| `pre-processor/app/utils/http_client_manager_test.go` | テストの期待値を `120s` → `0` に更新 |

### タイムアウト設定の変更

| コンポーネント | 変更前 | 変更後 | タイムアウト制御 |
|---|---|---|---|
| summaryClient (要約生成) | `Client.Timeout=120s` | `Client.Timeout=0` | context.WithTimeout (600s) に委譲 |
| scoreSummary (品質チェック) | `Client.Timeout=120s` | `Client.Timeout=300s` | Client.Timeout で直接制御 |

### PROS

1. **タイムアウトエラーの解消**: キュー待ちが長い場合でもリクエストが途中で打ち切られなくなる
2. **設計意図との一致**: summaryClient のタイムアウトが context.WithTimeout に一元化され、設定ファイル (`NEWS_CREATOR_TIMEOUT`) で制御可能になる
3. **誤解を招くコメントの修正**: Go の `Client.Timeout` と context の優先順位について正確な記述に修正

### CONS, TRADEOFF

1. **summaryClient の無応答検出**: `Client.Timeout=0` のため、context がキャンセルされない限りリクエストが永続する。ただし context.WithTimeout (600s) が設定されているため実質的なリスクは低い
2. **品質チェッカーの 300s**: 十分なマージンを持たせたが、極端にキューが詰まった場合はタイムアウトする可能性がある。将来的には context ベースのタイムアウト管理への移行が望ましい

## APPENDIX

### Go の http.Client.Timeout の挙動

```go
// Client.Timeout はハードシーリングとして機能する。
// context.WithTimeout より短い場合、Client.Timeout が先に発火する。
client := &http.Client{Timeout: 120 * time.Second}

ctx, cancel := context.WithTimeout(context.Background(), 600*time.Second)
req, _ := http.NewRequestWithContext(ctx, "POST", url, body)
resp, err := client.Do(req) // 120s でタイムアウト (600s ではない)
```

参考: [Go net/http package documentation](https://pkg.go.dev/net/http#Client)

### 検証方法

```bash
# テスト実行
cd pre-processor/app && go test ./...

# コンテナ再ビルド・再起動
docker compose -f compose/compose.yaml -p alt build pre-processor
docker compose -f compose/compose.yaml -p alt up -d pre-processor

# ログ監視
docker compose -f compose/compose.yaml -p alt logs pre-processor -f | grep -E "timeout|error"
```
