# マルチ言語サービスにおける ADR 98 ビジネスコンテキストロギングの実装

## ステータス

採択（Accepted）

## コンテキスト

### 背景

ADR 98 で定義されたビジネスコンテキスト属性（`alt.feed.id`, `alt.article.id`, `alt.job.id`, `alt.processing.stage`, `alt.ai.pipeline`）を、Go/Python/Rust で実装された全マイクロサービスに展開する必要があった。

### 課題

| 課題 | 詳細 |
|------|------|
| 言語間の実装差異 | Go (slog), Python (logging/structlog), Rust (tracing) で異なるロギングライブラリ |
| コンテキスト伝播 | 非同期処理やHTTPリクエスト境界を越えたコンテキスト伝播が必要 |
| 既存コードへの影響 | 大規模な変更を避けつつ、一貫した属性出力を実現 |
| OSS 互換性 | OpenTelemetry Semantic Conventions に準拠した汎用的な設計 |

### 実装前の状態

| サービス | 言語 | fields 有り率 | alt.プレフィックス |
|---------|------|--------------|-------------------|
| Go API サービス | Go | 99.9% | 実装済み |
| Go Worker サービス | Go | N/A | 未実装 |
| Python AI サービス A | Python | 0% | 未実装 |
| Python AI サービス B | Python | 46% | 未実装 |
| Rust Worker サービス | Rust | 100% | 未実装 |

## 決定

言語ごとに最適なパターンを採用し、出力形式を統一する。

### Go サービス: Context-Based Logger

Go の `context.Context` を活用したビジネスコンテキスト伝播パターンを採用。

```go
package logger

import (
    "context"
    "log/slog"
)

type ContextKey string

const (
    JobIDKey           ContextKey = "alt.job.id"
    ArticleIDKey       ContextKey = "alt.article.id"
    ProcessingStageKey ContextKey = "alt.processing.stage"
    AIPipelineKey      ContextKey = "alt.ai.pipeline"
)

// ContextLogger はコンテキストからビジネス属性を自動抽出
type ContextLogger struct {
    logger      *slog.Logger
    serviceName string
}

// WithContext はコンテキスト値をログフィールドとして抽出
func (cl *ContextLogger) WithContext(ctx context.Context) *slog.Logger {
    logger := cl.logger.With("service", cl.serviceName)

    if jobID := ctx.Value(JobIDKey); jobID != nil {
        logger = logger.With(string(JobIDKey), jobID)
    }
    if articleID := ctx.Value(ArticleIDKey); articleID != nil {
        logger = logger.With(string(ArticleIDKey), articleID)
    }
    // ... 他の属性も同様

    return logger
}

// ヘルパー関数
func WithJobID(ctx context.Context, jobID string) context.Context {
    return context.WithValue(ctx, JobIDKey, jobID)
}
```

### Python サービス: contextvars + Filter

Python の `contextvars` を使用した非同期安全なコンテキスト伝播パターンを採用。

```python
"""Business context logger for OpenTelemetry semantic conventions."""
import logging
import json
from contextvars import ContextVar
from datetime import datetime, timezone

# Context variables（async-safe）
_alt_article_id: ContextVar[str | None] = ContextVar("alt.article.id", default=None)
_alt_job_id: ContextVar[str | None] = ContextVar("alt.job.id", default=None)
_alt_ai_pipeline: ContextVar[str | None] = ContextVar("alt.ai.pipeline", default=None)
_alt_processing_stage: ContextVar[str | None] = ContextVar("alt.processing.stage", default=None)


class BusinessContextFilter(logging.Filter):
    """Filter that injects business context into log records."""

    def filter(self, record: logging.LogRecord) -> bool:
        setattr(record, "alt.article.id", _alt_article_id.get())
        setattr(record, "alt.job.id", _alt_job_id.get())
        setattr(record, "alt.ai.pipeline", _alt_ai_pipeline.get())
        setattr(record, "alt.processing.stage", _alt_processing_stage.get())
        return True


class BusinessContextJSONFormatter(logging.Formatter):
    """JSON formatter that includes business context attributes."""

    def format(self, record: logging.LogRecord) -> str:
        log_obj = {
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "level": record.levelname.lower(),
            "logger": record.name,
            "msg": record.getMessage(),
        }

        # Add business context if present
        for key in ["alt.article.id", "alt.job.id", "alt.ai.pipeline", "alt.processing.stage"]:
            value = getattr(record, key, None)
            if value:
                log_obj[key] = value

        return json.dumps(log_obj, ensure_ascii=False)


# Setter functions
def set_article_id(article_id: str | None) -> None:
    _alt_article_id.set(article_id)

def set_ai_pipeline(pipeline: str | None) -> None:
    _alt_ai_pipeline.set(pipeline)

def clear_context() -> None:
    """Clear all business context (call in finally block)."""
    _alt_article_id.set(None)
    _alt_job_id.set(None)
    _alt_ai_pipeline.set(None)
    _alt_processing_stage.set(None)
```

#### structlog 連携（オプション）

既存の structlog 基盤がある場合は、プロセッサーを追加。

```python
from structlog.typing import EventDict, WrappedLogger

def add_business_context(
    _logger: WrappedLogger,
    _method_name: str,
    event_dict: EventDict,
) -> EventDict:
    """Rename keys to OpenTelemetry semantic conventions."""
    if "article_id" in event_dict:
        event_dict["alt.article.id"] = event_dict.pop("article_id")
    if "feed_id" in event_dict:
        event_dict["alt.feed.id"] = event_dict.pop("feed_id")

    # Always add pipeline identifier
    event_dict["alt.ai.pipeline"] = "service-name"
    return event_dict
```

### Rust サービス: tracing Layer

Rust の `tracing` クレートを使用したフィールド名変換パターンを採用。

```rust
use serde_json::json;
use tracing::{Event, Subscriber};
use tracing_subscriber::Layer;
use tracing_subscriber::layer::Context;

/// Convert internal field names to OpenTelemetry semantic conventions.
#[allow(dead_code)]
fn convert_to_otel_key(key: &str) -> String {
    match key {
        "job_id" => "alt.job.id".to_string(),
        "article_id" => "alt.article.id".to_string(),
        "processing_stage" => "alt.processing.stage".to_string(),
        "ai_pipeline" => "alt.ai.pipeline".to_string(),
        _ => key.to_string(),
    }
}

/// Structured log layer with OpenTelemetry semantic conventions.
#[allow(dead_code)]
pub(crate) struct StructuredLogLayer;

impl<S: Subscriber> Layer<S> for StructuredLogLayer {
    fn on_event(&self, event: &Event<'_>, _ctx: Context<'_, S>) {
        use tracing::field::Visit;

        struct JsonVisitor {
            values: serde_json::Map<String, serde_json::Value>,
        }

        impl Visit for JsonVisitor {
            fn record_str(&mut self, field: &tracing::field::Field, value: &str) {
                let key = convert_to_otel_key(field.name());
                self.values.insert(key, json!(value));
            }
            // ... other record_* methods
        }

        let mut visitor = JsonVisitor {
            values: serde_json::Map::new(),
        };
        event.record(&mut visitor);

        // Always include pipeline identifier
        visitor.values.insert(
            "alt.ai.pipeline".to_string(),
            json!("service-name")
        );

        // Output JSON
        let log_entry = json!({
            "timestamp": chrono::Utc::now().to_rfc3339(),
            "level": event.metadata().level().as_str(),
            "target": event.metadata().target(),
            "fields": visitor.values,
        });

        eprintln!("{}", serde_json::to_string(&log_entry).unwrap_or_default());
    }
}
```

## 結果

### 実装パターン比較

| 言語 | ライブラリ | コンテキスト伝播 | 変換タイミング |
|------|-----------|-----------------|---------------|
| Go | log/slog | context.Context | WithContext() 呼び出し時 |
| Python | logging + contextvars | ContextVar | Filter/Formatter 適用時 |
| Python | structlog | ContextVar or extra | Processor チェーン内 |
| Rust | tracing | Span fields | Layer の on_event() 内 |

### 出力形式の統一

全言語で以下の JSON 形式を出力。

```json
{
  "timestamp": "2026-01-15T12:00:00Z",
  "level": "info",
  "msg": "Processing completed",
  "alt.job.id": "abc123",
  "alt.article.id": "def456",
  "alt.ai.pipeline": "summarization",
  "alt.processing.stage": "generation"
}
```

### ClickHouse への格納

ログ収集基盤が `LogAttributes` として取り込み、マテリアライズドカラムで抽出。

```sql
-- クエリ例
SELECT
    Timestamp,
    ServiceName,
    Body,
    LogAttributes['alt.job.id'] AS JobId,
    LogAttributes['alt.article.id'] AS ArticleId
FROM otel_logs
WHERE LogAttributes['alt.ai.pipeline'] = 'summarization'
  AND Timestamp > now() - INTERVAL 1 HOUR;
```

### 効果

| 指標 | 改善前 | 改善後 |
|------|--------|--------|
| ビジネスコンテキスト追跡 | 一部サービスのみ | 全サービス対応 |
| ジョブ・記事トレーサビリティ | 不可 | `alt.job.id`, `alt.article.id` で追跡可能 |
| AI パイプライン識別 | なし | `alt.ai.pipeline` で自動分類 |
| 処理段階の可視化 | なし | `alt.processing.stage` で進捗追跡 |

### トレードオフ

| PROS | CONS |
|------|------|
| 言語に依存しない統一出力形式 | 各言語で実装パターンが異なる |
| 既存コードへの影響が最小限 | ハンドラー/エントリポイントでの明示的なコンテキスト設定が必要 |
| OpenTelemetry 互換 | `alt.` プレフィックスはカスタム属性 |
| 非同期処理でも安全に動作 | Python: contextvars の理解が必要 |

## 実装日

2026-01-15

## 関連

- [ADR 98: ClickHouse ログ基盤の包括的改善](./000098.md)
- [OpenTelemetry Semantic Conventions](https://opentelemetry.io/docs/concepts/semantic-conventions/)
- [Python contextvars](https://docs.python.org/3/library/contextvars.html)
- [Rust tracing Layers](https://docs.rs/tracing-subscriber/latest/tracing_subscriber/layer/index.html)
- [Go slog Package](https://pkg.go.dev/log/slog)
