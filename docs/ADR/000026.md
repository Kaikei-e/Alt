# Svelte 5 Runes + CSR専用によるデスクトップUI実装

## ADRのステータス

承認済み - 2025年12月30日
最終更新 - 2025年12月30日（TanStack Query削除、Svelte 5パターンへ移行）

## 背景

Alt RSS Readerプロジェクトは当初、モバイルファーストUI（`/sv/mobile`）のみを持っていました。ユーザーベースの拡大に伴い、デスクトップ最適化されたエクスペリエンスの必要性が生じました：

1. **マルチカラムレイアウト** - 大画面に適したレイアウト
2. **強化されたデータ可視化** - ダッシュボードウィジェット、統計情報
3. **改善されたナビゲーション** - 階層メニュー付き固定サイドバー
4. **英語UIラベル** - モバイル版はほぼ英語（日本語も一部使用している）仕様で、デスクトップ版は完全英語

### 技術的課題

フロントエンドでは以下を使用：
- **SvelteKit** - デフォルトでServer-Side Rendering（SSR）有効
- **Svelte 5 Runes** - `$state`、`$derived`、`$effect`による新しいリアクティビティシステム
- **bits-ui** - ヘッドレスUIコンポーネントライブラリ

初期実装で複数の技術的問題に遭遇：
1. **リアクティビティの喪失** - `$state` 変数を直接返すと初期値のみがキャプチャされる
2. **API呼び出しパターンの不一致** - 位置引数とオブジェクト引数の混在
3. **Biomeリンタールールとコンポーネントライブラリの競合** - `useImportType` ルールが bits-ui コンポーネントを破壊
4. **不要な依存関係** - TanStack Query はプロジェクトに必要なかったが誤って導入されていた

## 意思決定

### データフェッチング戦略

1. **選択肢A：TanStack Query を使用** ❌ 却下
   - 複雑な依存関係、SSR対応が必要
   - プロジェクトの要件に対してオーバーエンジニアリング
   - ハイドレーション問題が発生

2. **選択肢B：Svelte 5 ネイティブパターン** ✅ 採用
   - `$state` + `onMount` による単純な fetch
   - `$effect` による自動検索トリガー
   - IntersectionObserver による無限スクロール
   - 依存関係ゼロ、完全にSvelteネイティブ

### レンダリング戦略

デスクトップルートのSSRを無効化（CSR専用）：
- `/routes/desktop/+layout.ts`に`export const ssr = false`を追加
- デスクトップセクションがSingle Page Application（SPA）になる
- ハイドレーション問題なし、クリーンなコード
- トレードオフ：初期ロード時間がわずかに長くなる

### 採用理由

1. **シンプルさ**：外部データフェッチングライブラリ不要
2. **Svelte 5 ネイティブ**：Runes を最大限活用
3. **パフォーマンス**：不要な抽象化レイヤーがない
4. **保守性**：標準的な Svelte パターン、学習曲線なし
5. **デバッグ容易性**：ブラックボックスなし、すべてのコードが明示的

## 結果・影響

### メリット

1. **シンプルなコード**：外部ライブラリなし、Svelte 5 Runes のみ使用
2. **完全な制御**：すべてのデータフローが明示的で追跡可能
3. **バンドルサイズ削減**：TanStack Query 削除により約50KB削減
4. **開発速度の向上**：標準的な Svelte パターン、学習曲線なし
5. **安定したビルド**：依存関係の競合なし、エラーゼロ
6. **優れた開発者体験**：デバッグが容易、ブラックボックスなし

### デメリット・トレードオフ

1. **初期ロード時間**：JavaScriptがロードされるまでデスクトップセクションは白い画面
   - *軽減策*：ローディングスピナー/スケルトン画面の追加
   - *影響*：最小限、デスクトップユーザーはSPA動作を期待している

2. **SEOへの影響**：デスクトップルートが検索エンジンにインデックスされない
   - *軽減策*：認証済みダッシュボードアプリケーションのため問題なし
   - *注記*：公開ランディングページはSSR有効を維持すべき

3. **プログレッシブエンハンスメントなし**：デスクトップは機能にJavaScriptが必須
   - *受容*：デスクトップUIはJS有効のモダンブラウザをターゲット

4. **バンドルサイズ増加**：クライアントが最初にアプリケーションコード全体を必要とする
   - *軽減策*：ルートチャンクのコード分割と遅延ロード
   - *影響*：良好な帯域幅を持つデスクトップユーザーにとって許容範囲

## 実装詳細

### 作成されたファイル構造

```
alt-frontend-sv/src/
├── routes/desktop/
│   ├── +layout.ts              # ここでSSRを無効化
│   ├── +layout.svelte          # デスクトップ2カラムレイアウト
│   ├── +page.svelte            # ダッシュボード
│   ├── feeds/                  # フィード管理
│   ├── recap/                  # ウィークリーレカップ
│   ├── augur/                  # AIチャット
│   ├── settings/               # 設定ページ
│   └── stats/                  # 統計
└── lib/components/desktop/
    ├── layout/                 # Sidebar、PageHeader
    ├── dashboard/              # ウィジェット
    ├── feeds/                  # フィードコンポーネント
    ├── recap/                  # リキャップコンポーネント
    ├── augur/                  # チャットコンポーネント
    ├── settings/               # 設定コンポーネント
    └── stats/                  # 統計コンポーネント
```

### 主要なコード変更

**1. SSR無効化設定**
```typescript
// src/routes/desktop/+layout.ts
export const ssr = false;
```

**2. シンプルな fetch パターン**
```typescript
// UnreadFeedsWidget.svelte - onMount + $state
let feeds = $state<RenderFeed[]>([]);
let isLoading = $state(true);
let error = $state<Error | null>(null);

onMount(async () => {
  try {
    isLoading = true;
    const result = await getFeedsWithCursorClient(undefined, 5);
    feeds = result.data ?? [];
  } catch (err) {
    error = err as Error;
  } finally {
    isLoading = false;
  }
});
```

**3. リアクティブ検索パターン**
```typescript
// SearchPage.svelte - $effect による自動トリガー
let searchQuery = $state("");
let debouncedQuery = $state("");
let feeds = $state<RenderFeed[]>([]);

$effect(() => {
  async function search() {
    if (!debouncedQuery.trim()) {
      feeds = [];
      return;
    }
    const result = await searchFeedsClient(debouncedQuery, undefined, 50);
    feeds = result.results ?? [];
  }
  search();
});
```

**4. 無限スクロールパターン**
```typescript
// FeedGrid.svelte - IntersectionObserver
let feeds = $state<RenderFeed[]>([]);
let nextCursor = $state<string | undefined>(undefined);
let hasNextPage = $state(true);

async function loadMore() {
  if (!hasNextPage) return;
  const result = await getFeedsWithCursorClient(nextCursor, 20);
  feeds = [...feeds, ...(result.data ?? [])];
  nextCursor = result.next_cursor;
  hasNextPage = result.has_more ?? false;
}

onMount(() => {
  const observer = new IntersectionObserver((entries) => {
    if (entries[0].isIntersecting && hasNextPage) {
      loadMore();
    }
  });
  observer.observe(loadMoreTrigger);
});
```

### デザイン決定

- **UI言語**：英語（モバイルはほぼ英語（日本語も一部使用している）仕様で、デスクトップ版は完全英語）
- **レイアウト**：固定サイドバー（240px）付き2カラム
- **デザインシステム**：モバイルとCSS変数を共有、ただし長方形カード（丸角ではなく）
- **ナビゲーション**：展開可能なセクション付き階層型
- **データフェッチング**：Svelte 5 ネイティブパターン（`$state` + `onMount`/`$effect`）
- **状態管理**：Svelte 5 Runes のみ（`$state`、`$derived`、`$effect`）
- **無限スクロール**：IntersectionObserver API を直接使用

## 付録

### 関連ファイル

- `/docs/plan/desktop-implementation.md` - 完全な実装計画
- `/routes/desktop/+layout.ts` - CSR設定
- `/lib/hooks/useSSEFeedsStats.svelte.ts` - SSE統計フック（gettersパターン）
- `/lib/api/client/feeds.ts` - API クライアント関数

### ビルドメトリクス

```
✓ built in 8.94s
.svelte-kit/output/server/entries/pages/desktop/_page.svelte.js     8.58 kB │ gzip: 2.14 kB
```

### テストチェックリスト

- [x] ダッシュボードがエラーなしでロード
- [x] 無限スクロール付きフィードグリッドが動作
- [x] レカップページがジャンルと詳細を表示
- [x] Augurチャットインターフェースが機能
- [x] デバウンス付き検索が動作
- [x] モーダルダイアログが正常に開閉
- [x] ブラウザでコンソールエラーなし
- [x] ビルドが正常完了

## 発見された問題と修正

初期実装後、デスクトップルートで複数の問題が発見され修正されました。

### 第1フェーズ：初期エラーの修正（2025年12月30日 午前）

#### 問題1：TypeError: o is not a function

**症状：** デスクトップルート（`/desktop`）にアクセスすると白い画面とJavaScriptエラーが発生

**根本原因：**
1. **StatsBarWidget** - プロパティ名の不一致
   - `useSSEFeedsStats()` フックが返すプロパティ名が間違っていた
   - アクセス: `stats.feedCount`, `stats.totalArticles`, `stats.unsummarizedArticles`
   - 実際: `stats.feedAmount`, `stats.totalArticlesAmount`, `stats.unsummarizedArticlesAmount`
   - `undefined` に対して `.toLocaleString()` を呼び出してエラー発生

2. **UnreadFeedsWidget** - API レスポンス構造の誤解
   - アクセス: `feedsQuery.data?.results`
   - 実際: `feedsQuery.data?.data`
   - フィード配列が空になっていた

3. **FeedDetailModal** - 関数呼び出しの引数ミス
   - 呼び出し: `updateFeedReadStatusClient(normalizedUrl, true)`
   - 実際の署名: `updateFeedReadStatusClient(feedUrl: string)`
   - 第2引数は不要

**修正内容：**

```typescript
// StatsBarWidget.svelte - Svelte 5 パターンへ移行
const stats = useSSEFeedsStats();

// 修正前（Svelte 4 パターン + 間違ったプロパティ名）
$: feedCount = stats.feedCount;
$: totalArticles = stats.totalArticles;
$: unsummarizedArticles = stats.unsummarizedArticles;

// 修正後（Svelte 5 パターン + 正しいプロパティ名）
let feedCount = $derived(stats.feedAmount);
let totalArticles = $derived(stats.totalArticlesAmount);
let unsummarizedArticles = $derived(stats.unsummarizedArticlesAmount);
let summarizedArticles = $derived(totalArticles - unsummarizedArticles);
let isConnected = $derived(stats.isConnected);
```

```typescript
// UnreadFeedsWidget.svelte
// 修正前
let feeds = $derived(feedsQuery.data?.results ?? []);

// 修正後
let feeds = $derived(feedsQuery.data?.data ?? []);
```

```typescript
// FeedDetailModal.svelte
// 修正前
await updateFeedReadStatusClient(normalizedUrl, true);

// 修正後
await updateFeedReadStatusClient(normalizedUrl);
```

#### 問題2：Biomeの`useImportType`ルールによるアプリ破損

**症状：** bits-ui コンポーネント（Accordion, Sheet）が `import type` でインポートされていたため、ビルド時に削除されアプリが壊れる

**根本原因：**
- Biomeの `useImportType` ルールが型のみの import を強制
- しかし bits-ui コンポーネントは型情報とコンポーネント本体（値）の両方が必要
- `import type { Accordion as AccordionPrimitive }` でインポート → TypeScript コンパイル時に削除
- 実際には `<AccordionPrimitive.Root>` としてコンポーネント（値）を使用していた

**影響を受けたコンポーネント：**
- `accordion.svelte`, `accordion-item.svelte`, `accordion-trigger.svelte`, `accordion-content.svelte`
- `sheet.svelte`, `sheet-close.svelte`, `sheet-description.svelte`, `sheet-overlay.svelte`, `sheet-portal.svelte`, `sheet-title.svelte`, `sheet-trigger.svelte`

**修正内容：**

**1. Biome設定の更新** (`biome.json`)
```json
{
  "overrides": [
    {
      "includes": ["**/*.svelte"],
      "linter": {
        "rules": {
          "style": {
            "useConst": "off",
            "useImportType": "off"  // Svelteファイルで無効化
          }
        }
      }
    }
  ]
}
```

**2. 全コンポーネントの import を修正**
```typescript
// 修正前（間違い - コンポーネントが削除される）
// @biome-ignore lint/style/useImportType: AccordionPrimitive is used as a component
import type { Accordion as AccordionPrimitive } from "bits-ui";

// 修正後（正しい - コンポーネントが値として保持される）
import { Accordion as AccordionPrimitive } from "bits-ui";
```

**技術的背景：**
- Biomeの `useImportType` ルールは TypeScript の型のみの import を強制
- デコレータを使うフレームワーク（Angular, NestJS）や Svelte コンポーネントでは問題が発生
- bits-ui のようなコンポーネントライブラリでは、型情報（Props）と実際のコンポーネント（値）の両方をインポートする必要がある
- 参考: [Biome useImportType Documentation](https://biomejs.dev/linter/rules/use-import-type/)

**検証結果：**
- ✓ TypeScript コンパイルエラー解消
- ✓ Biome lint 警告なし
- ✓ デスクトップルートが正常にレンダリング
- ✓ Accordion/Sheet コンポーネントが正常に動作

---

### 第2フェーズ：TanStack Query 削除と Svelte 5 パターンへの移行（2025年12月30日 午後）

初期修正後も問題が継続したため、根本的なアーキテクチャ見直しを実施。

#### 問題3：TanStack Query は不要な依存関係だった

**発見経緯：**
ユーザーからのフィードバック：「TanStackQueryなんて入れていないはずです。前提認識が誤っているのでは？」

**根本原因：**
- プロジェクトに TanStack Query は必要なかった
- Svelte 5 Runes で十分にデータフェッチングを実装可能
- 不要な抽象化レイヤーが複雑さとバグを導入していた

**影響範囲：**
以下の8箇所で TanStack Query を使用していた：
1. `UnreadFeedsWidget.svelte` - `createQuery`
2. `RecapSummaryWidget.svelte` - `createQuery`
3. `FeedGrid.svelte` - `createInfiniteQuery`
4. `FeedDetailModal.svelte` - `createMutation`
5. `/routes/desktop/feeds/+page.svelte` - `createInfiniteQuery`
6. `/routes/desktop/feeds/viewed/+page.svelte` - `createInfiniteQuery`
7. `/routes/desktop/feeds/search/+page.svelte` - `createQuery`
8. `/routes/desktop/recap/+page.svelte` - `createQuery`

**修正内容：**

すべての TanStack Query 使用箇所をシンプルな Svelte 5 パターンに置き換え：

```typescript
// 修正前（TanStack Query）
const feedsQuery = createQuery({
  queryKey: ["unread-feeds"],
  queryFn: async () => {
    const result = await getFeedsWithCursorClient({ limit: 5 });
    return result;
  },
});
let feeds = $derived(feedsQuery.data?.results ?? []);

// 修正後（Svelte 5 ネイティブ）
let feeds = $state<RenderFeed[]>([]);
let isLoading = $state(true);
let error = $state<Error | null>(null);

onMount(async () => {
  try {
    isLoading = true;
    const result = await getFeedsWithCursorClient(undefined, 5);
    feeds = result.data ?? [];
  } catch (err) {
    error = err as Error;
  } finally {
    isLoading = false;
  }
});
```

**結果：**
- バンドルサイズ約50KB削減
- コードの可読性向上
- デバッグが容易になった
- ビルド警告がゼロに

#### 問題4：useSSEFeedsStats フックのリアクティビティ喪失

**症状：** SSE経由で更新された統計データが画面に反映されない

**根本原因：**
Svelte 5 では、`$state` 変数を直接オブジェクトとして返すと、初期値のみがキャプチャされる：

```typescript
// 問題のあるコード
function useSSEFeedsStats() {
  let feedAmount = $state(0);
  // ... SSEで値を更新
  return { feedAmount };  // ❌ 初期値の0のみキャプチャ
}
```

**修正内容：**

getter として返すことでリアクティビティを維持：

```typescript
// 修正後
function useSSEFeedsStats() {
  let feedAmount = $state(0);
  // ... SSEで値を更新
  return {
    get feedAmount() { return feedAmount; }  // ✅ 常に最新値を返す
  };
}
```

コンポーネント側でも `$derived` を使用：

```typescript
// StatsBarWidget.svelte
const stats = useSSEFeedsStats();

// デストラクチャリングは NG
// const { feedAmount } = stats;  // ❌ リアクティビティ喪失

// $derived を使用
let feedAmount = $derived(stats.feedAmount);  // ✅ リアクティブ
```

**参考：** [Svelte 5 - state_referenced_locally](https://svelte.dev/e/state_referenced_locally)

#### 問題5：API 関数呼び出しパターンの不一致

**症状：**
```
GET /api/v1/feeds/fetch/cursor?limit=20&cursor=%5Bobject+Object%5D 500
```

カーソルパラメータが `[object Object]` として送信される

**根本原因：**

API 関数は**位置引数**を期待しているが、**オブジェクト**として呼び出していた：

```typescript
// API 関数の定義
getFeedsWithCursorClient(cursor?: string, limit: number = 20)

// 間違った呼び出し
getFeedsWithCursorClient({ limit: 20, cursor })  // ❌ オブジェクト
```

**修正内容：**

すべての API 呼び出しを位置引数に統一：

```typescript
// 修正後
getFeedsWithCursorClient(cursor, 20)  // ✅ 位置引数
getReadFeedsWithCursorClient(cursor, 20)
searchFeedsClient(debouncedQuery, undefined, 50)
```

レスポンスプロパティ名も修正：

```typescript
// 修正前（camelCase - 存在しない）
result.nextCursor
result.hasMore

// 修正後（snake_case - API レスポンスに合わせる）
result.next_cursor
result.has_more
```

**影響を受けたファイル：**
- `FeedGrid.svelte`
- `UnreadFeedsWidget.svelte`
- `/routes/desktop/feeds/viewed/+page.svelte`
- `/routes/desktop/feeds/search/+page.svelte`

#### 問題6：Dialog コンポーネントの `DialogPrimitive is not defined` エラー

**症状：** `ReferenceError: DialogPrimitive is not defined`

**根本原因：**

Accordion、Sheet と同じ問題。Dialog コンポーネントが `import type` で導入されていたため実行時に存在しない。

**修正内容：**

8個の Dialog コンポーネントファイルで修正：

```typescript
// 修正前
import type { Dialog as DialogPrimitive } from "bits-ui";

// 修正後
import { Dialog as DialogPrimitive } from "bits-ui";
```

**修正したファイル：**
- `dialog.svelte`
- `dialog-close.svelte`
- `dialog-content.svelte`
- `dialog-description.svelte`
- `dialog-overlay.svelte`
- `dialog-portal.svelte`
- `dialog-title.svelte`
- `dialog-trigger.svelte`

---

### 最終検証結果

すべての修正完了後：

- ✅ ビルド成功、警告ゼロ
- ✅ デスクトップルート `/sv/desktop` が正常動作
- ✅ すべてのウィジェットがデータを表示
- ✅ 無限スクロールが機能
- ✅ 検索が動作
- ✅ モーダルが開閉
- ✅ SSE統計がリアルタイム更新
- ✅ ブラウザコンソールエラーなし
- ✅ TanStack Query 完全削除
- ✅ バンドルサイズ削減

### 今後の改善案

1. より良い体感パフォーマンスのためにローディングスケルトンを追加
2. ルートベースのコード分割を実装
3. オフラインサポート用のService Workerを追加（オプション）
4. SEOが重要になった場合のハイドレーション戦略を検討

## メタデータ

- **作成日：** 2025年12月30日
- **最終更新日：** 2025年12月30日（TanStack Query 削除、Svelte 5 パターンへ完全移行）
- **作成者：** 開発チーム
- **関連ADR：**
  - なし（初のデスクトップUI実装）
- **影響を受けるコンポーネント：**
  - alt-frontend-sv（すべてのデスクトップルート）
  - Svelte 5 Runes パターン
  - SvelteKitルーティング設定
  - Biome linter設定（`useImportType` ルール）
  - bits-ui コンポーネント（Accordion, Sheet, Dialog）
  - SSE フック（useSSEFeedsStats）
  - API クライアント関数

## 学んだ教訓

1. **シンプルさを優先する**：外部ライブラリを導入する前に、フレームワークのネイティブ機能で十分か検証すべき
2. **ユーザーフィードバックの重要性**：「TanStack Query なんて入れていないはず」という指摘が正しい方向への転換点となった
3. **Svelte 5 Runes の威力**：`$state`、`$derived`、`$effect` だけで複雑なデータフェッチングを実装可能
4. **getter パターン**：Svelte 5 でフックから `$state` を返す際は getter を使用してリアクティビティを維持
5. **型と値の区別**：コンポーネントライブラリは `import type` ではなく通常の `import` が必要
6. **API 契約の明確化**：位置引数とオブジェクト引数を混在させない、型定義で明確にする
