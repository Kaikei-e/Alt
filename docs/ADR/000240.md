# ADR-000240: TTS-Speaker 読み上げ文章量の拡大

## STATUS

Accepted（実装完了）

## CONTEXT

3-day Recap のジャンル詳細（summary + bullets）を TTS で読み上げる際、`tts-speaker` の 5000 文字ハードリミット（前処理後）に引っかかり、リクエストが `INVALID_ARGUMENT` で拒否されていた。

### 問題の構造

```
ユーザーが Recap ジャンルの読み上げを開始
  → フロントエンド: テキスト全文を 1 リクエストで送信
  → BFF → tts-speaker: preprocess_for_tts() で英語→カタカナ変換
    → "API" → "エーピーアイ" (3→6文字) で文字数が膨張
  → len(text) > 5000 → INVALID_ARGUMENT で拒否
  → フロントエンド: エラー表示
```

英語→カタカナ変換による文字数膨張（例: "RSS" → "アールエスエス"、"API" → "エーピーアイ"）のため、実質的な raw テキスト上限は 5000 よりさらに低かった。

### 技術的背景

- Kokoro-82M の `KPipeline` は文単位のジェネレータ方式であり、テキスト長に制限はない
- ストリーミング RPC (`SynthesizeStream`) は既に実装済み
- 制限値は unary `Synthesize`（全音声をメモリバッファ）と共通の 5000 がハードコードされていた

## DECISION MAKING

### 方針

unary とストリーミングで文字数制限を差別化し、クライアント側でもチャンキングを導入する。

| 項目 | unary `Synthesize` | streaming `SynthesizeStream` |
|------|-------------------|------------------------------|
| 制限値 | 5000（変更なし） | 30000（新設定） |
| 理由 | 全音声をメモリバッファ | 文単位ストリーミングでメモリ制約なし |

### unary の制限値を維持する理由

`Synthesize` は全音声を `numpy` 配列としてメモリ上に組み立ててから WAV 化する。24kHz float32 の場合、5 分の音声 ≈ 約 28MB。制限を引き上げるとメモリ消費が線形に増大するため、unary は短文専用のまま維持する。

### 30000 の根拠

- 3-day Recap のジャンル詳細（5 ジャンル × summary + 3-5 bullets）は最大約 8000-12000 文字
- 英語→カタカナ変換後の膨張率は最大 2-3 倍
- 安全マージンを含めて 30000 に設定
- 環境変数 `TTS_MAX_STREAM_TEXT_LENGTH` でオーバーライド可能

### クライアント側チャンキングの導入理由

フロントエンドに既存の `splitTextForTts()` が実装済みだが `useTtsPlayback` では未使用だった。クライアント側でも文境界でチャンク分割することで、将来的に 30000 を超えるテキストにも対応できる防御的設計とした。

## RESULTS

### 変更ファイル一覧

| ファイル | 変更内容 |
|---------|---------|
| `tts-speaker/tts_speaker/infra/config.py` | `tts_max_stream_text_length` フィールド追加（デフォルト 30000） |
| `tts-speaker/tts_speaker/app/connect_service.py` | `MAX_TEXT_LENGTH` 定数抽出、`synthesize_stream()` の制限を config から取得、ログ出力追加 |
| `tts-speaker/tests/unit/test_config.py` | 新設定のデフォルト値・環境変数オーバーライドテスト |
| `tts-speaker/tests/unit/test_connect_service.py` | ストリーミング長テキスト受理・拒否・前処理テスト 3 件追加 |
| `alt-frontend-sv/src/lib/utils/audio.ts` | `TTS_MAX_CHARS` を 5000 → 30000 に引き上げ |
| `alt-frontend-sv/src/lib/utils/audio.test.ts` | 分割境界テストを 30000 基準に更新、30000 超分割テスト追加 |
| `alt-frontend-sv/src/lib/hooks/useTtsPlayback.svelte.ts` | `splitTextForTts()` でチャンク分割後、チャンクごとに `synthesizeSpeechStream()` を呼び出す |
| `alt-frontend-sv/src/lib/hooks/useTtsPlayback.test.ts` | 複数チャンク再生テスト追加 |

### サーバー側の変更

`synthesize()` と `synthesize_stream()` の制限値を差別化：

```python
# connect_service.py
MAX_TEXT_LENGTH = 5000  # unary 用（変更なし）

# synthesize() — unary
if len(text) > MAX_TEXT_LENGTH:
    raise ConnectError(...)

# synthesize_stream() — ストリーミング
stream_max = self._settings.tts_max_stream_text_length  # デフォルト 30000
if len(text) > stream_max:
    raise ConnectError(...)
logger.info("Text length: %d chars (after preprocess)", len(text))
```

### フロントエンド側の変更

`play()` 内で `splitTextForTts()` を導入し、チャンクごとにストリーミング RPC を呼び出す：

```typescript
// useTtsPlayback.svelte.ts
const chunks = splitTextForTts(text);
for (const textChunk of chunks) {
  if (cancelled) break;
  const stream = synthesizeSpeechStream(transport, {
    text: textChunk, ...options
  });
  for await (const chunk of stream) {
    // 既存の再生ロジック（変更なし）
  }
}
```

### テスト結果

- tts-speaker: `uv run pytest tests/unit/` — 60 テスト全 PASS
- alt-frontend-sv: `npx vitest run --project=server` — 370 テスト全 PASS

## PROS

1. **Recap ジャンル詳細の全文読み上げが可能に** — 5000 文字制限による拒否が解消
2. **unary の安全性を維持** — メモリバッファ方式の unary は 5000 制限のまま
3. **運用時の調整が容易** — `TTS_MAX_STREAM_TEXT_LENGTH` 環境変数でオーバーライド可能
4. **防御的なクライアント設計** — フロントエンドのチャンキングにより、制限を超えるテキストでも文境界で分割して再生
5. **既存コードの再利用** — `splitTextForTts()` と `synthesizeSpeechStream()` を活用し、新規コード量を最小化

## CONS, TRADEOFF

1. **チャンク境界での微小な再生遅延** — チャンク間で次のストリームを開始するため、ミリ秒単位のギャップが発生しうる。実用上は知覚されにくい
2. **前処理後の文字数で制限判定** — raw テキスト長とのギャップがユーザーにとって直感的でない。ただし前処理後の方がリソース消費と正確に相関するため妥当

## APPENDIX

- 既存実装: `splitTextForTts()` — 句点（。）・改行境界でのテキスト分割ロジック
- 既存実装: `synthesizeSpeechStream()` — Connect-RPC ストリーミングクライアント
- 既存実装: `preprocess_for_tts()` — 英語→カタカナ変換パイプライン（変更なし）
- 既存実装: `TTSPipeline.synthesize_stream()` — Kokoro ストリーミング生成（変更なし）
