# alt-backend: 記事要約保存時の ON CONFLICT 制約不一致エラー修正

## ADR's STATUS

Accepted

## CONTEXT

### 背景

記事要約ボタン押下時に HTTP 524 エラーが発生。ログ調査により、要約自体は正常に生成されているが、データベースへの保存が失敗していることが判明。

### エラーログ

```
ERROR: there is no unique or exclusion constraint matching the ON CONFLICT specification (SQLSTATE 42P10)
```

### 根本原因

マイグレーション `20260108000000` で `user_id` カラムが追加され、ユニーク制約が変更された:

| 項目 | 変更前 | 変更後 |
|------|--------|--------|
| ユニーク制約 | `article_id` 単独 | `(article_id, user_id)` 複合 |
| 設計意図 | 記事ごとに1つの要約 | ユーザーごとに要約を管理（マルチテナント対応） |

しかし、`SaveArticleSummary` 関数は `ON CONFLICT (article_id)` を使用しており、存在しない単独制約を参照していた。

```
[マイグレーション]
  └─ 複合制約 (article_id, user_id) を作成
  └─ 単独制約 idx_article_summaries_article_id を削除

[コード]
  └─ ON CONFLICT (article_id) ← 存在しない制約を参照
  └─ PostgreSQL エラー: SQLSTATE 42P10
```

## DECISION MAKING

### 検討したアプローチ

| Option | 内容 | 評価 |
|--------|------|------|
| A: コード修正 | `ON CONFLICT (article_id, user_id)` に変更 | 採用 |
| B: マイグレーション追加 | 単独の `article_id` 制約を追加 | 不採用 |

### 採用理由

**Option A（コード修正）を採用**:
1. マイグレーションの設計意図（マルチテナント対応）を維持
2. ユーザーごとの要約管理が可能
3. 既存のスキーマ設計に整合

**Option B を不採用にした理由**:
- 単独制約を追加すると、同一記事に対して複数ユーザーの要約が保存できなくなる
- マルチテナント対応の意図が無効化される

## RESULTS, EFFECTS

### 修正ファイル

| ファイル | 変更内容 |
|----------|----------|
| `driver/alt_db/save_article_summary_driver.go` | `userID` パラメータ追加、ON CONFLICT 修正 |
| `connect/v2/feeds/handler.go` | `userID` を渡すように修正 |
| `rest/rest_feeds/summarization/stream_handlers.go` | `userID` を渡すように修正 |
| `rest/rest_feeds/summarization/request_handlers.go` | `userID` を渡すように修正 |
| `rest/rest_feeds/summary_fetch.go` | `userID` を渡すように修正 |

### 主な変更

#### SaveArticleSummary 関数シグネチャ

```go
// Before
func (r *AltDBRepository) SaveArticleSummary(ctx context.Context, articleID string, articleTitle string, summary string) error

// After
func (r *AltDBRepository) SaveArticleSummary(ctx context.Context, articleID string, userID string, articleTitle string, summary string) error
```

#### SQL クエリ

```sql
-- Before
INSERT INTO article_summaries (article_id, article_title, summary_japanese)
VALUES ($1, $2, $3)
ON CONFLICT (article_id)
DO UPDATE SET ...

-- After
INSERT INTO article_summaries (article_id, user_id, article_title, summary_japanese)
VALUES ($1, $2, $3, $4)
ON CONFLICT (article_id, user_id)
DO UPDATE SET ...
```

#### 呼び出し元の修正

各ハンドラーで `domain.GetUserFromContext(ctx)` または `middleware.GetUserContext(ctx)` を使用してユーザーコンテキストを取得し、`userID` を渡すように修正。

### 検証結果

- ビルド: パス
- ユニットテスト: 全件パス
- コンテナヘルスチェック: healthy

### PROS

1. **スキーマ整合性**: マイグレーションの設計意図と整合
2. **マルチテナント対応**: ユーザーごとの要約管理が可能
3. **最小限の変更**: 関数シグネチャと呼び出し元のみ修正
4. **後方互換性**: 既存データへの影響なし

### CONS, TRADEOFF

1. **呼び出し元の修正**: 5ファイルの修正が必要だった
2. **認証必須**: 要約保存には認証済みユーザーが必要（設計上は妥当）

## APPENDIX

### デプロイ手順

```bash
# リビルド・再起動
docker compose -f compose/compose.yaml -p alt build alt-backend
docker compose -f compose/compose.yaml -p alt up -d alt-backend

# ヘルスチェック
curl http://localhost:9000/v1/health
```

### 検証方法

1. フロントエンドで記事要約ボタンを押す
2. alt-backend のログで「Article summary saved successfully」を確認
3. DB でレコードが正しく保存されていることを確認

```bash
# ログ確認
docker logs alt-alt-backend-1 --tail=50 | grep -i summary

# DB 確認
docker exec -it alt-db-1 psql -U postgres -d alt_dev -c \
  "SELECT id, article_id, user_id, created_at FROM article_summaries ORDER BY created_at DESC LIMIT 5;"
```

### 関連マイグレーション

- `20260108000000`: `user_id` カラム追加、複合ユニーク制約 `(article_id, user_id)` 作成
