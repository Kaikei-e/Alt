# news-creator / pre-processor キュー飽和問題の解決

## ADR's STATUS

Accepted (実装完了)

## CONTEXT

### 問題点

要約処理パイプラインにおいて、LLM 推論キューが飽和し、リクエストが長時間滞留する問題が発生。

- **queue_wait_time が 3,668 秒（約 61 分）** に達し、リクエストがキュー内で 1 時間以上待機
- RT queue size: 29-30 件、BE queue: 5-7 件が常時飽和状態
- LLM 推論は 1 リクエストあたり 2-3 分かかるが、並列度は 2

### 根本原因分析

| # | 原因 | 影響 |
|---|------|------|
| 1 | キュー深度が無制限 | `HybridPrioritySemaphore` に上限なし。リクエストがメモリに際限なく蓄積 |
| 2 | バックプレッシャーなし | pre-processor が news-creator のキュー状態を知らずにリクエストを送り続ける |
| 3 | リトライが毎回セマフォ再取得 | `generate()` 呼び出し毎にセマフォ release → re-acquire。1 記事 3 リトライ = キューに 3 回並び直し |
| 4 | HTTP 429 未実装 | キュー満杯でも news-creator が全リクエストを受け入れてしまう |

### 方針

3 レイヤーに分けた段階的な対策を TDD-first で実装:

1. **Layer 1**: news-creator 側でキュー深度制限 & HTTP 429 レスポンス
2. **Layer 2**: news-creator 側でリトライ中のセマフォスロット保持
3. **Layer 3**: pre-processor 側でバックプレッシャー対応（429 検出 + 指数バックオフ）

## DECISION MAKING

### Layer 1: キュー深度制限 & HTTP 429

#### QueueFullError & max_queue_depth

`HybridPrioritySemaphore` にキュー深度上限を導入。`acquire()` 呼び出し時に RT + BE のキュー合計が上限を超えていれば `QueueFullError` を送出。

```python
class QueueFullError(Exception):
    """Raised when the queue depth limit is exceeded."""
    pass

# acquire() 内
if self._max_queue_depth > 0:
    current_depth = len(self._rt_queue) + len(self._be_queue)
    if current_depth >= self._max_queue_depth and self._semaphore.locked():
        raise QueueFullError(
            f"Queue depth {current_depth} exceeds max {self._max_queue_depth}"
        )
```

デフォルト値は `MAX_QUEUE_DEPTH=20`（環境変数で変更可能）。

#### HTTP 429 レスポンス

ハンドラで `QueueFullError` を catch し、429 を返却:

```python
except QueueFullError as exc:
    return JSONResponse(
        status_code=429,
        content={"error": "queue full"},
        headers={"Retry-After": "30"},
    )
```

#### キューステータスエンドポイント

`GET /queue/status` で現在のキュー状態をモニタリング可能に:

```json
{
  "rt_queue": 0,
  "be_queue": 0,
  "total_slots": 2,
  "available_slots": 1,
  "accepting": true,
  "max_queue_depth": 20
}
```

### Layer 2: リトライ中セマフォスロット保持

#### 問題

既存の実装では、リトライループ内で毎回 `generate()` を呼び出し、その都度セマフォを取得・解放していた。キューが飽和している場合、各リトライで数十分の待ち時間が発生。

#### 解決: hold_slot() + generate_raw()

`LLMProviderPort` に 2 つの新メソッドを追加:

```python
@asynccontextmanager
async def hold_slot(self, is_high_priority: bool = False):
    """セマフォスロットを保持するコンテキストマネージャ"""
    wait_time = await self._semaphore.acquire(high_priority=is_high_priority)
    try:
        yield wait_time, cancel_event, task_id
    finally:
        self._semaphore.release(was_high_priority=is_high_priority)

async def generate_raw(self, prompt, cancel_event=None, task_id=None, **kwargs):
    """セマフォ取得なしで直接 LLM を呼び出す（hold_slot 内で使用）"""
```

Usecase のリトライループを改修:

```python
# Before: リトライ毎にセマフォ再取得
for attempt in range(max_retries + 1):
    response = await self.llm_provider.generate(prompt, ...)

# After: セマフォを 1 回だけ取得し、リトライは内部で完結
async with self.llm_provider.hold_slot(is_high_priority=...) as (wait_time, ...):
    for attempt in range(max_retries + 1):
        response = await self.llm_provider.generate_raw(prompt, ...)
```

合わせて `MAX_REPETITION_RETRIES` のデフォルトを 3 → 2 に変更。

### Layer 3: pre-processor バックプレッシャー対応

#### ErrServiceOverloaded の伝播

Go 側で `domain.ErrServiceOverloaded` を定義し、driver → repository → service → handler の各レイヤーで `errors.Is()` チェーンにより伝播:

```
driver (429 検出) → repository (透過) → SummarizeQueueWorker (残ジョブスキップ) → jobHandler (指数バックオフ)
```

#### 指数バックオフ

`runSummarizeQueueLoop` のティッカーループで、`ErrServiceOverloaded` 受信時にバックオフを適用:

```go
const (
    normalInterval = 10 * time.Second
    initialBackoff = 30 * time.Second
    maxBackoff     = 5 * time.Minute
)

// ErrServiceOverloaded 時: ticker.Reset(backoff) で間隔を拡大
// 成功時: ticker.Reset(normalInterval) で通常に復帰
```

バックオフ系列: 30s → 60s → 120s → 240s → 300s (上限)

## RESULTS, EFFECTS

### 変更ファイル一覧

| サービス | ファイル | 変更内容 |
|----------|----------|----------|
| news-creator | `gateway/hybrid_priority_semaphore.py` | `QueueFullError`, `max_queue_depth`, `queue_status()` |
| news-creator | `gateway/ollama_gateway.py` | `hold_slot()`, `generate_raw()`, `max_queue_depth` 接続 |
| news-creator | `port/llm_provider_port.py` | 抽象メソッド `generate_raw()`, `hold_slot()` 追加 |
| news-creator | `handler/summarize_handler.py` | `QueueFullError` → HTTP 429 変換 |
| news-creator | `handler/health_handler.py` | `GET /queue/status` エンドポイント追加 |
| news-creator | `config/config.py` | `MAX_QUEUE_DEPTH`, `MAX_REPETITION_RETRIES` デフォルト変更 |
| news-creator | `usecase/summarize_usecase.py` | `hold_slot` + `generate_raw` によるリトライ改修 |
| pre-processor | `domain/errors.go` | `ErrServiceOverloaded` 定義 |
| pre-processor | `driver/summarizer_api.go` | HTTP 429 検出（通常 & ストリーミング） |
| pre-processor | `repository/external_api_repository.go` | `ErrServiceOverloaded` 透過 |
| pre-processor | `service/summarize_queue_worker.go` | 429 時に残ジョブスキップ |
| pre-processor | `handler/job_handler.go` | 指数バックオフ（30s-5min） |

### テスト追加

| サービス | テストファイル | テスト数 |
|----------|---------------|---------|
| news-creator | `tests/gateway/test_hybrid_priority_semaphore.py` | +5 |
| news-creator | `tests/gateway/test_ollama_gateway.py` | +4 |
| news-creator | `tests/handler/test_summarize_handler.py` | +2 (新規) |
| news-creator | `tests/handler/test_health_handler.py` | +2 |
| news-creator | `tests/usecase/test_summarize_usecase.py` | +3 (新規) |
| pre-processor | `driver/summarizer_api_test.go` | +1 |
| pre-processor | `service/summarize_queue_worker_test.go` | +1 |
| pre-processor | `handler/job_handler_test.go` | +1 |

### 動作確認

- `uv run pytest tests/ -v`: 208 テスト全通過
- `go test ./...`: 全パッケージ通過
- コンテナ再ビルド・起動後:
  - `GET /queue/status` が `max_queue_depth: 20`, `accepting: true` を返却
  - news-creator, pre-processor ともに healthy ステータス
  - 要約処理が正常に実行されることをログで確認

### PROS

1. **キュー飽和の防止**: `max_queue_depth` により無制限蓄積を防止。超過時は即座に 429 を返却
2. **リトライ効率の改善**: セマフォスロット保持により、リトライ時のキュー再待機を排除
3. **段階的バックオフ**: pre-processor が 429 を検知し自動的に送信レートを下げることで、下流の過負荷を回避
4. **可観測性の向上**: `/queue/status` エンドポイントによりキュー状態のリアルタイム監視が可能
5. **自動復旧**: バックオフは成功時に自動的にリセットされ、正常復帰に人手不要

### CONS, TRADEOFF

1. **429 発生中のジョブ遅延**: バックオフ中は後続ジョブの処理が 30 秒-5 分遅延する
2. **max_queue_depth のチューニング**: 環境に応じた適切な値の選定が必要（デフォルト 20）
3. **hold_slot による占有時間増加**: リトライ中もスロットを保持するため、他リクエストの待機時間が増える可能性がある（ただしリトライ回数を 3→2 に削減して緩和）

## APPENDIX

### 環境変数

| 変数名 | デフォルト | 説明 |
|--------|-----------|------|
| `MAX_QUEUE_DEPTH` | 20 | セマフォキューの最大深度（0 = 無制限） |
| `MAX_REPETITION_RETRIES` | 2 | LLM 要約の最大リトライ回数（旧デフォルト: 3） |

### バックオフ系列

```
正常時:        10s間隔で ProcessQueue
429 初回:      30s 後に再試行
429 連続:      60s → 120s → 240s → 300s (上限)
成功復帰時:    即座に 10s 間隔に戻る
```

### 関連 ADR

- ADR-000184: recap-worker 3-day Recap 自動バッチデーモン化（キュー飽和が発生した直接的契機）
