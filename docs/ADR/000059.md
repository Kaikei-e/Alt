# ADR-000059: 安全なデータベースマイグレーションパターン

## Status
Accepted

## Context
2026-01-08のマイグレーション（article_summariesへのuser_id追加）で全データが消失。
原因は単一トランザクション内でのDDL + DML混合と、不完全なデータ検証。

## Decision

### 1. Expand-Contract パターンの採用

データを伴うスキーマ変更は3段階に分割する：

**Phase 1: Expand（スキーマ拡張のみ）**
```sql
-- マイグレーション1: カラム追加のみ（NULLable）
ALTER TABLE article_summaries ADD COLUMN user_id UUID;
```

**Phase 2: Migrate（データ移行）**
```sql
-- マイグレーション2: データバックフィル
-- 必ず事前検証を含める
DO $$
DECLARE
    orphaned_count INTEGER;
    total_count INTEGER;
BEGIN
    -- 検証: orphanedレコードの数を確認
    SELECT COUNT(*) INTO orphaned_count
    FROM article_summaries s
    WHERE NOT EXISTS (SELECT 1 FROM articles a WHERE a.id = s.article_id);

    SELECT COUNT(*) INTO total_count FROM article_summaries;

    RAISE NOTICE 'Total: %, Orphaned: %', total_count, orphaned_count;

    -- orphanedが全体の10%を超える場合は警告
    IF orphaned_count > total_count * 0.1 THEN
        RAISE EXCEPTION 'Too many orphaned records: % out of %', orphaned_count, total_count;
    END IF;
END $$;

-- データ更新
UPDATE article_summaries s
SET user_id = a.user_id
FROM articles a
WHERE s.article_id = a.id
  AND s.user_id IS NULL;
```

**Phase 3: Contract（制約追加）**
```sql
-- マイグレーション3: 制約追加（データ移行完了後）
-- 再度検証
DO $$
DECLARE
    null_count INTEGER;
BEGIN
    SELECT COUNT(*) INTO null_count FROM article_summaries WHERE user_id IS NULL;
    IF null_count > 0 THEN
        RAISE EXCEPTION 'Cannot add NOT NULL constraint: % records have NULL user_id', null_count;
    END IF;
END $$;

ALTER TABLE article_summaries ALTER COLUMN user_id SET NOT NULL;
CREATE UNIQUE INDEX CONCURRENTLY idx_article_summaries_article_user ON article_summaries (article_id, user_id);
```

### 2. 必須チェックリスト

マイグレーション作成時：
- [ ] DRY RUN（`atlas migrate apply --dry-run`）で影響範囲を確認
- [ ] 本番データのサンプルでテスト
- [ ] ロールバック手順を文書化
- [ ] バックアップ確認

破壊的変更（DELETE, DROP）を含む場合：
- [ ] 影響を受けるレコード数を事前に計算
- [ ] 閾値を超える場合は例外をスロー
- [ ] 本番適用前にステージングで検証

### 3. 外部キー制約の追加

orphanedデータを防ぐため、適切な外部キー制約を追加：

```sql
-- 将来のマイグレーションで追加
ALTER TABLE article_summaries
ADD CONSTRAINT fk_article_summaries_article
FOREIGN KEY (article_id) REFERENCES articles(id) ON DELETE CASCADE;

ALTER TABLE article_summaries
ADD CONSTRAINT fk_article_summaries_user
FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE;
```

### 4. Atlas Lintの活用

CI/CDパイプラインで破壊的変更を検出：

```yaml
# .github/workflows/migration-lint.yml
- name: Lint migrations
  run: |
    atlas migrate lint \
      --dev-url "postgres://..." \
      --dir "file://migrations-atlas/migrations" \
      --latest 1
```

## Consequences

### Positive
- データ消失リスクの大幅な低減
- マイグレーション失敗時の影響範囲の限定
- 本番適用前の問題検出

### Negative
- マイグレーション作成の工数増加
- 複数回のデプロイが必要になる場合がある

## References
- [Strategies for Reliable Schema Migrations | Atlas](https://atlasgo.io/blog/2024/10/09/strategies-for-reliable-migrations)
- [Zero Downtime Schema Migrations | Xata](https://xata.io/blog/zero-downtime-schema-migrations-postgresql)
- [strong_migrations | GitHub](https://github.com/ankane/strong_migrations)
