# UMAP 近傍探索バックエンドの FAISS 移行

## ADR'S STATUS

Accepted

## CONTEXT

### 背景

recap-subworker のクラスタリングパイプラインでは、UMAP による次元削減後に HDBSCAN でクラスタリングを行っている。UMAP は内部で pynndescent ライブラリを使用して k-最近傍探索を実行する。

### 問題

1. **整数オーバーフロー**: pynndescent 0.6.0 で `index XXXXXXXXX is out of bounds for axis 1` エラーが発生
2. **不安定性**: 特定のデータサイズ・次元数の組み合わせで再現性のない失敗
3. **デバッグ困難**: numba JIT コンパイル内部でのエラーのため原因特定が困難

### 実装前の状態

- 近傍探索: pynndescent（UMAP のデフォルト）
- 失敗率: 特定条件下で高頻度に発生
- エラーハンドリング: なし（例外で処理中断）

## DECISION MAKING

### 決定

pynndescent を FAISS に置き換え、事前計算した k-NN グラフを UMAP に渡す。

#### アーキテクチャ

```
Before:
  embeddings → UMAP (pynndescent) → reduced → HDBSCAN

After:
  embeddings → FAISS (k-NN) → knn_graph → UMAP (precomputed) → reduced → HDBSCAN
```

#### 実装詳細

```python
def compute_knn_faiss(embeddings: np.ndarray, n_neighbors: int) -> tuple[np.ndarray, np.ndarray]:
    """FAISS による k-最近傍計算"""
    import faiss

    # L2 正規化で cosine 類似度を内積に変換
    embeddings_norm = embeddings.astype(np.float32).copy()
    faiss.normalize_L2(embeddings_norm)

    # IndexFlatIP: 正規化後の内積 = cosine 類似度
    index = faiss.IndexFlatIP(embeddings.shape[1])
    index.add(embeddings_norm)

    similarities, indices = index.search(embeddings_norm, n_neighbors)
    distances = np.clip(1.0 - similarities, 0.0, 2.0)

    return indices, distances
```

```python
# UMAP への適用
knn_indices, knn_dists = compute_knn_faiss(embeddings, n_neighbors)
reducer = UMAP(
    precomputed_knn=(knn_indices, knn_dists),
    ...
)
reduced = reducer.fit_transform(embeddings)
```

#### 技術選定

| 項目 | 選定 | 理由 |
|------|------|------|
| ライブラリ | FAISS (faiss-cpu) | Meta 製、安定性、広範な採用実績 |
| インデックス | IndexFlatIP | 厳密検索、小〜中規模データに最適 |
| 距離関数 | Cosine (via IP) | 埋め込みベクトルに適切 |
| 精度 | Exact | 近似検索不要なデータサイズ |

#### 代替案の検討

| ライブラリ | 利点 | 欠点 |
|-----------|------|------|
| pynndescent | UMAP 標準 | 整数オーバーフローバグ |
| NMSLIB (HNSW) | CPU 最速 | メンテナンス状況 |
| Annoy | 軽量 | 精度が FAISS より低い |
| hnswlib | 高速 | FAISS より採用実績少 |

## RESULTS, EFFECTS

### 変更ファイル

| ファイル | 種別 | 内容 |
|----------|------|------|
| `recap-subworker/pyproject.toml` | 修正 | faiss-cpu 依存追加 |
| `recap-subworker/recap_subworker/services/clusterer.py` | 修正 | FAISS k-NN 実装、UMAP 統合 |

### 効果

- pynndescent の整数オーバーフローバグを回避
- 安定したクラスタリング実行
- エラー時のフォールバック（UMAP スキップ）

### PROS

1. **安定性**: FAISS は広範にテストされた成熟ライブラリ
2. **互換性**: UMAP の `precomputed_knn` API で透過的に統合
3. **拡張性**: 将来的に GPU (faiss-gpu) への移行が容易
4. **フォールバック**: FAISS 失敗時は UMAP なしで HDBSCAN 実行

### CONS, TRADEOFF

1. **依存関係増加**: faiss-cpu パッケージの追加
2. **transform 不可**: precomputed_knn 使用時は新規データの transform が不可（recap では不要）
3. **メモリ**: 厳密検索のためインデックスがメモリに乗る（現状のデータサイズでは問題なし）

## APPENDIX

### 参考資料

- [UMAP Precomputed KNN](https://umap-learn.readthedocs.io/en/latest/precomputed_k-nn.html)
- [FAISS Wiki](https://github.com/facebookresearch/faiss/wiki)
- [ANN-Benchmarks](https://ann-benchmarks.com/)

### UMAP 警告について

```
UserWarning: precomputed_knn[2] (knn_search_index) is not an NNDescent object:
transforming new data with transform will be unavailable.
```

この警告は想定内。recap パイプラインでは `transform()` を使用しないため影響なし。
