# ADR-000224: Svelte 5 $effect 内 isLoading ガード除去による初回ローディングスピナー永続表示バグの修正

## STATUS

Accepted（実装完了・コンテナデプロイ・動作確認済み）

## CONTEXT

ADR-221 で `bind:this` + `$effect` パターンへ移行した後、Desktop 版の複数ページで初回のローディングスピナーが永続表示されるバグが発生した。

### 問題の詳細

infinite scroll 用の `$effect` 内で `isLoading` を短絡評価のガードとして使用していた:

```typescript
$effect(() => {
    if (!loadMoreTrigger || isLoading) return;
    // IntersectionObserver のセットアップ
});
```

Svelte 5 の `$effect` は**実行時に実際に読まれたリアクティブ変数のみ**を依存として追跡する。JavaScript の `||` 短絡評価により、`loadMoreTrigger` が `undefined`（初回実行時）の場合、`isLoading` は評価されず依存に登録されない。

この仕様により、以下のタイミング問題が発生した:

1. 初回実行: `loadMoreTrigger` が `undefined` → 短絡評価で `isLoading` は未読 → 依存は `[loadMoreTrigger]` のみ
2. データ取得完了 → `isLoading = false` → テンプレート更新 → `bind:this` が `loadMoreTrigger` をセット
3. `loadMoreTrigger` 変化 → `$effect` 再実行 → 今度は `isLoading` も読まれ依存に追加
4. 以降、`isLoading` の変化で `$effect` が再トリガーされ、`loadMoreTrigger` が中間状態で observer セットアップに失敗するパスが生じる

### 制約

- Svelte 5 Runes のリアクティビティモデルに準拠すること
- infinite scroll の動作を維持すること
- 全プラットフォーム（Desktop / Mobile レスポンシブ）で同一の修正パターンを適用すること

## DECISION MAKING

### isLoading ガードは冗長である

テンプレート構造を分析すると、`loadMoreTrigger` に `bind:this` されている `<div>` は全て `{:else}` ブロック内に配置されている:

```svelte
{#if isLoading}
    <!-- スピナー表示 -->
{:else}
    <!-- フィード一覧 -->
    <div bind:this={loadMoreTrigger}>...</div>
{/if}
```

つまり:
- `loadMoreTrigger` が DOM に存在する ⟺ `isLoading === false`
- `loadMoreTrigger` が `undefined` ⟺ `isLoading === true`（またはデータ未取得）

したがって `!loadMoreTrigger` のチェックのみで `isLoading` のガードは暗黙的に満たされる。

### 修正方針

`$effect` から `isLoading` ガードを除去し、`loadMoreTrigger` のみを条件とする。これにより:

1. 依存追跡が `loadMoreTrigger` の 1 変数に単純化される
2. 短絡評価による依存追跡の不確定性が排除される
3. `isLoading` 変化による不要な `$effect` 再実行が防止される

## RESULTS

### 変更ファイル

| ファイル | 変更内容 |
|---------|---------|
| `alt-frontend-sv/src/routes/desktop/feeds/search/+page.svelte` | `$effect` 内の `isLoading` ガード除去 |
| `alt-frontend-sv/src/lib/components/desktop/feeds/FeedGrid.svelte` | 同上 |
| `alt-frontend-sv/src/routes/desktop/feeds/viewed/+page.svelte` | 同上 |
| `alt-frontend-sv/src/routes/(app)/feeds/viewed/+page.svelte` | `isLoading` ガード除去（`!isDesktop` ガードは維持） |

### 変更パターン

```typescript
// Before
$effect(() => {
    if (!loadMoreTrigger || isLoading) return;
    // ...
});

// After
$effect(() => {
    if (!loadMoreTrigger) return;
    // ...
});
```

`(app)/feeds/viewed/+page.svelte` はレスポンシブ対応のため `!isDesktop` ガードを維持:

```typescript
// Before
if (!loadMoreTrigger || isLoading || !isDesktop) return;

// After
if (!loadMoreTrigger || !isDesktop) return;
```

### 検証結果

| 検証項目 | 結果 |
|---------|------|
| `svelte-check` | 0 errors, 0 warnings |
| Unit tests (`page.search.spec.ts`) | 17/17 pass |
| `GET /api/health` | `{"status":"ok"}` |
| コンテナ再ビルド・起動 | 正常 |

## PROS

1. Svelte 5 の `$effect` 依存追跡の仕様に適合した、予測可能なリアクティビティが実現された
2. 全 4 ファイルで統一されたパターンとなり、保守性が向上した
3. テンプレート構造（`{#if isLoading}` / `{:else}`）による暗黙的なガードを活用することで、明示的な冗長チェックを排除した
4. `$effect` の依存が最小化され、不要な再実行が防止された

## CONS, TRADEOFF

1. `isLoading` ガードが明示的でなくなるため、テンプレート構造を変更する際に `loadMoreTrigger` の描画条件との整合性を意識する必要がある。将来テンプレート構造を変更し `loadMoreTrigger` が `isLoading === true` 時にも DOM に存在するようになった場合、ガードの再追加が必要になる
2. Svelte 5 の `$effect` 依存追跡は実行パスに依存するという仕様知識がチーム内で共有されている必要がある

## APPENDIX

- Svelte 5 の `$effect` は実行時に読み取られたリアクティブ変数を動的に追跡する（静的解析ではない）
- JavaScript の短絡評価（`||`, `&&`）により、条件の前半で `return` した場合、後半の変数は依存に登録されない
- `bind:this` による `$state` 更新は DOM 更新後に非同期で発生し、Svelte 5 のスケジューラによってバッチ処理される
- 関連 ADR: ADR-221（`bind:this` + `$effect` パターン移行）
