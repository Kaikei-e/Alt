# Buf Connect-RPCの導入とREST APIからの段階的移行

## ステータス

**採択・Phase 1実装完了（Accepted & Phase 1 Implemented）** - 2025年12月30日

## コンテキスト

### 現状の課題

alt-frontend-sv と alt-backend 間の通信は現在REST API（Echo framework）を使用している。以下の課題が顕在化していた：

1. **型安全性の欠如**
   - フロントエンドとバックエンド間でAPIスキーマが分離
   - TypeScriptの型定義を手動で維持する必要がある
   - 型の不整合によるランタイムエラーのリスク

2. **コード生成の不在**
   - APIクライアントを手動で実装
   - エンドポイント追加のたびにボイラープレートコードが増加
   - リクエスト/レスポンス型の二重管理

3. **将来的な拡張性**
   - ストリーミングRPC（Server-Sent Events以外）のサポートが限定的
   - gRPC互換性がない
   - マイクロサービス間通信の標準化が困難

### 技術選定の背景

**検討した代替案：**

| 選択肢 | メリット | デメリット |
|--------|----------|------------|
| REST継続 | 変更不要、学習コストゼロ | 型安全性なし、コード生成なし |
| gRPC | 高性能、成熟したエコシステム | ブラウザ直接通信不可、プロキシ必要 |
| tRPC | TypeScript特化、型安全 | Go対応なし、フロントエンド限定 |
| **Connect-RPC** | 型安全、Go/TS両対応、HTTP/1.1互換 | 比較的新しい技術 |

**Connect-RPCを選択した理由：**

- Protocol Buffersによる型定義の一元管理
- Go（backend）とTypeScript（frontend）両方のコード生成
- HTTP/1.1/HTTP/2両対応でブラウザ直接通信可能
- gRPC互換性（将来のマイクロサービス統合に有利）
- Bufエコシステムによる開発体験の向上

## 意思決定

### 決定1: 並行運用による段階的移行

既存のREST API（v1）を維持しながら、新規Connect-RPC API（v2）を追加する。

```
alt-backend
├── REST API (Echo)     → Port 9000 (/v1/*)  # 既存維持
└── Connect-RPC         → Port 9101          # 新規追加
```

**理由：**
- ゼロダウンタイム移行が可能
- 問題発生時のロールバックが容易
- エンドポイント単位での段階的な移行

### 決定2: 専用ポートでのConnect-RPCサーバー運用

Connect-RPCサーバーをポート9101で独立運用する。

**検討した代替案：**
1. 同一ポートでパス分離（`/v2/*`）
2. Vanguard-Goによる自動トランスコーディング
3. **専用ポート（9101）** ← 採用

**採用理由：**
- 既存のEchoルーティングへの影響ゼロ
- HTTP/2（h2c）の設定が独立
- 障害分離（一方のサーバー障害が他方に影響しない）
- 将来的なスケーリングが容易

### 決定3: Phase 1対象としてFeed Statsエンドポイントを選定

最初の移行対象として以下の3エンドポイントを選定：

| REST (v1) | Connect-RPC (v2) |
|-----------|------------------|
| `GET /v1/feeds/count` | `FeedService.GetFeedStats` |
| `GET /v1/feeds/count/detailed` | `FeedService.GetDetailedFeedStats` |
| `GET /v1/articles/unread/count` | `FeedService.GetUnreadCount` |

**選定理由：**
- シンプルなリクエスト/レスポンス（ページネーションなし）
- 認証が必要（interceptorのテストに最適）
- 本番影響が限定的（統計情報のみ）

### 決定4: Buf Schema Registry（BSR）は使用しない

ローカルでのコード生成のみを採用。BSRへのpublishは行わない。

**理由：**
- 単一リポジトリ（モノレポ）構成
- 外部サービス依存を最小化
- 開発フローのシンプルさを維持

### 決定5: 認証方式の継続

既存のJWT認証方式をConnect-RPC interceptorとして実装。

```
X-Alt-Backend-Token ヘッダー → AuthInterceptor → UserContext
```

**実装詳細：**
- `connect.UnaryInterceptorFunc`でJWTを検証
- `domain.SetUserContext`でコンテキストに認証情報を設定
- 既存の`middleware/auth_middleware.go`のロジックを再利用

## 実装内容

### ディレクトリ構造

```
Alt/
├── proto/                              # Protocol Buffers定義
│   ├── buf.yaml                        # Bufモジュール設定
│   ├── buf.gen.yaml                    # コード生成設定
│   └── alt/
│       ├── common/v2/common.proto      # 共通型（CursorRequest等）
│       └── feeds/v2/feeds.proto        # FeedService定義
│
├── alt-backend/app/
│   ├── gen/proto/                      # 生成されたGoコード
│   │   └── alt/
│   │       ├── common/v2/
│   │       └── feeds/v2/
│   │           ├── feeds.pb.go
│   │           └── feedsv2connect/feeds.connect.go
│   └── connect/v2/                     # Connect-RPC実装
│       ├── middleware/
│       │   └── auth_interceptor.go     # JWT認証interceptor
│       ├── feeds/
│       │   └── handler.go              # FeedService実装
│       └── server.go                   # サーバーセットアップ
│
└── alt-frontend-sv/src/lib/
    ├── gen/alt/feeds/v2/feeds_pb.ts    # 生成されたTS型
    └── connect/
        ├── transport.ts                # Transport設定
        ├── feeds.ts                    # FeedServiceクライアント
        └── index.ts                    # エクスポート
```

### Proto定義（feeds.proto）

```protobuf
syntax = "proto3";
package alt.feeds.v2;
option go_package = "alt/gen/proto/alt/feeds/v2;feedsv2";

message GetFeedStatsRequest {}

message GetFeedStatsResponse {
  int64 feed_amount = 1;
  int64 summarized_feed_amount = 2;
}

message GetDetailedFeedStatsRequest {}

message GetDetailedFeedStatsResponse {
  int64 feed_amount = 1;
  int64 article_amount = 2;
  int64 unsummarized_feed_amount = 3;
}

message GetUnreadCountRequest {}

message GetUnreadCountResponse {
  int64 count = 1;
}

service FeedService {
  rpc GetFeedStats(GetFeedStatsRequest) returns (GetFeedStatsResponse);
  rpc GetDetailedFeedStats(GetDetailedFeedStatsRequest) returns (GetDetailedFeedStatsResponse);
  rpc GetUnreadCount(GetUnreadCountRequest) returns (GetUnreadCountResponse);
}
```

### バックエンド実装

**認証Interceptor（auth_interceptor.go）：**

```go
func (a *AuthInterceptor) Interceptor() connect.Interceptor {
    return connect.UnaryInterceptorFunc(func(next connect.UnaryFunc) connect.UnaryFunc {
        return func(ctx context.Context, req connect.AnyRequest) (connect.AnyResponse, error) {
            userCtx, err := a.validateToken(req.Header().Get("X-Alt-Backend-Token"))
            if err != nil {
                return nil, connect.NewError(connect.CodeUnauthenticated, err)
            }
            ctx = domain.SetUserContext(ctx, userCtx)
            return next(ctx, req)
        }
    })
}
```

**FeedServiceハンドラー（handler.go）：**

```go
func (h *Handler) GetFeedStats(
    ctx context.Context,
    req *connect.Request[feedsv2.GetFeedStatsRequest],
) (*connect.Response[feedsv2.GetFeedStatsResponse], error) {
    _, err := middleware.GetUserContext(ctx)
    if err != nil {
        return nil, connect.NewError(connect.CodeUnauthenticated, err)
    }

    feedCount, _ := h.container.FeedAmountUsecase.Execute(ctx)
    summarizedCount, _ := h.container.SummarizedArticlesCountUsecase.Execute(ctx)

    return connect.NewResponse(&feedsv2.GetFeedStatsResponse{
        FeedAmount:           int64(feedCount),
        SummarizedFeedAmount: int64(summarizedCount),
    }), nil
}
```

**サーバー起動（main.go）：**

```go
connectPort := 9101
connectServer := connectv2.CreateConnectServer(container, cfg, log)
go func() {
    logger.Logger.Info("Connect-RPC server starting", "port", connectPort)
    http.ListenAndServe(fmt.Sprintf(":%d", connectPort), connectServer)
}()
```

### フロントエンド実装

**Transport（transport.ts）：**

```typescript
export async function createServerTransport(cookie: string | null): Promise<Transport> {
    const backendToken = await getBackendToken(cookie);
    return createConnectTransport({
        baseUrl: BACKEND_CONNECT_URL,
        interceptors: [(next) => async (req) => {
            if (backendToken) {
                req.header.set("X-Alt-Backend-Token", backendToken);
            }
            return next(req);
        }],
    });
}
```

**FeedServiceクライアント（feeds.ts）：**

```typescript
export async function getFeedStats(transport: Transport): Promise<FeedStats> {
    const client = createClient(FeedService, transport);
    const response = await client.getFeedStats({});
    return {
        feedAmount: Number(response.feedAmount),
        summarizedFeedAmount: Number(response.summarizedFeedAmount),
    };
}
```

**APIプロキシ（/api/v2/[...path]/+server.ts）：**

```typescript
export const fallback: RequestHandler = async ({ request, params }) => {
    const token = await getBackendToken(request.headers.get("cookie"));
    const backendUrl = `${BACKEND_CONNECT_URL}/${params.path}`;

    const headers = new Headers(request.headers);
    headers.set("X-Alt-Backend-Token", token);
    headers.delete("cookie");

    return fetch(backendUrl, {
        method: request.method,
        headers,
        body: request.body,
        duplex: "half",
    });
};
```

## 結果・影響

### メリット

1. **型安全性の確保**
   - Protocol Buffersによる単一スキーマ定義
   - Go/TypeScript両方でコンパイル時型チェック
   - APIの不整合がビルド時に検出可能

2. **開発効率の向上**
   - `make buf-generate`でコード自動生成
   - ボイラープレートコードの削減
   - IDEの補完・型推論が効く

3. **将来的な拡張性**
   - gRPC互換（マイクロサービス間通信に転用可能）
   - ストリーミングRPCのネイティブサポート
   - Bufエコシステムのツール利用可能

4. **運用の柔軟性**
   - REST/Connect-RPC並行運用で安全な移行
   - エンドポイント単位での段階的移行
   - 障害時のフォールバック可能

### デメリット・トレードオフ

1. **学習コスト**
   - Protocol Buffers構文の習得
   - Bufツールチェーンの理解
   - Connect-RPC固有のパターン（interceptor等）

2. **運用複雑性の一時的増加**
   - 移行期間中は2つのAPIが並存
   - ポート管理の増加（9000 + 9101）
   - Docker Compose設定の複雑化

3. **依存関係の増加**
   - Go: `connectrpc.com/connect`, `google.golang.org/protobuf`
   - TypeScript: `@bufbuild/protobuf`, `@connectrpc/connect-web`
   - ビルドツール: `buf`, `protoc-gen-go`, `protoc-gen-connect-go`, `protoc-gen-es`

## 付録

### 移行ロードマップ

| Phase | 対象エンドポイント | 状態 |
|-------|-------------------|------|
| 1 | Feed Stats（3エンドポイント） | **完了** |
| 2 | Feed List（カーソルページネーション） | 未着手 |
| 3 | Feed Search | 未着手 |
| 4 | Articles（content, archive） | 未着手 |
| 5 | RSS Feed Links（CRUD） | 未着手 |
| 6 | Streaming（summarize） | 未着手 |

### 使用例

**サーバーサイド（+page.server.ts）：**

```typescript
import { createServerTransport, getFeedStats } from "$lib/connect";

export async function load({ request }) {
    const transport = await createServerTransport(request.headers.get("cookie"));
    const stats = await getFeedStats(transport);
    return { feedAmount: stats.feedAmount };
}
```

**クライアントサイド：**

```typescript
import { createClientTransport, getFeedStats } from "$lib/connect";

const transport = createClientTransport();
const stats = await getFeedStats(transport);
```

### Makefileターゲット

```makefile
.PHONY: buf-generate buf-lint buf-breaking

buf-generate:
	cd proto && buf generate

buf-lint:
	cd proto && buf lint

buf-breaking:
	cd proto && buf breaking --against '.git#branch=main'
```

### 関連ファイル一覧

**新規作成（14ファイル）：**

| ファイル | 説明 |
|----------|------|
| `proto/buf.yaml` | Bufモジュール設定 |
| `proto/buf.gen.yaml` | コード生成設定 |
| `proto/alt/common/v2/common.proto` | 共通型定義 |
| `proto/alt/feeds/v2/feeds.proto` | FeedService定義 |
| `alt-backend/app/connect/v2/server.go` | Connect-RPCサーバー |
| `alt-backend/app/connect/v2/middleware/auth_interceptor.go` | 認証interceptor |
| `alt-backend/app/connect/v2/feeds/handler.go` | FeedService実装 |
| `alt-frontend-sv/src/lib/connect/transport.ts` | Transport設定 |
| `alt-frontend-sv/src/lib/connect/feeds.ts` | クライアント |
| `alt-frontend-sv/src/lib/connect/index.ts` | エクスポート |
| `alt-frontend-sv/src/routes/api/v2/[...path]/+server.ts` | APIプロキシ |

**変更（3ファイル）：**

| ファイル | 変更内容 |
|----------|----------|
| `alt-backend/app/main.go` | Connect-RPCサーバー起動追加 |
| `compose.yaml` | ポート9101追加、環境変数追加 |
| `.env.template` | `BACKEND_CONNECT_URL`追加 |
| `Makefile` | buf-generate等のターゲット追加 |

### 参考資料

- [Connect-RPC公式ドキュメント](https://connectrpc.com/)
- [Connect-ES 2.0](https://buf.build/blog/connect-es-v2)
- [Buf CLI](https://buf.build/docs/ecosystem/cli-overview)
- [Protocol Buffers Language Guide](https://protobuf.dev/programming-guides/proto3/)
