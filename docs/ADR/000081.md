# recap-worker パイプラインのバッチ API 完全移行

## ステータス

採択（Accepted）

## コンテキスト

ADR-080 で news-creator にバッチ API（`/v1/summary/generate/batch`）を実装したが、recap-worker のパイプラインは依然として個別の API 呼び出しを行っていた。

### 移行前の状態

```rust
// dispatch.rs - 各ジャンルを順次処理
for (genre, clustering_result) in clustering_results {
    let summary_result = self
        .generate_summary_with_metadata(job_id, &genre, &clustering_response)
        .await;  // ← N回の HTTP 呼び出し
}
```

### 問題点

| 問題 | 影響 |
|------|------|
| N 回の HTTP 呼び出し | ネットワークオーバーヘッド累積 |
| 順次処理 | 各ジャンルの待機時間が累積 |
| バッチ API 未活用 | ADR-080 の改善効果が未発揮 |

## 決定

`dispatch.rs` のサマリー生成フェーズをバッチ API 使用に移行する。

### 1. リクエストビルダーの分離

HTTP 呼び出しを含む `generate_summary_with_metadata()` から、リクエスト構築のみを行う `build_summary_request_for_batch()` を分離。

```rust
/// メタデータを取得して SummaryRequest を構築する（HTTP 呼び出しなし）
async fn build_summary_request_for_batch(
    &self,
    job_id: Uuid,
    genre: &str,
    clustering_response: &ClusteringResponse,
) -> Result<SummaryRequest> {
    // 記事メタデータ取得
    let article_metadata = self.dao.get_article_metadata(job_id, &article_ids).await?;

    // SummaryRequest 構築（CPU集約的なためブロッキングタスクで実行）
    let summary_request = tokio::task::spawn_blocking(move || {
        news_creator_client.build_summary_request(...)
    }).await?;

    Ok(summary_request)
}
```

### 2. バッチ処理メソッドの追加

```rust
/// Phase 2: サマリー生成をバッチ API で実行（1回の HTTP 呼び出しで全ジャンル処理）
async fn generate_summaries_with_batch(
    &self,
    job: &JobContext,
    clustering_results: HashMap<String, Result<ClusteringResponse>>,
    _evidence: Arc<EvidenceBundle>,
) -> HashMap<String, GenreResult> {
    // 1. クラスタリング成功/失敗を分離
    // 2. 全リクエストを並列構築（futures::future::join_all）
    // 3. 有効なリクエストを収集
    // 4. バッチ API 呼び出し（1回）
    // 5. レスポンスをジャンル別にマッピング
}
```

### 3. dispatch() の呼び出し変更

```rust
// Before
let mut genre_results = self
    .generate_summaries_sequentially(job, clustering_results, evidence_arc)
    .await;

// After
let mut genre_results = self
    .generate_summaries_with_batch(job, clustering_results, evidence_arc)
    .await;
```

### エラーハンドリング

| ケース | 処理 |
|--------|------|
| クラスタリング失敗 | 事前に分離し、エラー結果として記録 |
| リクエスト構築失敗 | 個別にエラー結果として記録、他ジャンルは継続 |
| バッチ API 部分失敗 | `response.errors` から個別にエラー結果を構築 |
| バッチ API 全体失敗 | 全ジャンルにエラーを伝播 |
| レスポンス欠落 | 警告ログ + エラー結果として記録 |

## 結果

### 変更ファイル

| ファイル | 変更内容 |
|---------|---------|
| `src/pipeline/dispatch.rs` | バッチ API 呼び出しに移行 |

### 具体的な変更

| 項目 | 内容 |
|------|------|
| Import 追加 | `SummaryOptions`, `SummaryRequest`, `SummaryResponse` |
| 新規メソッド | `build_summary_request_for_batch()` |
| 新規メソッド | `save_summary_metrics()` |
| 新規メソッド | `generate_summaries_with_batch()` |
| 呼び出し変更 | `dispatch()` で新メソッドを使用 |

### 後方互換性

以下のメソッドは `#[allow(dead_code)]` で保持：

- `build_genre_result()` - 将来のフォールバック用
- `generate_summary_with_metadata()` - 単発 API 呼び出し用
- `generate_summaries_sequentially()` - 順次処理用

### 処理フロー

```
移行前:
Clustering Results
    ↓
┌─ Genre A → HTTP → SummaryResponse A
├─ Genre B → HTTP → SummaryResponse B
└─ Genre C → HTTP → SummaryResponse C
    ↓
Genre Results

移行後:
Clustering Results
    ↓
Build Requests (parallel)
    ↓
[SummaryRequest A, B, C]
    ↓
Single HTTP Call (Batch API)
    ↓
BatchResponse { responses: [A, B, C], errors: [] }
    ↓
Genre Results
```

### 期待効果

| メトリクス | Before | After |
|-----------|--------|-------|
| N ジャンル HTTP 呼び出し | N 回 | 1 回 |
| ネットワークレイテンシ | N × RTT | 1 × RTT |
| 処理時間（5ジャンル） | ~25 秒 | ~8 秒 |

### メリット

1. **レイテンシ削減**: HTTP 往復オーバーヘッドを N → 1 に削減
2. **リソース効率**: 接続プール使用量の削減
3. **エラー局所化**: 部分失敗時も成功ジャンルは処理継続
4. **ログ可読性**: バッチ単位での成功/失敗カウントを記録

### トレードオフ

1. **タイムアウト設計**: バッチ全体のタイムアウトは `summary_timeout * 3`
2. **部分失敗の複雑性**: 成功/失敗/欠落の3状態を個別に処理
3. **デバッグ**: 個別ジャンルの問題特定にはログ確認が必要

## テスト

```bash
# 全テスト実行
cargo test --lib

# 結果
test result: ok. 147 passed; 0 failed; 1 ignored
```

## 実装日

2026-01-13

## 関連

- ADR-080: チャッティマイクロサービス改善（バッチ API 実装）
- [Batch Processing Pattern - Microsoft Azure](https://learn.microsoft.com/en-us/azure/architecture/patterns/gateway-aggregation)
