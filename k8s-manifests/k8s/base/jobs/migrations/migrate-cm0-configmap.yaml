apiVersion: v1
data:
  000001_create_feeds_table.down.sql: DROP TABLE IF EXISTS feeds;
  000001_create_feeds_table.up.sql: |-
    CREATE TABLE IF NOT EXISTS feeds (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        title TEXT NOT NULL,
        description TEXT NOT NULL,
        link TEXT NOT NULL,
        pub_date TIMESTAMP NOT NULL,
        created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
    );

    CREATE INDEX IF NOT EXISTS idx_feeds_created_at ON feeds (created_at);
    CREATE INDEX IF NOT EXISTS idx_feeds_id_link ON feeds (id, link);
  000002_create_feed_links.down.sql: DROP TABLE IF EXISTS feed_links;
  000002_create_feed_links.up.sql: |-
    CREATE TABLE IF NOT EXISTS feed_links (
        id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
        url TEXT NOT NULL UNIQUE,
        CONSTRAINT idx_feed_links_id_url UNIQUE (id, url)
    );
  000003_add_unique_constraint_feeds_link.down.sql: 'ALTER TABLE feeds DROP CONSTRAINT unique_feeds_link; '
  000003_add_unique_constraint_feeds_link.up.sql: 'ALTER TABLE feeds ADD CONSTRAINT unique_feeds_link UNIQUE (link); '
  000004_create_read_status_table.down.sql: 'DROP TABLE IF EXISTS read_status; '
  000004_create_read_status_table.up.sql: "CREATE TABLE IF NOT EXISTS read_status (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    feed_id UUID NOT NULL UNIQUE,\n    is_read BOOLEAN NOT NULL DEFAULT FALSE,\n    read_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    \n    CONSTRAINT fk_read_status_feed_id \n        FOREIGN KEY (feed_id) \n        REFERENCES feeds(id) \n        ON DELETE CASCADE\n);\n\nCREATE INDEX IF NOT EXISTS idx_read_status_feed_id ON read_status (feed_id);\nCREATE INDEX IF NOT EXISTS idx_read_status_is_read ON read_status (is_read);\nCREATE INDEX IF NOT EXISTS idx_read_status_created_at ON read_status (created_at); "
  000005_add_composite_index_read_status.down.sql: "-- Remove composite index\nDROP INDEX IF EXISTS idx_read_status_feed_id_is_read; "
  000005_add_composite_index_read_status.up.sql: "-- Add composite index for efficient LEFT JOIN and NOT EXISTS queries\nCREATE INDEX IF NOT EXISTS idx_read_status_feed_id_is_read ON read_status (feed_id, is_read); "
  000006_add_partial_index_read_status.down.sql: "-- Remove partial index for read feeds\nDROP INDEX IF EXISTS idx_read_status_feed_id_read_true; "
  000006_add_partial_index_read_status.up.sql: "-- Add partial index for read feeds only to optimize NOT EXISTS queries\nCREATE INDEX IF NOT EXISTS idx_read_status_feed_id_read_true \nON read_status (feed_id) \nWHERE is_read = TRUE; "
  000007_create_articles_table.down.sql: DROP TABLE IF EXISTS articles;
  000007_create_articles_table.up.sql: |-
    CREATE TABLE IF NOT EXISTS articles (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        title TEXT NOT NULL,
        content TEXT NOT NULL,
        url TEXT NOT NULL UNIQUE,
        created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
    );

    CREATE INDEX IF NOT EXISTS idx_articles_created_at ON articles (created_at);
    CREATE INDEX IF NOT EXISTS idx_articles_title_created_at ON articles (title, created_at);
    CREATE INDEX IF NOT EXISTS idx_articles_title ON articles (title);
  000008_grant_preprocessor_permissions.down.sql: |-
    -- Revoke preprocessor user permissions
    REVOKE ALL ON TABLE feeds FROM pre_processor_user;
    REVOKE ALL ON TABLE articles FROM pre_processor_user;
  000008_grant_preprocessor_permissions.up.sql: |-
    -- Grant specific table permissions to the preprocessor user
    -- This runs after all tables have been created by previous migrations
    -- Note: This assumes the user is named 'pre_processor_user' based on the environment variable

    -- Grant permissions on feeds table (read access for getting RSS URLs)
    GRANT SELECT ON TABLE feeds TO pre_processor_user;

    -- Grant permissions on articles table (read/write access for storing processed articles)
    GRANT SELECT, INSERT, UPDATE ON TABLE articles TO pre_processor_user;

    -- Ensure the user has access to sequences used by these tables
    GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO pre_processor_user;
  000009_create_article_summaries_table.down.sql: DROP TABLE IF EXISTS article_summaries;
  000009_create_article_summaries_table.up.sql: |-
    CREATE TABLE IF NOT EXISTS article_summaries (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        article_id UUID NOT NULL,
        article_title TEXT NOT NULL,
        summary_japanese TEXT NOT NULL,
        created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

        CONSTRAINT fk_article_summaries_article_id
            FOREIGN KEY (article_id)
            REFERENCES articles(id)
            ON DELETE CASCADE
    );

    -- Indexes for performance
    CREATE INDEX IF NOT EXISTS idx_article_summaries_article_id ON article_summaries (article_id);
    CREATE INDEX IF NOT EXISTS idx_article_summaries_created_at ON article_summaries (created_at);

    -- Ensure only one summary per article
    CREATE UNIQUE INDEX IF NOT EXISTS idx_article_summaries_unique_article ON article_summaries (article_id);
  000010_grant_preprocessor_article_summaries_permissions.down.sql: |-
    -- Revoke permissions on article_summaries table from the preprocessor user
    REVOKE ALL ON TABLE article_summaries FROM pre_processor_user;
  000010_grant_preprocessor_article_summaries_permissions.up.sql: |-
    -- Grant permissions on article_summaries table to the preprocessor user
    GRANT SELECT, INSERT, UPDATE ON TABLE article_summaries TO pre_processor_user;
  000011_optimize_feed_article_lookup.down.sql: |-
    -- Remove optimization indexes
    DROP INDEX IF EXISTS idx_articles_url_lookup;
    DROP INDEX IF EXISTS idx_feeds_created_at_link;
    -- DROP INDEX IF EXISTS idx_articles_url_hash;
  000011_optimize_feed_article_lookup.up.sql: |-
    -- Add index on articles.url for faster lookups in NOT EXISTS queries
    -- (This should already exist due to UNIQUE constraint, but we'll ensure it's optimal)
    CREATE INDEX IF NOT EXISTS idx_articles_url_lookup ON articles (url);

    -- Add a composite index on feeds for this specific query pattern
    CREATE INDEX IF NOT EXISTS idx_feeds_created_at_link ON feeds (created_at ASC, link);

    -- Optional: Add a hash index on articles.url for even faster equality lookups
    -- (Only if PostgreSQL version supports it and the table is read-heavy)
    -- CREATE INDEX IF NOT EXISTS idx_articles_url_hash ON articles USING hash (url);
  000012_optimize_feed_article_indexes.down.sql: |-
    -- Remove optimized indexes
    DROP INDEX IF EXISTS idx_feeds_created_at_link;
    DROP INDEX IF EXISTS idx_articles_url;
  000012_optimize_feed_article_indexes.up.sql: |-
    -- feeds: 並び替えと検索を同時に満たす複合
    CREATE INDEX IF NOT EXISTS idx_feeds_created_at_link
        ON feeds (created_at, link);

    -- articles: 存在確認だけなので単一キー
    CREATE UNIQUE INDEX IF NOT EXISTS idx_articles_url
        ON articles (url);
  000013_add_feeds_link_gin_trgm_index.down.sql: |-
    -- Remove GIN trigram index on feeds.link
    DROP INDEX IF EXISTS idx_feeds_link_gin_trgm;

    -- Note: We don't drop the pg_trgm extension as it might be used by other indexes or queries
  000013_add_feeds_link_gin_trgm_index.up.sql: |-
    -- Enable pg_trgm extension for trigram similarity operations
    CREATE EXTENSION IF NOT EXISTS pg_trgm;

    -- Add GIN trigram index on feeds.link for fast text similarity searches
    CREATE INDEX IF NOT EXISTS idx_feeds_link_gin_trgm ON feeds USING gin (link gin_trgm_ops);
  000014_add_articles_gin_trgm_indexes.down.sql: |-
    -- Remove GIN trigram indexes for articles table
    DROP INDEX IF EXISTS idx_articles_title_gin_trgm;
    DROP INDEX IF EXISTS idx_articles_url_gin_trgm;
  000014_add_articles_gin_trgm_indexes.up.sql: |-
    -- Add GIN trigram indexes for articles table
    -- Index on title for fast text similarity searches
    CREATE INDEX IF NOT EXISTS idx_articles_title_gin_trgm ON articles USING gin (title gin_trgm_ops);

    -- Index on url for fast text similarity searches
    CREATE INDEX IF NOT EXISTS idx_articles_url_gin_trgm ON articles USING gin (url gin_trgm_ops);
  000015_add_article_summaries_gin_trgm_indexes.down.sql: |-
    -- Remove GIN trigram index for article_summaries table
    DROP INDEX IF EXISTS idx_article_summaries_title_gin_trgm;
  000015_add_article_summaries_gin_trgm_indexes.up.sql: |-
    -- Add GIN trigram index for article_summaries table
    -- Index on article_title for fast text similarity searches
    CREATE INDEX IF NOT EXISTS idx_article_summaries_title_gin_trgm ON article_summaries USING gin (article_title gin_trgm_ops);
  000016_remove_duplicate_articles_url_index.down.sql: |-
    -- Recreate the articles URL lookup index (in case rollback is needed)
    CREATE INDEX IF NOT EXISTS idx_articles_url_lookup ON articles (url);
  000016_remove_duplicate_articles_url_index.up.sql: |-
    -- Remove duplicate index on articles.url
    -- The unique index idx_articles_url already provides lookup performance
    DROP INDEX IF EXISTS idx_articles_url_lookup;
  000017_add_feeds_created_desc_not_mp3_index.down.sql: |-
    -- Remove the partial index for non-MP3 feeds
    DROP INDEX IF EXISTS idx_feeds_created_desc_not_mp3;
  000017_add_feeds_created_desc_not_mp3_index.up.sql: |-
    -- Add partial index for feeds excluding MP3 files, ordered by creation date descending
    -- Optimizes queries for non-audio content chronologically
    CREATE INDEX idx_feeds_created_desc_not_mp3
      ON feeds (created_at DESC, link)
      WHERE link NOT LIKE '%.mp3';
  000018_add_articles_created_id_desc_index.down.sql: DROP INDEX CONCURRENTLY IF EXISTS idx_articles_created_id_desc;
  000018_add_articles_created_id_desc_index.up.sql: |-
    CREATE INDEX CONCURRENTLY idx_articles_created_id_desc
        ON articles (created_at DESC, id DESC);
  000019_add_articles_id_index.down.sql: DROP INDEX IF EXISTS idx_articles_id_only;
  000019_add_articles_id_index.up.sql: CREATE INDEX IF NOT EXISTS idx_articles_id_only ON articles (id);
  000020_refine_articles_indexes_add_covering.down.sql: |-
    -- Remove the covering index
    DROP INDEX CONCURRENTLY IF EXISTS idx_articles_cover_desc;

    -- Recreate the original indexes that were dropped
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_articles_created_id_desc
        ON articles (created_at DESC, id DESC);

    CREATE INDEX IF NOT EXISTS idx_articles_created_at ON articles (created_at);

    CREATE INDEX IF NOT EXISTS idx_articles_id_only ON articles (id);
  000020_refine_articles_indexes_add_covering.up.sql: |-
    -- Drop redundant indexes that will be covered by the new covering index
    DROP INDEX CONCURRENTLY IF EXISTS idx_articles_created_id_desc;
    DROP INDEX IF EXISTS idx_articles_created_at;
    DROP INDEX IF EXISTS idx_articles_id_only;

    -- Create the new covering index that includes frequently accessed columns
    -- This covers queries that need created_at/id ordering plus title, content, url access
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_articles_cover_desc
      ON articles (created_at DESC, id DESC)
      INCLUDE (title, content, url);
  000021_optimize_articles_title_indexes.down.sql: CREATE INDEX IF NOT EXISTS idx_articles_title_created_at ON articles (title, created_at);
  000021_optimize_articles_title_indexes.up.sql: DROP INDEX IF EXISTS idx_articles_title_created_at;
  000022_add_feeds_desc_not_mp3_cover_index.down.sql: DROP INDEX IF EXISTS idx_feeds_desc_not_mp3_cover;
  000022_add_feeds_desc_not_mp3_cover_index.up.sql: |-
    CREATE INDEX IF NOT EXISTS idx_feeds_desc_not_mp3_cover
      ON feeds (created_at DESC, id DESC)
      INCLUDE (link)
      WHERE link NOT LIKE '%.mp3';
  000023_grant_preprocessor_delete_article_summaries.down.sql: |-
    -- Revoke DELETE permission on article_summaries table from the preprocessor user
    REVOKE DELETE ON TABLE article_summaries FROM pre_processor_user;
  000023_grant_preprocessor_delete_article_summaries.up.sql: |-
    -- Grant DELETE permission on article_summaries table to the preprocessor user
    GRANT DELETE ON TABLE article_summaries TO pre_processor_user;
  000024_create_feed_tags_table.down.sql: |
    -- Drop feed_tags table and its indexes
    DROP INDEX IF EXISTS idx_feed_tags_created_at;
    DROP INDEX IF EXISTS idx_feed_tags_tag_id;
    DROP TABLE IF EXISTS feed_tags;
  000024_create_feed_tags_table.up.sql: |-
    -- Create the feed_tags junction table
    CREATE TABLE feed_tags (
        feed_id    UUID NOT NULL REFERENCES feeds(id) ON DELETE CASCADE,
        tag_id     INT  NOT NULL REFERENCES tags(id)  ON DELETE CASCADE,
        created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
        PRIMARY KEY (feed_id, tag_id)
    );

    ALTER TABLE feed_tags
        OWNER TO alt_db_user;

    CREATE INDEX idx_feed_tags_tag_id
        ON feed_tags (tag_id);

    CREATE INDEX idx_feed_tags_created_at
        ON feed_tags (created_at);
  000025_create_article_tags_table.down.sql: |-
    DROP INDEX IF EXISTS idx_article_tags_created_at;
    DROP INDEX IF EXISTS idx_article_tags_tag_id;
    DROP TABLE IF EXISTS article_tags;
  000025_create_article_tags_table.up.sql: |-
    -- Create the article_tags junction table
    CREATE TABLE article_tags (
        article_id UUID     NOT NULL REFERENCES articles(id) ON DELETE CASCADE,
        feed_tag_id     INT      NOT NULL REFERENCES feed_tags(id)     ON DELETE CASCADE,
        created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
        PRIMARY KEY (article_id, feed_tag_id)
    );

    ALTER TABLE article_tags
        OWNER TO alt_db_user;

    CREATE INDEX idx_article_tags_feed_tag_id
        ON article_tags (feed_tag_id);

    CREATE INDEX idx_article_tags_created_at
        ON article_tags (created_at);
  000026_grant_tag_generator_permissions.down.sql: |-
    REVOKE SELECT, INSERT, DELETE
        ON article_tags, feed_tags
        FROM tag_generator;
  000026_grant_tag_generator_permissions.up.sql: |-
    GRANT SELECT, INSERT, DELETE
        ON feed_tags, article_tags
        TO tag_generator;
  000027_fix_tags_schema.down.sql: |-
    -- Reverse the tags schema fix

    -- 1. Drop the corrected article_tags table
    DROP TABLE IF EXISTS article_tags;

    -- 2. Rename indexes back
    ALTER INDEX idx_tags_name RENAME TO idx_feed_tags_name;
    ALTER INDEX idx_tags_created_at RENAME TO idx_feed_tags_created_at;

    -- 3. Rename constraints back
    ALTER TABLE tags RENAME CONSTRAINT tags_name_key TO feed_tags_name_key;
    ALTER TABLE tags RENAME CONSTRAINT tags_pkey TO feed_tags_pkey;

    -- 4. Rename sequence back
    ALTER SEQUENCE tags_id_seq RENAME TO feed_tags_id_seq;

    -- 5. Rename table back to feed_tags
    ALTER TABLE tags RENAME TO feed_tags;

    -- 6. Recreate the original (incorrect) article_tags table
    CREATE TABLE article_tags (
        article_id UUID     NOT NULL REFERENCES articles(id) ON DELETE CASCADE,
        feed_tag_id     INT      NOT NULL REFERENCES feed_tags(id)     ON DELETE CASCADE,
        created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
        PRIMARY KEY (article_id, feed_tag_id)
    );

    ALTER TABLE article_tags
        OWNER TO alt_db_user;

    CREATE INDEX idx_article_tags_feed_tag_id
        ON article_tags (feed_tag_id);

    CREATE INDEX idx_article_tags_created_at
        ON article_tags (created_at);
  000027_fix_tags_schema.up.sql: |-
    -- Fix the tags schema
    -- The feed_tags table is actually the main tags table with id and name
    -- We need to rename it and fix the article_tags table structure

    -- 1. Rename feed_tags to tags (since it has the correct structure: id, name)
    ALTER TABLE feed_tags RENAME TO tags;

    -- 2. Rename the sequence as well
    ALTER SEQUENCE feed_tags_id_seq RENAME TO tags_id_seq;

    -- 3. Update the primary key constraint name
    ALTER TABLE tags RENAME CONSTRAINT feed_tags_pkey TO tags_pkey;

    -- 4. Update the unique constraint name
    ALTER TABLE tags RENAME CONSTRAINT feed_tags_name_key TO tags_name_key;

    -- 5. Rename indexes
    ALTER INDEX idx_feed_tags_created_at RENAME TO idx_tags_created_at;
    ALTER INDEX idx_feed_tags_name RENAME TO idx_tags_name;

    -- 6. Drop the existing article_tags table (it has wrong structure)
    DROP TABLE IF EXISTS article_tags;

    -- 7. Create the correct article_tags table
    CREATE TABLE article_tags (
        article_id UUID NOT NULL REFERENCES articles(id) ON DELETE CASCADE,
        tag_id     INT  NOT NULL REFERENCES tags(id) ON DELETE CASCADE,
        created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
        PRIMARY KEY (article_id, tag_id)
    );

    ALTER TABLE article_tags
        OWNER TO alt_db_user;

    CREATE INDEX idx_article_tags_tag_id
        ON article_tags (tag_id);

    CREATE INDEX idx_article_tags_created_at
        ON article_tags (created_at);
  000028_grant_search_indexer_permissions.down.sql: |-
    -- Revoke search indexer user permissions

    REVOKE SELECT ON articles FROM search_indexer_user;
    REVOKE SELECT ON tags FROM search_indexer_user;
    REVOKE SELECT ON article_tags FROM search_indexer_user;
    REVOKE USAGE ON SCHEMA public FROM search_indexer_user;
    REVOKE CONNECT ON DATABASE alt FROM search_indexer_user;
  000028_grant_search_indexer_permissions.up.sql: |-
    -- Grant search indexer user access to all tables it needs for search functionality

    -- Articles table access (for reading articles)
    GRANT SELECT ON articles TO search_indexer_user;

    -- Tags table access (for reading tag information)
    GRANT SELECT ON tags TO search_indexer_user;

    -- Article_tags table access (for reading article-tag relationships)
    GRANT SELECT ON article_tags TO search_indexer_user;

    -- Grant connect and usage permissions
    GRANT CONNECT ON DATABASE alt TO search_indexer_user;
    GRANT USAGE ON SCHEMA public TO search_indexer_user;
  000029_create_favorite_feeds_table.down.sql: DROP TABLE IF EXISTS favorite_feeds;
  000029_create_favorite_feeds_table.up.sql: |-
    -- Create the favorite_feeds table
    CREATE TABLE IF NOT EXISTS favorite_feeds (
        feed_id    UUID PRIMARY KEY,
        created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
        CONSTRAINT fk_favorite_feeds_feed_id
            FOREIGN KEY (feed_id)
            REFERENCES feeds(id)
            ON DELETE CASCADE
    );

    -- Index for ordering favorites by creation date
    CREATE INDEX IF NOT EXISTS idx_favorite_feeds_created_at ON favorite_feeds (created_at DESC);
  000030_add_feed_id_to_articles.down.sql: |-
    -- Remove the index on feed_id
    DROP INDEX IF EXISTS idx_articles_feed_id;

    -- Remove the foreign key constraint
    ALTER TABLE articles
        DROP CONSTRAINT IF EXISTS fk_articles_feed_id;

    -- Remove the feed_id column from the articles table
    ALTER TABLE articles
        DROP COLUMN IF EXISTS feed_id;
  000030_add_feed_id_to_articles.up.sql: |-
    -- Add feed_id to articles table to link articles to their source feed
    ALTER TABLE articles
        ADD COLUMN feed_id UUID;

    -- Add a foreign key constraint to ensure data integrity
    -- If a feed is deleted, all its articles will be deleted as well.
    ALTER TABLE articles
        ADD CONSTRAINT fk_articles_feed_id
            FOREIGN KEY (feed_id)
            REFERENCES feeds(id)
            ON DELETE CASCADE;

    -- Add an index on feed_id for faster querying of articles by feed
    CREATE INDEX IF NOT EXISTS idx_articles_feed_id ON articles (feed_id);
  000031_update_tag_generator_permissions.down.sql: |-
    -- Revoke the privileges granted to tag_generator in migration 000031

    REVOKE SELECT, INSERT ON article_tags FROM tag_generator;
    REVOKE SELECT, INSERT ON tags FROM tag_generator;
    REVOKE SELECT ON articles FROM tag_generator;
    REVOKE USAGE ON SCHEMA public FROM tag_generator;
    REVOKE CONNECT ON DATABASE alt FROM tag_generator;
  000031_update_tag_generator_permissions.up.sql: |-
    -- Reset tag_generator privileges and grant only the required access

    -- Remove any existing privileges on the database to start from a clean state
    REVOKE ALL ON DATABASE alt FROM tag_generator;

    -- Basic connectivity and schema usage privileges
    GRANT CONNECT ON DATABASE alt TO tag_generator;
    GRANT USAGE ON SCHEMA public TO tag_generator;

    -- Table-level privileges
    GRANT SELECT ON articles TO tag_generator;
    GRANT SELECT, INSERT ON tags TO tag_generator;
    GRANT SELECT, INSERT ON article_tags TO tag_generator;
kind: ConfigMap
metadata:
  labels:
    io.kompose.service: migrate
  name: migrate-cm0
