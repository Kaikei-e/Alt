// Code generated by MockGen. DO NOT EDIT.
// Source: ./port/internal_article_port/port.go
//
// Generated by this command:
//
//	mockgen -source=./port/internal_article_port/port.go -destination=./mocks/mock_internal_article_port.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	internal_article_port "alt/port/internal_article_port"
	context "context"
	reflect "reflect"
	time "time"

	gomock "go.uber.org/mock/gomock"
)

// MockListArticlesWithTagsPort is a mock of ListArticlesWithTagsPort interface.
type MockListArticlesWithTagsPort struct {
	ctrl     *gomock.Controller
	recorder *MockListArticlesWithTagsPortMockRecorder
	isgomock struct{}
}

// MockListArticlesWithTagsPortMockRecorder is the mock recorder for MockListArticlesWithTagsPort.
type MockListArticlesWithTagsPortMockRecorder struct {
	mock *MockListArticlesWithTagsPort
}

// NewMockListArticlesWithTagsPort creates a new mock instance.
func NewMockListArticlesWithTagsPort(ctrl *gomock.Controller) *MockListArticlesWithTagsPort {
	mock := &MockListArticlesWithTagsPort{ctrl: ctrl}
	mock.recorder = &MockListArticlesWithTagsPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockListArticlesWithTagsPort) EXPECT() *MockListArticlesWithTagsPortMockRecorder {
	return m.recorder
}

// ListArticlesWithTags mocks base method.
func (m *MockListArticlesWithTagsPort) ListArticlesWithTags(ctx context.Context, lastCreatedAt *time.Time, lastID string, limit int) ([]*internal_article_port.ArticleWithTags, *time.Time, string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListArticlesWithTags", ctx, lastCreatedAt, lastID, limit)
	ret0, _ := ret[0].([]*internal_article_port.ArticleWithTags)
	ret1, _ := ret[1].(*time.Time)
	ret2, _ := ret[2].(string)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// ListArticlesWithTags indicates an expected call of ListArticlesWithTags.
func (mr *MockListArticlesWithTagsPortMockRecorder) ListArticlesWithTags(ctx, lastCreatedAt, lastID, limit any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListArticlesWithTags", reflect.TypeOf((*MockListArticlesWithTagsPort)(nil).ListArticlesWithTags), ctx, lastCreatedAt, lastID, limit)
}

// MockListArticlesWithTagsForwardPort is a mock of ListArticlesWithTagsForwardPort interface.
type MockListArticlesWithTagsForwardPort struct {
	ctrl     *gomock.Controller
	recorder *MockListArticlesWithTagsForwardPortMockRecorder
	isgomock struct{}
}

// MockListArticlesWithTagsForwardPortMockRecorder is the mock recorder for MockListArticlesWithTagsForwardPort.
type MockListArticlesWithTagsForwardPortMockRecorder struct {
	mock *MockListArticlesWithTagsForwardPort
}

// NewMockListArticlesWithTagsForwardPort creates a new mock instance.
func NewMockListArticlesWithTagsForwardPort(ctrl *gomock.Controller) *MockListArticlesWithTagsForwardPort {
	mock := &MockListArticlesWithTagsForwardPort{ctrl: ctrl}
	mock.recorder = &MockListArticlesWithTagsForwardPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockListArticlesWithTagsForwardPort) EXPECT() *MockListArticlesWithTagsForwardPortMockRecorder {
	return m.recorder
}

// ListArticlesWithTagsForward mocks base method.
func (m *MockListArticlesWithTagsForwardPort) ListArticlesWithTagsForward(ctx context.Context, incrementalMark, lastCreatedAt *time.Time, lastID string, limit int) ([]*internal_article_port.ArticleWithTags, *time.Time, string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListArticlesWithTagsForward", ctx, incrementalMark, lastCreatedAt, lastID, limit)
	ret0, _ := ret[0].([]*internal_article_port.ArticleWithTags)
	ret1, _ := ret[1].(*time.Time)
	ret2, _ := ret[2].(string)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// ListArticlesWithTagsForward indicates an expected call of ListArticlesWithTagsForward.
func (mr *MockListArticlesWithTagsForwardPortMockRecorder) ListArticlesWithTagsForward(ctx, incrementalMark, lastCreatedAt, lastID, limit any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListArticlesWithTagsForward", reflect.TypeOf((*MockListArticlesWithTagsForwardPort)(nil).ListArticlesWithTagsForward), ctx, incrementalMark, lastCreatedAt, lastID, limit)
}

// MockListDeletedArticlesPort is a mock of ListDeletedArticlesPort interface.
type MockListDeletedArticlesPort struct {
	ctrl     *gomock.Controller
	recorder *MockListDeletedArticlesPortMockRecorder
	isgomock struct{}
}

// MockListDeletedArticlesPortMockRecorder is the mock recorder for MockListDeletedArticlesPort.
type MockListDeletedArticlesPortMockRecorder struct {
	mock *MockListDeletedArticlesPort
}

// NewMockListDeletedArticlesPort creates a new mock instance.
func NewMockListDeletedArticlesPort(ctrl *gomock.Controller) *MockListDeletedArticlesPort {
	mock := &MockListDeletedArticlesPort{ctrl: ctrl}
	mock.recorder = &MockListDeletedArticlesPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockListDeletedArticlesPort) EXPECT() *MockListDeletedArticlesPortMockRecorder {
	return m.recorder
}

// ListDeletedArticles mocks base method.
func (m *MockListDeletedArticlesPort) ListDeletedArticles(ctx context.Context, lastDeletedAt *time.Time, limit int) ([]*internal_article_port.DeletedArticle, *time.Time, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListDeletedArticles", ctx, lastDeletedAt, limit)
	ret0, _ := ret[0].([]*internal_article_port.DeletedArticle)
	ret1, _ := ret[1].(*time.Time)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListDeletedArticles indicates an expected call of ListDeletedArticles.
func (mr *MockListDeletedArticlesPortMockRecorder) ListDeletedArticles(ctx, lastDeletedAt, limit any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListDeletedArticles", reflect.TypeOf((*MockListDeletedArticlesPort)(nil).ListDeletedArticles), ctx, lastDeletedAt, limit)
}

// MockGetLatestArticleTimestampPort is a mock of GetLatestArticleTimestampPort interface.
type MockGetLatestArticleTimestampPort struct {
	ctrl     *gomock.Controller
	recorder *MockGetLatestArticleTimestampPortMockRecorder
	isgomock struct{}
}

// MockGetLatestArticleTimestampPortMockRecorder is the mock recorder for MockGetLatestArticleTimestampPort.
type MockGetLatestArticleTimestampPortMockRecorder struct {
	mock *MockGetLatestArticleTimestampPort
}

// NewMockGetLatestArticleTimestampPort creates a new mock instance.
func NewMockGetLatestArticleTimestampPort(ctrl *gomock.Controller) *MockGetLatestArticleTimestampPort {
	mock := &MockGetLatestArticleTimestampPort{ctrl: ctrl}
	mock.recorder = &MockGetLatestArticleTimestampPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGetLatestArticleTimestampPort) EXPECT() *MockGetLatestArticleTimestampPortMockRecorder {
	return m.recorder
}

// GetLatestArticleTimestamp mocks base method.
func (m *MockGetLatestArticleTimestampPort) GetLatestArticleTimestamp(ctx context.Context) (*time.Time, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLatestArticleTimestamp", ctx)
	ret0, _ := ret[0].(*time.Time)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLatestArticleTimestamp indicates an expected call of GetLatestArticleTimestamp.
func (mr *MockGetLatestArticleTimestampPortMockRecorder) GetLatestArticleTimestamp(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLatestArticleTimestamp", reflect.TypeOf((*MockGetLatestArticleTimestampPort)(nil).GetLatestArticleTimestamp), ctx)
}

// MockGetArticleByIDPort is a mock of GetArticleByIDPort interface.
type MockGetArticleByIDPort struct {
	ctrl     *gomock.Controller
	recorder *MockGetArticleByIDPortMockRecorder
	isgomock struct{}
}

// MockGetArticleByIDPortMockRecorder is the mock recorder for MockGetArticleByIDPort.
type MockGetArticleByIDPortMockRecorder struct {
	mock *MockGetArticleByIDPort
}

// NewMockGetArticleByIDPort creates a new mock instance.
func NewMockGetArticleByIDPort(ctrl *gomock.Controller) *MockGetArticleByIDPort {
	mock := &MockGetArticleByIDPort{ctrl: ctrl}
	mock.recorder = &MockGetArticleByIDPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGetArticleByIDPort) EXPECT() *MockGetArticleByIDPortMockRecorder {
	return m.recorder
}

// GetArticleByID mocks base method.
func (m *MockGetArticleByIDPort) GetArticleByID(ctx context.Context, articleID string) (*internal_article_port.ArticleWithTags, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetArticleByID", ctx, articleID)
	ret0, _ := ret[0].(*internal_article_port.ArticleWithTags)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetArticleByID indicates an expected call of GetArticleByID.
func (mr *MockGetArticleByIDPortMockRecorder) GetArticleByID(ctx, articleID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetArticleByID", reflect.TypeOf((*MockGetArticleByIDPort)(nil).GetArticleByID), ctx, articleID)
}

// MockCheckArticleExistsPort is a mock of CheckArticleExistsPort interface.
type MockCheckArticleExistsPort struct {
	ctrl     *gomock.Controller
	recorder *MockCheckArticleExistsPortMockRecorder
	isgomock struct{}
}

// MockCheckArticleExistsPortMockRecorder is the mock recorder for MockCheckArticleExistsPort.
type MockCheckArticleExistsPortMockRecorder struct {
	mock *MockCheckArticleExistsPort
}

// NewMockCheckArticleExistsPort creates a new mock instance.
func NewMockCheckArticleExistsPort(ctrl *gomock.Controller) *MockCheckArticleExistsPort {
	mock := &MockCheckArticleExistsPort{ctrl: ctrl}
	mock.recorder = &MockCheckArticleExistsPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCheckArticleExistsPort) EXPECT() *MockCheckArticleExistsPortMockRecorder {
	return m.recorder
}

// CheckArticleExists mocks base method.
func (m *MockCheckArticleExistsPort) CheckArticleExists(ctx context.Context, url, feedID string) (bool, string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckArticleExists", ctx, url, feedID)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CheckArticleExists indicates an expected call of CheckArticleExists.
func (mr *MockCheckArticleExistsPortMockRecorder) CheckArticleExists(ctx, url, feedID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckArticleExists", reflect.TypeOf((*MockCheckArticleExistsPort)(nil).CheckArticleExists), ctx, url, feedID)
}

// MockCreateArticlePort is a mock of CreateArticlePort interface.
type MockCreateArticlePort struct {
	ctrl     *gomock.Controller
	recorder *MockCreateArticlePortMockRecorder
	isgomock struct{}
}

// MockCreateArticlePortMockRecorder is the mock recorder for MockCreateArticlePort.
type MockCreateArticlePortMockRecorder struct {
	mock *MockCreateArticlePort
}

// NewMockCreateArticlePort creates a new mock instance.
func NewMockCreateArticlePort(ctrl *gomock.Controller) *MockCreateArticlePort {
	mock := &MockCreateArticlePort{ctrl: ctrl}
	mock.recorder = &MockCreateArticlePortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCreateArticlePort) EXPECT() *MockCreateArticlePortMockRecorder {
	return m.recorder
}

// CreateArticle mocks base method.
func (m *MockCreateArticlePort) CreateArticle(ctx context.Context, params internal_article_port.CreateArticleParams) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateArticle", ctx, params)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateArticle indicates an expected call of CreateArticle.
func (mr *MockCreateArticlePortMockRecorder) CreateArticle(ctx, params any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateArticle", reflect.TypeOf((*MockCreateArticlePort)(nil).CreateArticle), ctx, params)
}

// MockSaveArticleSummaryPort is a mock of SaveArticleSummaryPort interface.
type MockSaveArticleSummaryPort struct {
	ctrl     *gomock.Controller
	recorder *MockSaveArticleSummaryPortMockRecorder
	isgomock struct{}
}

// MockSaveArticleSummaryPortMockRecorder is the mock recorder for MockSaveArticleSummaryPort.
type MockSaveArticleSummaryPortMockRecorder struct {
	mock *MockSaveArticleSummaryPort
}

// NewMockSaveArticleSummaryPort creates a new mock instance.
func NewMockSaveArticleSummaryPort(ctrl *gomock.Controller) *MockSaveArticleSummaryPort {
	mock := &MockSaveArticleSummaryPort{ctrl: ctrl}
	mock.recorder = &MockSaveArticleSummaryPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSaveArticleSummaryPort) EXPECT() *MockSaveArticleSummaryPortMockRecorder {
	return m.recorder
}

// SaveArticleSummary mocks base method.
func (m *MockSaveArticleSummaryPort) SaveArticleSummary(ctx context.Context, articleID, summary, language string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SaveArticleSummary", ctx, articleID, summary, language)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveArticleSummary indicates an expected call of SaveArticleSummary.
func (mr *MockSaveArticleSummaryPortMockRecorder) SaveArticleSummary(ctx, articleID, summary, language any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveArticleSummary", reflect.TypeOf((*MockSaveArticleSummaryPort)(nil).SaveArticleSummary), ctx, articleID, summary, language)
}

// MockGetArticleContentPort is a mock of GetArticleContentPort interface.
type MockGetArticleContentPort struct {
	ctrl     *gomock.Controller
	recorder *MockGetArticleContentPortMockRecorder
	isgomock struct{}
}

// MockGetArticleContentPortMockRecorder is the mock recorder for MockGetArticleContentPort.
type MockGetArticleContentPortMockRecorder struct {
	mock *MockGetArticleContentPort
}

// NewMockGetArticleContentPort creates a new mock instance.
func NewMockGetArticleContentPort(ctrl *gomock.Controller) *MockGetArticleContentPort {
	mock := &MockGetArticleContentPort{ctrl: ctrl}
	mock.recorder = &MockGetArticleContentPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGetArticleContentPort) EXPECT() *MockGetArticleContentPortMockRecorder {
	return m.recorder
}

// GetArticleContent mocks base method.
func (m *MockGetArticleContentPort) GetArticleContent(ctx context.Context, articleID string) (*internal_article_port.ArticleContent, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetArticleContent", ctx, articleID)
	ret0, _ := ret[0].(*internal_article_port.ArticleContent)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetArticleContent indicates an expected call of GetArticleContent.
func (mr *MockGetArticleContentPortMockRecorder) GetArticleContent(ctx, articleID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetArticleContent", reflect.TypeOf((*MockGetArticleContentPort)(nil).GetArticleContent), ctx, articleID)
}
