// Code generated by MockGen. DO NOT EDIT.
// Source: ./port/internal_tag_port/port.go
//
// Generated by this command:
//
//	mockgen -source=./port/internal_tag_port/port.go -destination=./mocks/mock_internal_tag_port.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	internal_tag_port "alt/port/internal_tag_port"
	context "context"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockUpsertArticleTagsPort is a mock of UpsertArticleTagsPort interface.
type MockUpsertArticleTagsPort struct {
	ctrl     *gomock.Controller
	recorder *MockUpsertArticleTagsPortMockRecorder
	isgomock struct{}
}

// MockUpsertArticleTagsPortMockRecorder is the mock recorder for MockUpsertArticleTagsPort.
type MockUpsertArticleTagsPortMockRecorder struct {
	mock *MockUpsertArticleTagsPort
}

// NewMockUpsertArticleTagsPort creates a new mock instance.
func NewMockUpsertArticleTagsPort(ctrl *gomock.Controller) *MockUpsertArticleTagsPort {
	mock := &MockUpsertArticleTagsPort{ctrl: ctrl}
	mock.recorder = &MockUpsertArticleTagsPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUpsertArticleTagsPort) EXPECT() *MockUpsertArticleTagsPortMockRecorder {
	return m.recorder
}

// UpsertArticleTags mocks base method.
func (m *MockUpsertArticleTagsPort) UpsertArticleTags(ctx context.Context, articleID, feedID string, tags []internal_tag_port.TagItem) (int32, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpsertArticleTags", ctx, articleID, feedID, tags)
	ret0, _ := ret[0].(int32)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpsertArticleTags indicates an expected call of UpsertArticleTags.
func (mr *MockUpsertArticleTagsPortMockRecorder) UpsertArticleTags(ctx, articleID, feedID, tags any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertArticleTags", reflect.TypeOf((*MockUpsertArticleTagsPort)(nil).UpsertArticleTags), ctx, articleID, feedID, tags)
}

// MockBatchUpsertArticleTagsPort is a mock of BatchUpsertArticleTagsPort interface.
type MockBatchUpsertArticleTagsPort struct {
	ctrl     *gomock.Controller
	recorder *MockBatchUpsertArticleTagsPortMockRecorder
	isgomock struct{}
}

// MockBatchUpsertArticleTagsPortMockRecorder is the mock recorder for MockBatchUpsertArticleTagsPort.
type MockBatchUpsertArticleTagsPortMockRecorder struct {
	mock *MockBatchUpsertArticleTagsPort
}

// NewMockBatchUpsertArticleTagsPort creates a new mock instance.
func NewMockBatchUpsertArticleTagsPort(ctrl *gomock.Controller) *MockBatchUpsertArticleTagsPort {
	mock := &MockBatchUpsertArticleTagsPort{ctrl: ctrl}
	mock.recorder = &MockBatchUpsertArticleTagsPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBatchUpsertArticleTagsPort) EXPECT() *MockBatchUpsertArticleTagsPortMockRecorder {
	return m.recorder
}

// BatchUpsertArticleTags mocks base method.
func (m *MockBatchUpsertArticleTagsPort) BatchUpsertArticleTags(ctx context.Context, items []internal_tag_port.BatchUpsertItem) (int32, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BatchUpsertArticleTags", ctx, items)
	ret0, _ := ret[0].(int32)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchUpsertArticleTags indicates an expected call of BatchUpsertArticleTags.
func (mr *MockBatchUpsertArticleTagsPortMockRecorder) BatchUpsertArticleTags(ctx, items any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchUpsertArticleTags", reflect.TypeOf((*MockBatchUpsertArticleTagsPort)(nil).BatchUpsertArticleTags), ctx, items)
}

// MockListUntaggedArticlesPort is a mock of ListUntaggedArticlesPort interface.
type MockListUntaggedArticlesPort struct {
	ctrl     *gomock.Controller
	recorder *MockListUntaggedArticlesPortMockRecorder
	isgomock struct{}
}

// MockListUntaggedArticlesPortMockRecorder is the mock recorder for MockListUntaggedArticlesPort.
type MockListUntaggedArticlesPortMockRecorder struct {
	mock *MockListUntaggedArticlesPort
}

// NewMockListUntaggedArticlesPort creates a new mock instance.
func NewMockListUntaggedArticlesPort(ctrl *gomock.Controller) *MockListUntaggedArticlesPort {
	mock := &MockListUntaggedArticlesPort{ctrl: ctrl}
	mock.recorder = &MockListUntaggedArticlesPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockListUntaggedArticlesPort) EXPECT() *MockListUntaggedArticlesPortMockRecorder {
	return m.recorder
}

// ListUntaggedArticles mocks base method.
func (m *MockListUntaggedArticlesPort) ListUntaggedArticles(ctx context.Context, limit, offset int) ([]internal_tag_port.UntaggedArticle, int32, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListUntaggedArticles", ctx, limit, offset)
	ret0, _ := ret[0].([]internal_tag_port.UntaggedArticle)
	ret1, _ := ret[1].(int32)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListUntaggedArticles indicates an expected call of ListUntaggedArticles.
func (mr *MockListUntaggedArticlesPortMockRecorder) ListUntaggedArticles(ctx, limit, offset any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListUntaggedArticles", reflect.TypeOf((*MockListUntaggedArticlesPort)(nil).ListUntaggedArticles), ctx, limit, offset)
}
