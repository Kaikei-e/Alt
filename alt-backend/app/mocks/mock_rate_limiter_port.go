// Code generated by MockGen. DO NOT EDIT.
// Source: ./alt-backend/app/port/rate_limiter_port/rate_limiter_port.go
//
// Generated by this command:
//
//	mockgen -source=./alt-backend/app/port/rate_limiter_port/rate_limiter_port.go -destination=./alt-backend/app/mocks/mock_rate_limiter_port.go -package=mocks RateLimiterPort
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"
	time "time"

	gomock "go.uber.org/mock/gomock"
)

// MockRateLimiterPort is a mock of RateLimiterPort interface.
type MockRateLimiterPort struct {
	ctrl     *gomock.Controller
	recorder *MockRateLimiterPortMockRecorder
	isgomock struct{}
}

// MockRateLimiterPortMockRecorder is the mock recorder for MockRateLimiterPort.
type MockRateLimiterPortMockRecorder struct {
	mock *MockRateLimiterPort
}

// NewMockRateLimiterPort creates a new mock instance.
func NewMockRateLimiterPort(ctrl *gomock.Controller) *MockRateLimiterPort {
	mock := &MockRateLimiterPort{ctrl: ctrl}
	mock.recorder = &MockRateLimiterPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRateLimiterPort) EXPECT() *MockRateLimiterPortMockRecorder {
	return m.recorder
}

// GetNextAvailableTime mocks base method.
func (m *MockRateLimiterPort) GetNextAvailableTime(host string) time.Time {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetNextAvailableTime", host)
	ret0, _ := ret[0].(time.Time)
	return ret0
}

// GetNextAvailableTime indicates an expected call of GetNextAvailableTime.
func (mr *MockRateLimiterPortMockRecorder) GetNextAvailableTime(host any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNextAvailableTime", reflect.TypeOf((*MockRateLimiterPort)(nil).GetNextAvailableTime), host)
}

// GetRemainingRequests mocks base method.
func (m *MockRateLimiterPort) GetRemainingRequests(host string) int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRemainingRequests", host)
	ret0, _ := ret[0].(int)
	return ret0
}

// GetRemainingRequests indicates an expected call of GetRemainingRequests.
func (mr *MockRateLimiterPortMockRecorder) GetRemainingRequests(host any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRemainingRequests", reflect.TypeOf((*MockRateLimiterPort)(nil).GetRemainingRequests), host)
}

// WaitForHost mocks base method.
func (m *MockRateLimiterPort) WaitForHost(ctx context.Context, host string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WaitForHost", ctx, host)
	ret0, _ := ret[0].(error)
	return ret0
}

// WaitForHost indicates an expected call of WaitForHost.
func (mr *MockRateLimiterPortMockRecorder) WaitForHost(ctx, host any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitForHost", reflect.TypeOf((*MockRateLimiterPort)(nil).WaitForHost), ctx, host)
}

// WaitForURL mocks base method.
func (m *MockRateLimiterPort) WaitForURL(ctx context.Context, url string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WaitForURL", ctx, url)
	ret0, _ := ret[0].(error)
	return ret0
}

// WaitForURL indicates an expected call of WaitForURL.
func (mr *MockRateLimiterPortMockRecorder) WaitForURL(ctx, url any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitForURL", reflect.TypeOf((*MockRateLimiterPort)(nil).WaitForURL), ctx, url)
}
