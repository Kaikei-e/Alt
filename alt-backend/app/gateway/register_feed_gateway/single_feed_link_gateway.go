package register_feed_gateway

import (
	"alt/driver/alt_db"
	"alt/utils/logger"
	"context"
	"crypto/tls"
	"errors"
	"fmt"
	"math"
	"net"
	"net/http"
	"net/url"
	"os"
	"strings"
	"time"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/mmcdole/gofeed"
)

// ProxyConfig holds proxy configuration
type ProxyConfig struct {
	ProxyURL string
	Enabled  bool
}

// getProxyConfigFromEnv retrieves proxy configuration from environment variables
func getProxyConfigFromEnv() *ProxyConfig {
	proxyURL := os.Getenv("HTTP_PROXY")
	if proxyURL == "" {
		proxyURL = "http://nginx-external.alt-ingress.svc.cluster.local:8888"
	}

	proxyEnabled := os.Getenv("PROXY_ENABLED")
	enabled := proxyEnabled == "true"

	return &ProxyConfig{
		ProxyURL: proxyURL,
		Enabled:  enabled,
	}
}

// EnvoyProxyConfig holds Envoy proxy configuration
type EnvoyProxyConfig struct {
	EnvoyURL string
	Enabled  bool
}

// ProxyMode represents different proxy operation modes
type ProxyMode string

const (
	ProxyModeSidecar ProxyMode = "sidecar"
	ProxyModeEnvoy   ProxyMode = "envoy"
	ProxyModeNginx   ProxyMode = "nginx"
	ProxyModeDisabled ProxyMode = "disabled"
)

// ProxyStrategy represents the proxy configuration strategy
type ProxyStrategy struct {
	Mode         ProxyMode
	BaseURL      string
	PathTemplate string
	Enabled      bool
}

// getProxyStrategy determines the appropriate proxy strategy based on environment configuration
func getProxyStrategy() *ProxyStrategy {
	// Priority order: SIDECAR > ENVOY > NGINX > DISABLED
	if os.Getenv("SIDECAR_PROXY_ENABLED") == "true" {
		baseURL := os.Getenv("SIDECAR_PROXY_URL")
		if baseURL == "" {
			baseURL = "http://envoy-proxy.alt-apps.svc.cluster.local:8085"
		}
		logger.SafeInfo("Proxy strategy: SIDECAR mode selected",
			"base_url", baseURL,
			"path_template", "/proxy/{scheme}://{host}{path}")
		return &ProxyStrategy{
			Mode:         ProxyModeSidecar,
			BaseURL:      baseURL,
			PathTemplate: "/proxy/{scheme}://{host}{path}",
			Enabled:      true,
		}
	}

	if os.Getenv("ENVOY_PROXY_ENABLED") == "true" {
		baseURL := os.Getenv("ENVOY_PROXY_URL")
		if baseURL == "" {
			baseURL = "http://envoy-proxy.alt-apps.svc.cluster.local:8080"
		}
		logger.SafeInfo("Proxy strategy: ENVOY mode selected",
			"base_url", baseURL,
			"path_template", "/proxy/{scheme}://{host}{path}")
		return &ProxyStrategy{
			Mode:         ProxyModeEnvoy,
			BaseURL:      baseURL,
			PathTemplate: "/proxy/{scheme}://{host}{path}",
			Enabled:      true,
		}
	}

	if os.Getenv("NGINX_PROXY_ENABLED") == "true" {
		baseURL := os.Getenv("NGINX_PROXY_URL")
		if baseURL == "" {
			baseURL = "http://nginx-external.alt-ingress.svc.cluster.local:8889"
		}
		logger.SafeInfo("Proxy strategy: NGINX mode selected",
			"base_url", baseURL,
			"path_template", "/rss-proxy/{scheme}://{host}{path}")
		return &ProxyStrategy{
			Mode:         ProxyModeNginx,
			BaseURL:      baseURL,
			PathTemplate: "/rss-proxy/{scheme}://{host}{path}",
			Enabled:      true,
		}
	}

	logger.SafeInfo("Proxy strategy: DISABLED mode - direct connection will be used")
	return &ProxyStrategy{
		Mode:         ProxyModeDisabled,
		BaseURL:      "",
		PathTemplate: "",
		Enabled:      false,
	}
}

// getEnvoyProxyConfigFromEnv retrieves proxy configuration from environment variables
// REFACTORED: Now uses flexible proxy strategy pattern
func getEnvoyProxyConfigFromEnv() *EnvoyProxyConfig {
	strategy := getProxyStrategy()
	
	// Convert strategy to legacy EnvoyProxyConfig for backward compatibility
	if !strategy.Enabled {
		return &EnvoyProxyConfig{
			EnvoyURL: "",
			Enabled:  false,
		}
	}

	return &EnvoyProxyConfig{
		EnvoyURL: strategy.BaseURL,
		Enabled:  strategy.Enabled,
	}
}

// RSSFeedFetcher interface for mocking RSS feed fetching
type RSSFeedFetcher interface {
	FetchRSSFeed(ctx context.Context, link string) (*gofeed.Feed, error)
}

// DefaultRSSFeedFetcher implements RSSFeedFetcher with actual HTTP requests
type DefaultRSSFeedFetcher struct{
	proxyConfig      *ProxyConfig
	envoyProxyConfig *EnvoyProxyConfig
	proxyStrategy    *ProxyStrategy
}

// NewDefaultRSSFeedFetcher creates a new DefaultRSSFeedFetcher with proxy configuration
func NewDefaultRSSFeedFetcher() *DefaultRSSFeedFetcher {
	strategy := getProxyStrategy()
	return &DefaultRSSFeedFetcher{
		proxyConfig:      getProxyConfigFromEnv(),
		envoyProxyConfig: getEnvoyProxyConfigFromEnv(),
		proxyStrategy:    strategy,
	}
}

// EnvoyProxyRoundTripper fixes Host header for Envoy Dynamic Forward Proxy
type EnvoyProxyRoundTripper struct {
	transport http.RoundTripper
}

func (ert *EnvoyProxyRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
	// Check if this is an Envoy proxy request (/proxy/https://domain.com/path)
	if strings.Contains(req.URL.Path, "/proxy/https://") || strings.Contains(req.URL.Path, "/proxy/http://") {
		// Extract target domain from proxy path
		// /proxy/https://zenn.dev/topics/typescript/feed -> zenn.dev
		pathParts := strings.SplitN(req.URL.Path, "/proxy/", 2)
		if len(pathParts) == 2 {
			targetURL := pathParts[1]
			if parsedTarget, err := url.Parse(targetURL); err == nil {
				// Set Host header to target domain for proper TLS SNI
				req.Host = parsedTarget.Host
				req.Header.Set("Host", parsedTarget.Host)
				// CRITICAL FIX: Add X-Target-Domain header required by Envoy proxy route matching
				req.Header.Set("X-Target-Domain", parsedTarget.Host)
				logger.SafeInfo("Fixed Host header for Envoy Dynamic Forward Proxy",
					"original_host", req.URL.Host,
					"target_host", parsedTarget.Host,
					"request_url", req.URL.String())
			}
		}
	}
	return ert.transport.RoundTrip(req)
}

// createHTTPClient creates an HTTP client with HTTPS direct connection (ROOT FIX)
func (f *DefaultRSSFeedFetcher) createHTTPClient() *http.Client {
	transport := &http.Transport{
		// ROOT FIX: 企業環境のHTTPSアクセス最適化
		TLSClientConfig: &tls.Config{
			InsecureSkipVerify: false,
			MinVersion:         tls.VersionTLS12,
		},
		DialContext: (&net.Dialer{
			Timeout:   30 * time.Second,
			KeepAlive: 30 * time.Second,
		}).DialContext,
		MaxIdleConns:        100,
		IdleConnTimeout:     90 * time.Second,
		TLSHandshakeTimeout: 30 * time.Second,
	}

	// ULTRATHINK ROOT FIX: nginx-external proxyがCONNECTメソッド未サポートのため直接HTTPS接続使用
	if f.proxyConfig != nil && f.proxyConfig.Enabled && f.proxyConfig.ProxyURL != "" {
		logger.SafeInfo("Using direct HTTPS connection due to proxy CONNECT method limitation",
			"proxy_enabled", f.proxyConfig.Enabled,
			"proxy_url", f.proxyConfig.ProxyURL,
			"reason", "nginx-external does not support CONNECT method for HTTPS tunneling")
		// NOTE: transport.Proxy = http.ProxyURL(proxyURL) を一時的に無効化
		// HTTPS URLs取得時にCONNECT method失敗（400 Bad Request）を回避
	}

	// Wrap transport with Envoy proxy Host header fixer
	roundTripper := &EnvoyProxyRoundTripper{
		transport: transport,
	}

	return &http.Client{
		Timeout:   60 * time.Second, // タイムアウト延長
		Transport: roundTripper,
	}
}

func (f *DefaultRSSFeedFetcher) FetchRSSFeed(ctx context.Context, link string) (*gofeed.Feed, error) {
	// ISSUE_RESOLVE_PLAN.md ROOT SOLUTION: Use proxy-sidecar exclusively
	// This eliminates upstream="10.96.32.212:8080" and achieves upstream="zenn.dev:443"
	
	logger.SafeInfo("DEBUG: Proxy strategy configuration check",
		"strategy_mode", string(f.proxyStrategy.Mode),
		"strategy_enabled", f.proxyStrategy.Enabled,
		"strategy_base_url", f.proxyStrategy.BaseURL,
		"strategy_path_template", f.proxyStrategy.PathTemplate)

	// ROOT SOLUTION: Use strategic proxy configuration based on environment
	if f.proxyStrategy.Enabled {
		proxyURL := f.convertToProxyURL(link, f.proxyStrategy)
		
		// Extract expected upstream from original URL (without port 443 for HTTPS)
		u, _ := url.Parse(link)
		expectedUpstream := u.Host
		
		logger.SafeInfo("Using strategic proxy for RSS fetching",
			"strategy_mode", string(f.proxyStrategy.Mode),
			"original_url", link,
			"proxy_url", proxyURL,
			"expected_upstream", expectedUpstream)

		return f.fetchRSSFeedWithRetry(ctx, proxyURL)
	}

	// Fallback: Direct connection when no proxy is configured
	logger.SafeInfo("Using direct RSS feed connection (no proxy configured)",
		"original_url", link)

	return f.fetchRSSFeedWithRetry(ctx, link)
}

// convertToProxyURL converts external RSS URLs to appropriate proxy routes based on strategy
// SECURITY: This implements secure URL construction following CVE-2024-34155 mitigations
// and Go 1.19.1 JoinPath security fixes to prevent directory traversal attacks
func (f *DefaultRSSFeedFetcher) convertToProxyURL(originalURL string, strategy *ProxyStrategy) string {
	// SECURITY: Parse original URL using net/url to prevent injection attacks
	u, err := url.Parse(originalURL)
	if err != nil {
		logger.SafeError("Failed to parse original URL for proxy conversion",
			"url", originalURL,
			"strategy_mode", string(strategy.Mode),
			"error", err.Error())
		return originalURL
	}

	// SECURITY: Validate URL components to prevent malicious inputs
	if u.Scheme == "" || u.Host == "" {
		logger.SafeError("Invalid URL components detected",
			"url", originalURL,
			"scheme", u.Scheme,
			"host", u.Host)
		return originalURL
	}

	// SECURITY: Use net/url.JoinPath (Go 1.19.1+) for secure path construction
	// This automatically handles directory traversal prevention and path cleaning
	baseURL, err := url.Parse(strategy.BaseURL)
	if err != nil {
		logger.SafeError("Failed to parse base URL for proxy strategy",
			"base_url", strategy.BaseURL,
			"error", err.Error())
		return originalURL
	}

	// SECURITY: Construct target URL components safely
	// Format: /proxy/https://domain.com/path
	targetURLStr := u.Scheme + "://" + u.Host + u.Path
	if u.RawQuery != "" {
		targetURLStr += "?" + u.RawQuery
	}

	// SECURITY: Use JoinPath to safely combine base URL with proxy path
	// This prevents directory traversal and ensures proper path cleaning
	proxyURL := baseURL.JoinPath("proxy", targetURLStr)

	logger.SafeInfo("RSS URL converted using secure proxy strategy",
		"strategy_mode", string(strategy.Mode),
		"original_url", originalURL,
		"proxy_url", proxyURL.String(),
		"target_host", u.Host,
		"base_url", strategy.BaseURL,
		"security", "CVE-2024-34155_mitigated")

	return proxyURL.String()
}

// convertToEgressGatewayURL converts external RSS URLs to nginx-external egress gateway routes
func (f *DefaultRSSFeedFetcher) convertToEgressGatewayURL(originalURL string) string {
	// Parse original URL
	u, err := url.Parse(originalURL)
	if err != nil {
		logger.SafeWarn("Failed to parse RSS URL, using original",
			"url", originalURL,
			"error", err.Error())
		return originalURL
	}

	// Only convert HTTP/HTTPS URLs (security requirement)
	if u.Scheme != "https" && u.Scheme != "http" {
		logger.SafeWarn("Non-HTTP(S) RSS URL detected, using original",
			"url", originalURL,
			"scheme", u.Scheme)
		return originalURL
	}

	// Get egress gateway base URL from environment variable
	egressGatewayBase := os.Getenv("EGRESS_GATEWAY_URL")
	if egressGatewayBase == "" {
		egressGatewayBase = "http://nginx-external.alt-ingress.svc.cluster.local:8889"
	}
	
	egressPath := fmt.Sprintf("/rss-proxy/%s://%s%s", u.Scheme, u.Host, u.Path)
	if u.RawQuery != "" {
		egressPath += "?" + u.RawQuery
	}

	egressURL := egressGatewayBase + egressPath

	logger.SafeInfo("RSS URL converted to egress gateway route",
		"original_url", originalURL,
		"egress_url", egressURL,
		"target_host", u.Host,
		"egress_gateway_base", egressGatewayBase)

	return egressURL
}

// convertToEnvoyProxyURL converts external RSS URLs to Envoy proxy routes
func (f *DefaultRSSFeedFetcher) convertToEnvoyProxyURL(originalURL string) string {
	// Parse original URL
	u, err := url.Parse(originalURL)
	if err != nil {
		logger.SafeWarn("Failed to parse RSS URL for Envoy proxy, using original",
			"url", originalURL,
			"error", err.Error())
		return originalURL
	}

	// Only convert HTTP/HTTPS URLs (security requirement)
	if u.Scheme != "https" && u.Scheme != "http" {
		logger.SafeWarn("Non-HTTP(S) RSS URL detected for Envoy proxy, using original",
			"url", originalURL,
			"scheme", u.Scheme)
		return originalURL
	}

	// Get Envoy proxy base URL from environment variable
	envoyProxyBase := f.envoyProxyConfig.EnvoyURL

	// Envoy Dynamic Forward Proxy format: /proxy/https://domain.com/path
	envoyPath := fmt.Sprintf("/proxy/%s://%s%s", u.Scheme, u.Host, u.Path)
	if u.RawQuery != "" {
		envoyPath += "?" + u.RawQuery
	}

	envoyURL := envoyProxyBase + envoyPath

	logger.SafeInfo("RSS URL converted to Envoy proxy route",
		"original_url", originalURL,
		"envoy_url", envoyURL,
		"target_host", u.Host,
		"envoy_proxy_base", envoyProxyBase)

	return envoyURL
}

// isRetryableError determines if an error should trigger a retry
func isRetryableError(err error) bool {
	errStr := err.Error()
	return strings.Contains(errStr, "timeout") ||
		strings.Contains(errStr, "deadline exceeded") ||
		strings.Contains(errStr, "connection refused") ||
		strings.Contains(errStr, "no such host") ||
		strings.Contains(errStr, "502") ||
		strings.Contains(errStr, "503") ||
		strings.Contains(errStr, "504")
}

// fetchRSSFeedWithRetry performs RSS feed fetching with exponential backoff retry
func (f *DefaultRSSFeedFetcher) fetchRSSFeedWithRetry(ctx context.Context, link string) (*gofeed.Feed, error) {
	const maxRetries = 3
	const initialDelay = 2 * time.Second
	const maxDelay = 30 * time.Second

	// Create HTTP client with proxy configuration if enabled
	httpClient := f.createHTTPClient()

	fp := gofeed.NewParser()
	fp.Client = httpClient

	// Use context with extended 60 second timeout for additional protection
	feedCtx, cancel := context.WithTimeout(ctx, 60*time.Second)
	defer cancel()

	var lastErr error
	for attempt := 0; attempt < maxRetries; attempt++ {
		if attempt > 0 {
			// Calculate exponential backoff delay
			delay := time.Duration(float64(initialDelay) * math.Pow(2, float64(attempt-1)))
			if delay > maxDelay {
				delay = maxDelay
			}

			logger.SafeInfo("Retrying RSS feed fetch",
				"url", link,
				"attempt", attempt+1,
				"delay_seconds", delay.Seconds())

			select {
			case <-time.After(delay):
			case <-feedCtx.Done():
				return nil, feedCtx.Err()
			}
		}

		feed, err := fp.ParseURLWithContext(link, feedCtx)
		if err == nil {
			if attempt > 0 {
				logger.SafeInfo("RSS feed fetch succeeded after retry",
					"url", link,
					"attempts", attempt+1)
			}
			return feed, nil
		}

		lastErr = err
		if !isRetryableError(err) {
			logger.SafeWarn("Non-retryable error, not retrying",
				"url", link,
				"error", err.Error())
			break
		}

		logger.SafeWarn("RSS feed fetch failed, will retry",
			"url", link,
			"attempt", attempt+1,
			"error", err.Error())
	}

	return nil, lastErr
}

type RegisterFeedGateway struct {
	alt_db      *alt_db.AltDBRepository
	feedFetcher RSSFeedFetcher
}

func NewRegisterFeedLinkGateway(pool *pgxpool.Pool) *RegisterFeedGateway {
	return &RegisterFeedGateway{
		alt_db:      alt_db.NewAltDBRepositoryWithPool(pool),
		feedFetcher: NewDefaultRSSFeedFetcher(),
	}
}

// NewRegisterFeedLinkGatewayWithFetcher creates a gateway with a custom RSS feed fetcher (for testing)
func NewRegisterFeedLinkGatewayWithFetcher(pool *pgxpool.Pool, fetcher RSSFeedFetcher) *RegisterFeedGateway {
	return &RegisterFeedGateway{
		alt_db:      alt_db.NewAltDBRepositoryWithPool(pool),
		feedFetcher: fetcher,
	}
}

func (g *RegisterFeedGateway) RegisterRSSFeedLink(ctx context.Context, link string) error {
	// Parse and validate the URL
	parsedURL, err := url.Parse(link)
	if err != nil {
		return errors.New("invalid URL format")
	}

	// Ensure the URL has a scheme
	if parsedURL.Scheme == "" {
		return errors.New("URL must include a scheme (http or https)")
	}

	// Try to fetch and parse the RSS feed with retry mechanism
	feed, err := g.feedFetcher.FetchRSSFeed(ctx, link)
	if err != nil {
		if strings.Contains(err.Error(), "no such host") || strings.Contains(err.Error(), "connection refused") {
			return errors.New("could not reach the RSS feed URL")
		}
		if strings.Contains(err.Error(), "timeout") || strings.Contains(err.Error(), "deadline exceeded") {
			return errors.New("RSS feed fetch timeout - server took too long to respond")
		}
		return errors.New("invalid RSS feed format")
	}

	if feed.Link == "" {
		logger.SafeWarn("RSS feed link is empty, using the link from the RSS feed", "link", link)
		feed.Link = link
	}

	if feed.FeedLink == "" {
		logger.SafeWarn("RSS feed feed link is empty, using the link from the RSS feed", "link", feed.Link)
		feed.FeedLink = link
	}

	// Check database connection only after RSS feed validation
	if g.alt_db == nil {
		return errors.New("database connection not available")
	}

	err = g.alt_db.RegisterRSSFeedLink(ctx, feed.FeedLink)
	if err != nil {
		if errors.Is(err, pgx.ErrTxClosed) {
			logger.SafeError("Failed to register RSS feed link", "error", err)
			return errors.New("failed to register RSS feed link")
		}
		logger.SafeError("Error registering RSS feed link", "error", err)
		return errors.New("failed to register RSS feed link")
	}
	logger.SafeInfo("RSS feed link registered", "link", link)

	return nil
}
