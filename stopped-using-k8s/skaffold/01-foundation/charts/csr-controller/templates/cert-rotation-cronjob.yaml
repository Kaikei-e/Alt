{{- if .Values.csrController.certRotation.enabled }}
apiVersion: batch/v1
kind: CronJob
metadata:
  name: {{ include "csr-controller.fullname" . }}-cert-rotation
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "csr-controller.labels" . | nindent 4 }}
    app.kubernetes.io/component: cert-rotation
spec:
  schedule: {{ .Values.csrController.certRotation.schedule | quote }}
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 1
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            {{- include "csr-controller.selectorLabels" . | nindent 12 }}
            app.kubernetes.io/component: cert-rotation
        spec:
          restartPolicy: OnFailure
          serviceAccountName: {{ include "csr-controller.serviceAccountName" . }}
          securityContext:
            runAsNonRoot: true
            runAsUser: 65534
            fsGroup: 65534
          containers:
          - name: cert-rotator
            image: {{ .Values.csrController.certRotation.image.repository }}:{{ .Values.csrController.certRotation.image.tag }}
            imagePullPolicy: {{ .Values.csrController.certRotation.image.pullPolicy }}
            env:
            - name: CERT_RENEWAL_THRESHOLD
              value: {{ .Values.csrController.certRotation.renewalThreshold | quote }}
            - name: NAMESPACES
              value: {{ join "," .Values.csrController.certRotation.namespaces }}
            - name: SIGNER_NAME
              value: {{ include "csr-controller.signerName" . }}
            - name: DRY_RUN
              value: {{ .Values.csrController.certRotation.dryRun | quote }}
            - name: LOG_LEVEL
              value: {{ .Values.csrController.certRotation.logLevel | quote }}
            command:
            - /bin/sh
            - -c
            - |
              echo "Starting certificate rotation check..."
              echo "Renewal threshold: $CERT_RENEWAL_THRESHOLD"
              echo "Target namespaces: $NAMESPACES"
              echo "Signer name: $SIGNER_NAME"
              echo "Dry run mode: $DRY_RUN"
              
              # Function to check certificate expiry
              check_cert_expiry() {
                local secret_name=$1
                local namespace=$2
                local threshold=$3
                
                echo "Checking certificate expiry for $secret_name in namespace $namespace"
                
                # Get certificate from secret
                cert_data=$(kubectl get secret $secret_name -n $namespace -o jsonpath='{.data.tls\.crt}' 2>/dev/null)
                if [ $? -ne 0 ] || [ -z "$cert_data" ]; then
                  echo "Warning: Certificate not found in secret $secret_name"
                  return 1
                fi
                
                # Decode and check expiry
                echo "$cert_data" | base64 -d > /tmp/cert.pem
                if ! openssl x509 -in /tmp/cert.pem -noout -text >/dev/null 2>&1; then
                  echo "Error: Invalid certificate format in secret $secret_name"
                  return 1
                fi
                
                # Get expiry date
                expiry_date=$(openssl x509 -in /tmp/cert.pem -noout -enddate | cut -d= -f2)
                expiry_epoch=$(date -d "$expiry_date" +%s)
                current_epoch=$(date +%s)
                threshold_epoch=$((current_epoch + $(echo $threshold | sed 's/h//' | awk '{print $1*3600}')))
                
                if [ $expiry_epoch -lt $threshold_epoch ]; then
                  echo "Certificate $secret_name expires soon: $expiry_date"
                  return 0
                else
                  echo "Certificate $secret_name is valid until: $expiry_date"
                  return 1
                fi
              }
              
              # Function to rotate certificate
              rotate_certificate() {
                local secret_name=$1
                local namespace=$2
                local service_name=$3
                
                echo "Rotating certificate for $service_name in namespace $namespace"
                
                if [ "$DRY_RUN" = "true" ]; then
                  echo "DRY RUN: Would rotate certificate for $service_name"
                  return 0
                fi
                
                # Generate new private key
                openssl genrsa -out /tmp/new_private.key 2048
                
                # Create new CSR
                cat > /tmp/csr.conf <<EOF
              [req]
              distinguished_name = req_distinguished_name
              req_extensions = v3_req
              prompt = no
              
              [req_distinguished_name]
              CN = $service_name
              O = Alt RSS Reader
              
              [v3_req]
              keyUsage = keyEncipherment, dataEncipherment
              extendedKeyUsage = serverAuth
              subjectAltName = @alt_names
              
              [alt_names]
              DNS.1 = $service_name
              DNS.2 = $service_name.$namespace.svc.cluster.local
              DNS.3 = localhost
              IP.1 = 127.0.0.1
              EOF
                
                # Generate CSR
                openssl req -new -key /tmp/new_private.key -out /tmp/new_certificate.csr -config /tmp/csr.conf
                
                # Create new CertificateSigningRequest
                csr_name="$service_name-$namespace-$(date +%s)"
                cat > /tmp/k8s_csr.yaml <<EOF
              apiVersion: certificates.k8s.io/v1
              kind: CertificateSigningRequest
              metadata:
                name: $csr_name
                labels:
                  app.kubernetes.io/managed-by: cert-rotation
                  app.kubernetes.io/component: ssl-certificate
                  app.kubernetes.io/service: $service_name
                  app.kubernetes.io/namespace: $namespace
              spec:
                request: $(cat /tmp/new_certificate.csr | base64 | tr -d '\n')
                signerName: $SIGNER_NAME
                usages:
                - digital signature
                - key encipherment
                - server auth
              EOF
                
                # Submit CSR
                if kubectl apply -f /tmp/k8s_csr.yaml; then
                  echo "CSR submitted successfully: $csr_name"
                  
                  # Wait for CSR to be approved and signed
                  echo "Waiting for CSR approval..."
                  for i in {1..30}; do
                    if kubectl get csr $csr_name -o jsonpath='{.status.certificate}' | grep -q "LS0t"; then
                      echo "CSR approved and signed"
                      break
                    fi
                    sleep 2
                  done
                  
                  # Get signed certificate
                  signed_cert=$(kubectl get csr $csr_name -o jsonpath='{.status.certificate}')
                  if [ -n "$signed_cert" ]; then
                    # Update secret with new certificate
                    kubectl patch secret $secret_name -n $namespace --type='merge' -p="{\"data\":{\"tls.crt\":\"$signed_cert\",\"tls.key\":\"$(cat /tmp/new_private.key | base64 | tr -d '\n')\"}}"
                    echo "Certificate rotated successfully for $service_name"
                    
                    # Clean up CSR
                    kubectl delete csr $csr_name
                  else
                    echo "Error: Failed to get signed certificate"
                    return 1
                  fi
                else
                  echo "Error: Failed to submit CSR"
                  return 1
                fi
              }
              
              # Main rotation loop
              for namespace in $(echo $NAMESPACES | tr ',' ' '); do
                echo "Processing namespace: $namespace"
                
                # Get all SSL certificate secrets
                secrets=$(kubectl get secrets -n $namespace -l app.kubernetes.io/component=ssl-certificate -o jsonpath='{.items[*].metadata.name}')
                
                for secret in $secrets; do
                  if check_cert_expiry $secret $namespace $CERT_RENEWAL_THRESHOLD; then
                    # Extract service name from secret name
                    service_name=$(echo $secret | sed 's/-ssl-certs-prod$//' | sed 's/-tls-cert$//')
                    rotate_certificate $secret $namespace $service_name
                  fi
                done
              done
              
              echo "Certificate rotation check completed"
            resources:
              limits:
                cpu: 100m
                memory: 128Mi
              requests:
                cpu: 50m
                memory: 64Mi
            securityContext:
              runAsNonRoot: true
              runAsUser: 65534
              allowPrivilegeEscalation: false
              readOnlyRootFilesystem: true
              capabilities:
                drop:
                - ALL
            volumeMounts:
            - name: tmp
              mountPath: /tmp
          volumes:
          - name: tmp
            emptyDir: {}
          {{- with .Values.nodeSelector }}
          nodeSelector:
            {{- toYaml . | nindent 12 }}
          {{- end }}
          {{- with .Values.affinity }}
          affinity:
            {{- toYaml . | nindent 12 }}
          {{- end }}
          {{- with .Values.tolerations }}
          tolerations:
            {{- toYaml . | nindent 12 }}
          {{- end }}
{{- end }}