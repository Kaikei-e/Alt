{{- if .Values.csrController.certLifecycle.enabled }}
apiVersion: batch/v1
kind: CronJob
metadata:
  name: {{ include "csr-controller.fullname" . }}-cert-lifecycle
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "csr-controller.labels" . | nindent 4 }}
    app.kubernetes.io/component: cert-lifecycle
spec:
  schedule: {{ .Values.csrController.certLifecycle.schedule | quote }}
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            {{- include "csr-controller.selectorLabels" . | nindent 12 }}
            app.kubernetes.io/component: cert-lifecycle
        spec:
          restartPolicy: OnFailure
          serviceAccountName: {{ include "csr-controller.serviceAccountName" . }}
          securityContext:
            runAsNonRoot: true
            runAsUser: 65534
            fsGroup: 65534
          containers:
          - name: cert-lifecycle
            image: {{ .Values.csrController.certLifecycle.image.repository }}:{{ .Values.csrController.certLifecycle.image.tag }}
            imagePullPolicy: {{ .Values.csrController.certLifecycle.image.pullPolicy }}
            env:
            - name: NAMESPACES
              value: {{ join "," .Values.csrController.certLifecycle.namespaces }}
            - name: SIGNER_NAME
              value: {{ include "csr-controller.signerName" . }}
            - name: VALIDATION_THRESHOLD
              value: {{ .Values.csrController.certLifecycle.validationThreshold | quote }}
            - name: AUTO_REPAIR
              value: {{ .Values.csrController.certLifecycle.autoRepair | quote }}
            - name: LOG_LEVEL
              value: {{ .Values.csrController.certLifecycle.logLevel | quote }}
            - name: DRY_RUN
              value: {{ .Values.csrController.certLifecycle.dryRun | quote }}
            command:
            - /bin/sh
            - -c
            - |
              echo "Starting certificate lifecycle management..."
              echo "Namespaces: $NAMESPACES"
              echo "Signer name: $SIGNER_NAME"
              echo "Validation threshold: $VALIDATION_THRESHOLD"
              echo "Auto repair: $AUTO_REPAIR"
              echo "Dry run: $DRY_RUN"
              
              # Function to validate certificate chain
              validate_cert_chain() {
                local cert_name=$1
                local namespace=$2
                local cert_data=$3
                local ca_data=$4
                
                echo "Validating certificate chain for $cert_name in $namespace"
                
                # Save certificates to temporary files
                echo "$cert_data" | base64 -d > /tmp/server.crt
                echo "$ca_data" | base64 -d > /tmp/ca.crt
                
                # Validate certificate format
                if ! openssl x509 -in /tmp/server.crt -noout -text >/dev/null 2>&1; then
                  echo "ERROR: Invalid certificate format for $cert_name"
                  return 1
                fi
                
                # Validate CA certificate format
                if ! openssl x509 -in /tmp/ca.crt -noout -text >/dev/null 2>&1; then
                  echo "ERROR: Invalid CA certificate format for $cert_name"
                  return 1
                fi
                
                # Verify certificate chain
                if ! openssl verify -CAfile /tmp/ca.crt /tmp/server.crt >/dev/null 2>&1; then
                  echo "ERROR: Certificate chain validation failed for $cert_name"
                  return 1
                fi
                
                # Check certificate expiry
                current_time=$(date +%s)
                cert_expiry=$(openssl x509 -in /tmp/server.crt -noout -enddate | cut -d= -f2)
                cert_expiry_time=$(date -d "$cert_expiry" +%s)
                
                if [ $cert_expiry_time -lt $current_time ]; then
                  echo "ERROR: Certificate has expired for $cert_name"
                  return 1
                fi
                
                # Check if certificate is expiring soon (within threshold)
                threshold_time=$((current_time + $(echo $VALIDATION_THRESHOLD | sed 's/h//' | awk '{print $1*3600}')))
                if [ $cert_expiry_time -lt $threshold_time ]; then
                  echo "WARNING: Certificate expires soon for $cert_name"
                  return 2
                fi
                
                echo "Certificate validation successful for $cert_name"
                return 0
              }
              
              # Function to check certificate key pair
              validate_key_pair() {
                local cert_name=$1
                local namespace=$2
                local cert_data=$3
                local key_data=$4
                
                echo "Validating key pair for $cert_name in $namespace"
                
                # Save certificate and key to temporary files
                echo "$cert_data" | base64 -d > /tmp/server.crt
                echo "$key_data" | base64 -d > /tmp/server.key
                
                # Validate private key format
                if ! openssl rsa -in /tmp/server.key -noout -check >/dev/null 2>&1; then
                  echo "ERROR: Invalid private key format for $cert_name"
                  return 1
                fi
                
                # Extract public key from certificate
                openssl x509 -in /tmp/server.crt -noout -pubkey > /tmp/cert_pubkey.pem
                
                # Extract public key from private key
                openssl rsa -in /tmp/server.key -pubout > /tmp/key_pubkey.pem
                
                # Compare public keys
                if ! cmp -s /tmp/cert_pubkey.pem /tmp/key_pubkey.pem; then
                  echo "ERROR: Certificate and private key do not match for $cert_name"
                  return 1
                fi
                
                echo "Key pair validation successful for $cert_name"
                return 0
              }
              
              # Function to check certificate DNS names
              validate_dns_names() {
                local cert_name=$1
                local namespace=$2
                local cert_data=$3
                local expected_dns_names=$4
                
                echo "Validating DNS names for $cert_name in $namespace"
                
                # Save certificate to temporary file
                echo "$cert_data" | base64 -d > /tmp/server.crt
                
                # Extract DNS names from certificate
                cert_dns_names=$(openssl x509 -in /tmp/server.crt -noout -text | grep -A 1 "Subject Alternative Name" | tail -n 1 | tr ',' '\n' | grep "DNS:" | sed 's/DNS://g' | tr -d ' ')
                
                # Check if required DNS names are present
                for expected_dns in $(echo $expected_dns_names | tr ',' '\n'); do
                  if ! echo "$cert_dns_names" | grep -q "^$expected_dns$"; then
                    echo "WARNING: Expected DNS name '$expected_dns' not found in certificate for $cert_name"
                    return 1
                  fi
                done
                
                echo "DNS names validation successful for $cert_name"
                return 0
              }
              
              # Function to repair certificate
              repair_certificate() {
                local cert_name=$1
                local namespace=$2
                local service_name=$3
                local reason=$4
                
                echo "Repairing certificate for $cert_name in $namespace (reason: $reason)"
                
                if [ "$DRY_RUN" = "true" ]; then
                  echo "DRY RUN: Would repair certificate for $cert_name"
                  return 0
                fi
                
                if [ "$AUTO_REPAIR" != "true" ]; then
                  echo "Auto repair is disabled, skipping repair for $cert_name"
                  return 0
                fi
                
                # Generate new private key
                openssl genrsa -out /tmp/new_private.key 2048
                
                # Get service DNS names from existing certificate or use defaults
                dns_names="$service_name,$service_name.$namespace.svc.cluster.local,localhost"
                
                # Create CSR configuration
                cat > /tmp/csr.conf <<EOF
              [req]
              distinguished_name = req_distinguished_name
              req_extensions = v3_req
              prompt = no
              
              [req_distinguished_name]
              CN = $service_name
              O = Alt RSS Reader
              
              [v3_req]
              keyUsage = keyEncipherment, dataEncipherment
              extendedKeyUsage = serverAuth
              subjectAltName = @alt_names
              
              [alt_names]
              EOF
                
                # Add DNS names to CSR
                dns_count=1
                for dns in $(echo $dns_names | tr ',' ' '); do
                  echo "DNS.$dns_count = $dns" >> /tmp/csr.conf
                  dns_count=$((dns_count + 1))
                done
                
                # Add IP addresses
                echo "IP.1 = 127.0.0.1" >> /tmp/csr.conf
                
                # Generate CSR
                openssl req -new -key /tmp/new_private.key -out /tmp/new_certificate.csr -config /tmp/csr.conf
                
                # Create new CertificateSigningRequest
                csr_name="$service_name-$namespace-repair-$(date +%s)"
                cat > /tmp/k8s_csr.yaml <<EOF
              apiVersion: certificates.k8s.io/v1
              kind: CertificateSigningRequest
              metadata:
                name: $csr_name
                labels:
                  app.kubernetes.io/managed-by: cert-lifecycle
                  app.kubernetes.io/component: ssl-certificate
                  app.kubernetes.io/service: $service_name
                  app.kubernetes.io/namespace: $namespace
                  cert-repair-reason: $reason
              spec:
                request: $(cat /tmp/new_certificate.csr | base64 | tr -d '\n')
                signerName: $SIGNER_NAME
                usages:
                - digital signature
                - key encipherment
                - server auth
              EOF
                
                # Submit CSR
                if kubectl apply -f /tmp/k8s_csr.yaml; then
                  echo "Repair CSR submitted successfully: $csr_name"
                  
                  # Wait for CSR to be approved and signed
                  echo "Waiting for CSR approval..."
                  for i in {1..30}; do
                    if kubectl get csr $csr_name -o jsonpath='{.status.certificate}' | grep -q "LS0t"; then
                      echo "CSR approved and signed"
                      break
                    fi
                    sleep 2
                  done
                  
                  # Get signed certificate
                  signed_cert=$(kubectl get csr $csr_name -o jsonpath='{.status.certificate}')
                  if [ -n "$signed_cert" ]; then
                    # Update secret with new certificate
                    kubectl patch secret $cert_name -n $namespace --type='merge' -p="{\"data\":{\"tls.crt\":\"$signed_cert\",\"tls.key\":\"$(cat /tmp/new_private.key | base64 | tr -d '\n')\"}}"
                    
                    # Add repair annotation
                    kubectl annotate secret $cert_name -n $namespace cert-repair-date="$(date -u +%Y-%m-%dT%H:%M:%SZ)" --overwrite
                    kubectl annotate secret $cert_name -n $namespace cert-repair-reason="$reason" --overwrite
                    
                    echo "Certificate repaired successfully for $cert_name"
                    
                    # Clean up CSR
                    kubectl delete csr $csr_name
                    
                    return 0
                  else
                    echo "Error: Failed to get signed certificate during repair"
                    return 1
                  fi
                else
                  echo "Error: Failed to submit repair CSR"
                  return 1
                fi
              }
              
              # Function to cleanup expired CSRs
              cleanup_expired_csrs() {
                echo "Cleaning up expired CSRs..."
                
                # Get all CSRs older than 24 hours
                kubectl get csr -o jsonpath='{.items[?(@.status.conditions[0].type=="Approved")].metadata.name}' | tr ' ' '\n' | while read csr_name; do
                  if [ -n "$csr_name" ]; then
                    # Check if CSR is older than 24 hours
                    csr_age=$(kubectl get csr $csr_name -o jsonpath='{.metadata.creationTimestamp}')
                    csr_age_seconds=$(date -d "$csr_age" +%s)
                    current_seconds=$(date +%s)
                    age_diff=$((current_seconds - csr_age_seconds))
                    
                    if [ $age_diff -gt 86400 ]; then  # 24 hours
                      echo "Cleaning up old CSR: $csr_name (age: $((age_diff / 3600)) hours)"
                      if [ "$DRY_RUN" != "true" ]; then
                        kubectl delete csr $csr_name
                      fi
                    fi
                  fi
                done
              }
              
              # Main lifecycle management loop
              total_certs=0
              healthy_certs=0
              warning_certs=0
              repaired_certs=0
              failed_certs=0
              
              for namespace in $(echo $NAMESPACES | tr ',' ' '); do
                echo "Processing namespace: $namespace"
                
                # Get all SSL certificate secrets
                secrets=$(kubectl get secrets -n $namespace -l app.kubernetes.io/component=ssl-certificate -o jsonpath='{.items[*].metadata.name}')
                
                for secret in $secrets; do
                  if [ -n "$secret" ]; then
                    total_certs=$((total_certs + 1))
                    
                    # Extract service name from secret name
                    service_name=$(echo $secret | sed 's/-ssl-certs-prod$//' | sed 's/-tls-cert$//')
                    
                    echo "Processing certificate: $secret (service: $service_name)"
                    
                    # Get certificate data
                    cert_data=$(kubectl get secret $secret -n $namespace -o jsonpath='{.data.tls\.crt}')
                    key_data=$(kubectl get secret $secret -n $namespace -o jsonpath='{.data.tls\.key}')
                    ca_data=$(kubectl get secret $secret -n $namespace -o jsonpath='{.data.ca\.crt}')
                    
                    if [ -z "$cert_data" ] || [ -z "$key_data" ]; then
                      echo "ERROR: Missing certificate data for $secret"
                      failed_certs=$((failed_certs + 1))
                      continue
                    fi
                    
                    # Validate certificate chain
                    chain_result=0
                    if [ -n "$ca_data" ]; then
                      validate_cert_chain $secret $namespace "$cert_data" "$ca_data"
                      chain_result=$?
                    fi
                    
                    # Validate key pair
                    validate_key_pair $secret $namespace "$cert_data" "$key_data"
                    key_result=$?
                    
                    # Validate DNS names (if configured)
                    dns_result=0
                    # TODO: Add DNS name validation based on service configuration
                    
                    # Determine overall certificate health
                    if [ $chain_result -eq 1 ] || [ $key_result -eq 1 ]; then
                      echo "Certificate $secret requires repair"
                      repair_reason="validation_failed"
                      if [ $chain_result -eq 1 ]; then
                        repair_reason="chain_validation_failed"
                      elif [ $key_result -eq 1 ]; then
                        repair_reason="key_validation_failed"
                      fi
                      
                      if repair_certificate $secret $namespace $service_name $repair_reason; then
                        repaired_certs=$((repaired_certs + 1))
                      else
                        failed_certs=$((failed_certs + 1))
                      fi
                    elif [ $chain_result -eq 2 ]; then
                      echo "Certificate $secret expires soon"
                      warning_certs=$((warning_certs + 1))
                    else
                      echo "Certificate $secret is healthy"
                      healthy_certs=$((healthy_certs + 1))
                    fi
                  fi
                done
              done
              
              # Cleanup old CSRs
              cleanup_expired_csrs
              
              # Report summary
              echo ""
              echo "Certificate lifecycle management summary:"
              echo "Total certificates processed: $total_certs"
              echo "Healthy certificates: $healthy_certs"
              echo "Warning certificates: $warning_certs"
              echo "Repaired certificates: $repaired_certs"
              echo "Failed certificates: $failed_certs"
              echo ""
              
              # Exit with appropriate code
              if [ $failed_certs -gt 0 ]; then
                echo "Some certificates failed validation or repair"
                exit 1
              elif [ $warning_certs -gt 0 ]; then
                echo "Some certificates have warnings"
                exit 0
              else
                echo "All certificates are healthy"
                exit 0
              fi
            resources:
              limits:
                cpu: 200m
                memory: 256Mi
              requests:
                cpu: 100m
                memory: 128Mi
            securityContext:
              runAsNonRoot: true
              runAsUser: 65534
              allowPrivilegeEscalation: false
              readOnlyRootFilesystem: true
              capabilities:
                drop:
                - ALL
            volumeMounts:
            - name: tmp
              mountPath: /tmp
          volumes:
          - name: tmp
            emptyDir: {}
          {{- with .Values.nodeSelector }}
          nodeSelector:
            {{- toYaml . | nindent 12 }}
          {{- end }}
          {{- with .Values.affinity }}
          affinity:
            {{- toYaml . | nindent 12 }}
          {{- end }}
          {{- with .Values.tolerations }}
          tolerations:
            {{- toYaml . | nindent 12 }}
          {{- end }}
{{- end }}